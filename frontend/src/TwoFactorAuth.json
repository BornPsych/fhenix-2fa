{
  "address": "0xbeb4eF1fcEa618C6ca38e3828B00f8D481EC2CC2",
  "abi": [
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "_owner",
          "type": "address"
        }
      ],
      "stateMutability": "nonpayable",
      "type": "constructor"
    },
    {
      "inputs": [],
      "name": "ECDSAInvalidSignature",
      "type": "error"
    },
    {
      "inputs": [
        {
          "internalType": "uint256",
          "name": "length",
          "type": "uint256"
        }
      ],
      "name": "ECDSAInvalidSignatureLength",
      "type": "error"
    },
    {
      "inputs": [
        {
          "internalType": "bytes32",
          "name": "s",
          "type": "bytes32"
        }
      ],
      "name": "ECDSAInvalidSignatureS",
      "type": "error"
    },
    {
      "inputs": [],
      "name": "InvalidShortString",
      "type": "error"
    },
    {
      "inputs": [],
      "name": "SignerNotMessageSender",
      "type": "error"
    },
    {
      "inputs": [],
      "name": "SignerNotOwner",
      "type": "error"
    },
    {
      "inputs": [
        {
          "internalType": "string",
          "name": "str",
          "type": "string"
        }
      ],
      "name": "StringTooLong",
      "type": "error"
    },
    {
      "anonymous": false,
      "inputs": [],
      "name": "EIP712DomainChanged",
      "type": "event"
    },
    {
      "anonymous": false,
      "inputs": [
        {
          "indexed": true,
          "internalType": "address",
          "name": "user",
          "type": "address"
        },
        {
          "indexed": true,
          "internalType": "address",
          "name": "secondarySigner",
          "type": "address"
        }
      ],
      "name": "LoginApproved",
      "type": "event"
    },
    {
      "anonymous": false,
      "inputs": [
        {
          "indexed": true,
          "internalType": "address",
          "name": "user",
          "type": "address"
        }
      ],
      "name": "LoginRequested",
      "type": "event"
    },
    {
      "anonymous": false,
      "inputs": [
        {
          "indexed": true,
          "internalType": "address",
          "name": "user",
          "type": "address"
        },
        {
          "indexed": true,
          "internalType": "address",
          "name": "secondarySigner",
          "type": "address"
        }
      ],
      "name": "Registered",
      "type": "event"
    },
    {
      "inputs": [],
      "name": "PASSWORD_VALIDITY_DURATION",
      "outputs": [
        {
          "internalType": "uint256",
          "name": "",
          "type": "uint256"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "TIME_INTERVAL",
      "outputs": [
        {
          "internalType": "uint256",
          "name": "",
          "type": "uint256"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "components": [
            {
              "internalType": "bytes32",
              "name": "publicKey",
              "type": "bytes32"
            },
            {
              "internalType": "bytes",
              "name": "signature",
              "type": "bytes"
            }
          ],
          "internalType": "struct Permission",
          "name": "perm",
          "type": "tuple"
        },
        {
          "internalType": "address",
          "name": "service",
          "type": "address"
        }
      ],
      "name": "addServiceToWhitelist",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "_user",
          "type": "address"
        },
        {
          "components": [
            {
              "internalType": "bytes",
              "name": "data",
              "type": "bytes"
            }
          ],
          "internalType": "struct inEuint256",
          "name": "_tempPassword",
          "type": "tuple"
        }
      ],
      "name": "approveLogin",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "",
          "type": "address"
        }
      ],
      "name": "authData",
      "outputs": [
        {
          "internalType": "uint256",
          "name": "lastRequestTime",
          "type": "uint256"
        },
        {
          "internalType": "address",
          "name": "secondarySigner",
          "type": "address"
        },
        {
          "internalType": "bool",
          "name": "isApproved",
          "type": "bool"
        },
        {
          "internalType": "uint256",
          "name": "lastApprovalTime",
          "type": "uint256"
        },
        {
          "internalType": "euint256",
          "name": "encryptedPassword",
          "type": "uint256"
        },
        {
          "internalType": "bytes32",
          "name": "userPublicKey",
          "type": "bytes32"
        },
        {
          "internalType": "uint256",
          "name": "validUntil",
          "type": "uint256"
        },
        {
          "internalType": "uint8",
          "name": "passwordAttempts",
          "type": "uint8"
        },
        {
          "internalType": "bool",
          "name": "passwordUsed",
          "type": "bool"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "eip712Domain",
      "outputs": [
        {
          "internalType": "bytes1",
          "name": "fields",
          "type": "bytes1"
        },
        {
          "internalType": "string",
          "name": "name",
          "type": "string"
        },
        {
          "internalType": "string",
          "name": "version",
          "type": "string"
        },
        {
          "internalType": "uint256",
          "name": "chainId",
          "type": "uint256"
        },
        {
          "internalType": "address",
          "name": "verifyingContract",
          "type": "address"
        },
        {
          "internalType": "bytes32",
          "name": "salt",
          "type": "bytes32"
        },
        {
          "internalType": "uint256[]",
          "name": "extensions",
          "type": "uint256[]"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "getEncryptedPassword",
      "outputs": [
        {
          "internalType": "string",
          "name": "encryptedPassword",
          "type": "string"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "components": [
            {
              "internalType": "bytes32",
              "name": "publicKey",
              "type": "bytes32"
            },
            {
              "internalType": "bytes",
              "name": "signature",
              "type": "bytes"
            }
          ],
          "internalType": "struct Permission",
          "name": "perm",
          "type": "tuple"
        },
        {
          "internalType": "address",
          "name": "_secondarySigner",
          "type": "address"
        }
      ],
      "name": "register",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "components": [
            {
              "internalType": "bytes32",
              "name": "publicKey",
              "type": "bytes32"
            },
            {
              "internalType": "bytes",
              "name": "signature",
              "type": "bytes"
            }
          ],
          "internalType": "struct Permission",
          "name": "perm",
          "type": "tuple"
        },
        {
          "internalType": "address",
          "name": "service",
          "type": "address"
        }
      ],
      "name": "removeServiceFromWhitelist",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "requestLogin",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "components": [
            {
              "internalType": "bytes32",
              "name": "publicKey",
              "type": "bytes32"
            },
            {
              "internalType": "bytes",
              "name": "signature",
              "type": "bytes"
            }
          ],
          "internalType": "struct Permission",
          "name": "perm",
          "type": "tuple"
        },
        {
          "internalType": "address",
          "name": "_service",
          "type": "address"
        },
        {
          "internalType": "address",
          "name": "_user",
          "type": "address"
        },
        {
          "components": [
            {
              "internalType": "bytes",
              "name": "data",
              "type": "bytes"
            }
          ],
          "internalType": "struct inEuint256",
          "name": "_encryptedTempPassword",
          "type": "tuple"
        }
      ],
      "name": "verifyTempPassword",
      "outputs": [
        {
          "internalType": "bool",
          "name": "",
          "type": "bool"
        }
      ],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "",
          "type": "address"
        }
      ],
      "name": "whitelistedServices",
      "outputs": [
        {
          "internalType": "bool",
          "name": "",
          "type": "bool"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    }
  ],
  "transactionHash": "0x8a93f3c86530c4a18de6e49c8da779c3218855f9a9592a2b607097b5d189b1ff",
  "receipt": {
    "to": null,
    "from": "0xd7702EB6Ca4C101C918f7d4eaBeDc36e36260482",
    "contractAddress": "0xbeb4eF1fcEa618C6ca38e3828B00f8D481EC2CC2",
    "transactionIndex": 1,
    "gasUsed": "2794990",
    "logsBloom": "0x00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000",
    "blockHash": "0x63b83d7f5433f985746c0938a859d77c7ea91f8e70d9475ff35f3d1a9274e490",
    "transactionHash": "0x8a93f3c86530c4a18de6e49c8da779c3218855f9a9592a2b607097b5d189b1ff",
    "logs": [],
    "blockNumber": 24,
    "cumulativeGasUsed": "2794990",
    "status": 1,
    "byzantium": true
  },
  "args": ["0xd7702EB6Ca4C101C918f7d4eaBeDc36e36260482"],
  "numDeployments": 1,
  "solcInputHash": "d9eda569f7733500e023fd346cb00198",
  "metadata": "{\"compiler\":{\"version\":\"0.8.25+commit.b61c2a91\"},\"language\":\"Solidity\",\"output\":{\"abi\":[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_owner\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"inputs\":[],\"name\":\"ECDSAInvalidSignature\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"length\",\"type\":\"uint256\"}],\"name\":\"ECDSAInvalidSignatureLength\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"s\",\"type\":\"bytes32\"}],\"name\":\"ECDSAInvalidSignatureS\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"InvalidShortString\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"SignerNotMessageSender\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"SignerNotOwner\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"string\",\"name\":\"str\",\"type\":\"string\"}],\"name\":\"StringTooLong\",\"type\":\"error\"},{\"anonymous\":false,\"inputs\":[],\"name\":\"EIP712DomainChanged\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"secondarySigner\",\"type\":\"address\"}],\"name\":\"LoginApproved\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"}],\"name\":\"LoginRequested\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"secondarySigner\",\"type\":\"address\"}],\"name\":\"Registered\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"PASSWORD_VALIDITY_DURATION\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"TIME_INTERVAL\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"components\":[{\"internalType\":\"bytes32\",\"name\":\"publicKey\",\"type\":\"bytes32\"},{\"internalType\":\"bytes\",\"name\":\"signature\",\"type\":\"bytes\"}],\"internalType\":\"struct Permission\",\"name\":\"perm\",\"type\":\"tuple\"},{\"internalType\":\"address\",\"name\":\"service\",\"type\":\"address\"}],\"name\":\"addServiceToWhitelist\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_user\",\"type\":\"address\"},{\"components\":[{\"internalType\":\"bytes\",\"name\":\"data\",\"type\":\"bytes\"}],\"internalType\":\"struct inEuint256\",\"name\":\"_tempPassword\",\"type\":\"tuple\"}],\"name\":\"approveLogin\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"authData\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"lastRequestTime\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"secondarySigner\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"isApproved\",\"type\":\"bool\"},{\"internalType\":\"uint256\",\"name\":\"lastApprovalTime\",\"type\":\"uint256\"},{\"internalType\":\"euint256\",\"name\":\"encryptedPassword\",\"type\":\"uint256\"},{\"internalType\":\"bytes32\",\"name\":\"userPublicKey\",\"type\":\"bytes32\"},{\"internalType\":\"uint256\",\"name\":\"validUntil\",\"type\":\"uint256\"},{\"internalType\":\"uint8\",\"name\":\"passwordAttempts\",\"type\":\"uint8\"},{\"internalType\":\"bool\",\"name\":\"passwordUsed\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"eip712Domain\",\"outputs\":[{\"internalType\":\"bytes1\",\"name\":\"fields\",\"type\":\"bytes1\"},{\"internalType\":\"string\",\"name\":\"name\",\"type\":\"string\"},{\"internalType\":\"string\",\"name\":\"version\",\"type\":\"string\"},{\"internalType\":\"uint256\",\"name\":\"chainId\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"verifyingContract\",\"type\":\"address\"},{\"internalType\":\"bytes32\",\"name\":\"salt\",\"type\":\"bytes32\"},{\"internalType\":\"uint256[]\",\"name\":\"extensions\",\"type\":\"uint256[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getEncryptedPassword\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"encryptedPassword\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"components\":[{\"internalType\":\"bytes32\",\"name\":\"publicKey\",\"type\":\"bytes32\"},{\"internalType\":\"bytes\",\"name\":\"signature\",\"type\":\"bytes\"}],\"internalType\":\"struct Permission\",\"name\":\"perm\",\"type\":\"tuple\"},{\"internalType\":\"address\",\"name\":\"_secondarySigner\",\"type\":\"address\"}],\"name\":\"register\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"components\":[{\"internalType\":\"bytes32\",\"name\":\"publicKey\",\"type\":\"bytes32\"},{\"internalType\":\"bytes\",\"name\":\"signature\",\"type\":\"bytes\"}],\"internalType\":\"struct Permission\",\"name\":\"perm\",\"type\":\"tuple\"},{\"internalType\":\"address\",\"name\":\"service\",\"type\":\"address\"}],\"name\":\"removeServiceFromWhitelist\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"requestLogin\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"components\":[{\"internalType\":\"bytes32\",\"name\":\"publicKey\",\"type\":\"bytes32\"},{\"internalType\":\"bytes\",\"name\":\"signature\",\"type\":\"bytes\"}],\"internalType\":\"struct Permission\",\"name\":\"perm\",\"type\":\"tuple\"},{\"internalType\":\"address\",\"name\":\"_service\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_user\",\"type\":\"address\"},{\"components\":[{\"internalType\":\"bytes\",\"name\":\"data\",\"type\":\"bytes\"}],\"internalType\":\"struct inEuint256\",\"name\":\"_encryptedTempPassword\",\"type\":\"tuple\"}],\"name\":\"verifyTempPassword\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"whitelistedServices\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"}],\"devdoc\":{\"details\":\"A smart contract for implementing a two-factor authentication (2FA) system. This contract allows users to register, request login, approve login, and verify temporary passwords.\",\"errors\":{\"ECDSAInvalidSignature()\":[{\"details\":\"The signature derives the `address(0)`.\"}],\"ECDSAInvalidSignatureLength(uint256)\":[{\"details\":\"The signature has an invalid length.\"}],\"ECDSAInvalidSignatureS(bytes32)\":[{\"details\":\"The signature has an S value that is in the upper half order.\"}]},\"events\":{\"EIP712DomainChanged()\":{\"details\":\"MAY be emitted to signal that the domain could have changed.\"}},\"kind\":\"dev\",\"methods\":{\"addServiceToWhitelist((bytes32,bytes),address)\":{\"details\":\"Adds a service to the whitelist.\",\"params\":{\"perm\":\"The permission object for access control.\",\"service\":\"The address of the service to be added.\"}},\"approveLogin(address,(bytes))\":{\"details\":\"Approves a login request from the secondary signer.\",\"params\":{\"_user\":\"The address of the user requesting login.\"}},\"eip712Domain()\":{\"details\":\"See {IERC-5267}.\"},\"getEncryptedPassword()\":{\"details\":\"Retrieves the encrypted password for a user.\",\"returns\":{\"encryptedPassword\":\"The sealed encrypted password.\"}},\"register((bytes32,bytes),address)\":{\"details\":\"Registers a user with a secondary signer and user public key.\",\"params\":{\"_secondarySigner\":\"The address of the secondary signer.\",\"perm\":\"The permission object for access control.\"}},\"removeServiceFromWhitelist((bytes32,bytes),address)\":{\"details\":\"Removes a service from the whitelist.\",\"params\":{\"perm\":\"The permission object for access control.\",\"service\":\"The address of the service to be removed.\"}},\"requestLogin()\":{\"details\":\"Requests a login, resetting the approval status.\"},\"verifyTempPassword((bytes32,bytes),address,address,(bytes))\":{\"details\":\"Verifies the temporary password for a user by a whitelisted service.\",\"params\":{\"_encryptedTempPassword\":\"The encrypted temporary password provided by the service.\",\"_service\":\"The address of the service verifying the password.\",\"_user\":\"The address of the user.\",\"perm\":\"The permission object for access control.\"},\"returns\":{\"_0\":\"True if the password is valid, false otherwise.\"}}},\"title\":\"TwoFactorAuth\",\"version\":1},\"userdoc\":{\"errors\":{\"SignerNotMessageSender()\":[{\"notice\":\"Emitted when the signer is not the message sender\"}],\"SignerNotOwner()\":[{\"notice\":\"Emitted when the signer is not the specified owner\"}]},\"kind\":\"user\",\"methods\":{},\"version\":1}},\"settings\":{\"compilationTarget\":{\"contracts/TwoFactorAuth.sol\":\"TwoFactorAuth\"},\"evmVersion\":\"paris\",\"libraries\":{},\"metadata\":{\"bytecodeHash\":\"ipfs\",\"useLiteralContent\":true},\"optimizer\":{\"enabled\":false,\"runs\":200},\"remappings\":[]},\"sources\":{\"@fhenixprotocol/contracts/FHE.sol\":{\"content\":\"// SPDX-License-Identifier: BSD-3-Clause-Clear\\n// solhint-disable one-contract-per-file\\n\\npragma solidity >=0.8.19 <=0.8.25;\\n\\nimport {Precompiles, FheOps} from \\\"./FheOS.sol\\\";\\n\\ntype ebool is uint256;\\ntype euint8 is uint256;\\ntype euint16 is uint256;\\ntype euint32 is uint256;\\ntype euint64 is uint256;\\ntype euint128 is uint256;\\ntype euint256 is uint256;\\ntype eaddress is uint256;\\n\\nstruct inEbool {\\n    bytes data;\\n}\\nstruct inEuint8 {\\n    bytes data;\\n}\\nstruct inEuint16 {\\n    bytes data;\\n}\\nstruct inEuint32 {\\n    bytes data;\\n}\\nstruct inEuint64 {\\n    bytes data;\\n}\\nstruct inEuint128 {\\n    bytes data;\\n}\\nstruct inEuint256 {\\n    bytes data;\\n}\\nstruct inEaddress {\\n    bytes data;\\n}\\n\\nstruct SealedArray {\\n  bytes[] data;\\n}\\n\\nlibrary Common {\\n    // Values used to communicate types to the runtime.\\n    // Must match values defined in warp-drive protobufs for everything to \\n    // make sense\\n    uint8 internal constant EUINT8_TFHE = 0;\\n    uint8 internal constant EUINT16_TFHE = 1;\\n    uint8 internal constant EUINT32_TFHE = 2;\\n    uint8 internal constant EUINT64_TFHE = 3;\\n    uint8 internal constant EUINT128_TFHE = 4;\\n    uint8 internal constant EUINT256_TFHE = 5;\\n    uint8 internal constant EADDRESS_TFHE = 12;\\n    // uint8 internal constant INT_BGV = 12;\\n    uint8 internal constant EBOOL_TFHE = 13;\\n    \\n    function bigIntToBool(uint256 i) internal pure returns (bool) {\\n        return (i > 0);\\n    }\\n\\n    function bigIntToUint8(uint256 i) internal pure returns (uint8) {\\n        return uint8(i);\\n    }\\n\\n    function bigIntToUint16(uint256 i) internal pure returns (uint16) {\\n        return uint16(i);\\n    }\\n\\n    function bigIntToUint32(uint256 i) internal pure returns (uint32) {\\n        return uint32(i);\\n    }\\n\\n    function bigIntToUint64(uint256 i) internal pure returns (uint64) {\\n        return uint64(i);\\n    }\\n\\n    function bigIntToUint128(uint256 i) internal pure returns (uint128) {\\n        return uint128(i);\\n    }\\n\\n    function bigIntToUint256(uint256 i) internal pure returns (uint256) {\\n        return i;\\n    }\\n\\n    function bigIntToAddress(uint256 i) internal pure returns (address) {\\n      return address(uint160(i));\\n    }\\n    \\n    function toBytes(uint256 x) internal pure returns (bytes memory b) {\\n        b = new bytes(32);\\n        assembly { mstore(add(b, 32), x) }\\n    }\\n}\\n\\nlibrary Impl {\\n    function sealoutput(uint8 utype, uint256 ciphertext, bytes32 publicKey) internal pure returns (string memory reencrypted) {\\n        // Call the sealoutput precompile.\\n        reencrypted = FheOps(Precompiles.Fheos).sealOutput(utype, Common.toBytes(ciphertext), bytes.concat(publicKey));\\n\\n        return reencrypted;\\n    }\\n\\n    function verify(bytes memory _ciphertextBytes, uint8 _toType) internal pure returns (uint256 result) {\\n        bytes memory output;\\n\\n        // Call the verify precompile.\\n        output = FheOps(Precompiles.Fheos).verify(_toType, _ciphertextBytes);\\n        result = getValue(output);\\n    }\\n\\n    function cast(uint8 utype, uint256 ciphertext, uint8 toType) internal pure returns (uint256 result) {\\n        bytes memory output;\\n\\n        // Call the cast precompile.\\n        output = FheOps(Precompiles.Fheos).cast(utype, Common.toBytes(ciphertext), toType);\\n        result = getValue(output);\\n    }\\n\\n    function getValue(bytes memory a) internal pure returns (uint256 value) {\\n        assembly {\\n            value := mload(add(a, 0x20))\\n        }\\n    }\\n\\n    function trivialEncrypt(uint256 value, uint8 toType) internal pure returns (uint256 result) {\\n        bytes memory output;\\n\\n        // Call the trivialEncrypt precompile.\\n        output = FheOps(Precompiles.Fheos).trivialEncrypt(Common.toBytes(value), toType);\\n\\n        result = getValue(output);\\n    }\\n\\n    function select(uint8 utype, uint256 control, uint256 ifTrue, uint256 ifFalse) internal pure returns (uint256 result) {\\n        bytes memory output;\\n\\n        // Call the trivialEncrypt precompile.\\n        output = FheOps(Precompiles.Fheos).select(utype, Common.toBytes(control), Common.toBytes(ifTrue), Common.toBytes(ifFalse));\\n\\n        result = getValue(output);\\n    }\\n}\\n\\nlibrary FHE {\\n    euint8 public constant NIL8 = euint8.wrap(0);\\n    euint16 public constant NIL16 = euint16.wrap(0);\\n    euint32 public constant NIL32 = euint32.wrap(0);\\n\\n    // Return true if the encrypted integer is initialized and false otherwise.\\n    function isInitialized(ebool v) internal pure returns (bool) {\\n        return ebool.unwrap(v) != 0;\\n    }\\n\\n    // Return true if the encrypted integer is initialized and false otherwise.\\n    function isInitialized(euint8 v) internal pure returns (bool) {\\n        return euint8.unwrap(v) != 0;\\n    }\\n\\n    // Return true if the encrypted integer is initialized and false otherwise.\\n    function isInitialized(euint16 v) internal pure returns (bool) {\\n        return euint16.unwrap(v) != 0;\\n    }\\n\\n    // Return true if the encrypted integer is initialized and false otherwise.\\n    function isInitialized(euint32 v) internal pure returns (bool) {\\n        return euint32.unwrap(v) != 0;\\n    }\\n    \\n    // Return true if the encrypted integer is initialized and false otherwise.\\n    function isInitialized(euint64 v) internal pure returns (bool) {\\n        return euint64.unwrap(v) != 0;\\n    }\\n    \\n        // Return true if the encrypted integer is initialized and false otherwise.\\n    function isInitialized(euint128 v) internal pure returns (bool) {\\n        return euint128.unwrap(v) != 0;\\n    }\\n    \\n        // Return true if the encrypted integer is initialized and false otherwise.\\n    function isInitialized(euint256 v) internal pure returns (bool) {\\n        return euint256.unwrap(v) != 0;\\n    }\\n\\n    function isInitialized(eaddress v) internal pure returns (bool) {\\n        return eaddress.unwrap(v) != 0;\\n    }\\n\\n    function getValue(bytes memory a) private pure returns (uint256 value) {\\n        assembly {\\n            value := mload(add(a, 0x20))\\n        }\\n    }\\n    \\n    function mathHelper(\\n        uint8 utype,\\n        uint256 lhs,\\n        uint256 rhs,\\n        function(uint8, bytes memory, bytes memory) external pure returns (bytes memory) impl\\n    ) internal pure returns (uint256 result) {\\n        bytes memory output;\\n        output = impl(utype, Common.toBytes(lhs), Common.toBytes(rhs));\\n        result = getValue(output);\\n    }\\n    \\n    /// @notice This functions performs the add operation\\n    /// @dev If any of the inputs are expected to be a ciphertext, it verifies that the value matches a valid ciphertext\\n    ///Pure in this function is marked as a hack/workaround - note that this function is NOT pure as fetches of ciphertexts require state access\\n    /// @param lhs The first input \\n    /// @param rhs The second input\\n    /// @return The result of the operation\\n    function add(euint8 lhs, euint8 rhs) internal pure returns (euint8) {\\n        if (!isInitialized(lhs)) {\\n            lhs = asEuint8(0);\\n        }\\n        if (!isInitialized(rhs)) {\\n            rhs = asEuint8(0);\\n        }\\n        uint256 unwrappedInput1 = euint8.unwrap(lhs);\\n        uint256 unwrappedInput2 = euint8.unwrap(rhs);\\n\\n        uint256 result = mathHelper(Common.EUINT8_TFHE, unwrappedInput1, unwrappedInput2, FheOps(Precompiles.Fheos).add);\\n        return euint8.wrap(result);\\n    }\\n    /// @notice This functions performs the add operation\\n    /// @dev If any of the inputs are expected to be a ciphertext, it verifies that the value matches a valid ciphertext\\n    ///Pure in this function is marked as a hack/workaround - note that this function is NOT pure as fetches of ciphertexts require state access\\n    /// @param lhs The first input \\n    /// @param rhs The second input\\n    /// @return The result of the operation\\n    function add(euint16 lhs, euint16 rhs) internal pure returns (euint16) {\\n        if (!isInitialized(lhs)) {\\n            lhs = asEuint16(0);\\n        }\\n        if (!isInitialized(rhs)) {\\n            rhs = asEuint16(0);\\n        }\\n        uint256 unwrappedInput1 = euint16.unwrap(lhs);\\n        uint256 unwrappedInput2 = euint16.unwrap(rhs);\\n\\n        uint256 result = mathHelper(Common.EUINT16_TFHE, unwrappedInput1, unwrappedInput2, FheOps(Precompiles.Fheos).add);\\n        return euint16.wrap(result);\\n    }\\n    /// @notice This functions performs the add operation\\n    /// @dev If any of the inputs are expected to be a ciphertext, it verifies that the value matches a valid ciphertext\\n    ///Pure in this function is marked as a hack/workaround - note that this function is NOT pure as fetches of ciphertexts require state access\\n    /// @param lhs The first input \\n    /// @param rhs The second input\\n    /// @return The result of the operation\\n    function add(euint32 lhs, euint32 rhs) internal pure returns (euint32) {\\n        if (!isInitialized(lhs)) {\\n            lhs = asEuint32(0);\\n        }\\n        if (!isInitialized(rhs)) {\\n            rhs = asEuint32(0);\\n        }\\n        uint256 unwrappedInput1 = euint32.unwrap(lhs);\\n        uint256 unwrappedInput2 = euint32.unwrap(rhs);\\n\\n        uint256 result = mathHelper(Common.EUINT32_TFHE, unwrappedInput1, unwrappedInput2, FheOps(Precompiles.Fheos).add);\\n        return euint32.wrap(result);\\n    }\\n    /// @notice This functions performs the add operation\\n    /// @dev If any of the inputs are expected to be a ciphertext, it verifies that the value matches a valid ciphertext\\n    ///Pure in this function is marked as a hack/workaround - note that this function is NOT pure as fetches of ciphertexts require state access\\n    /// @param lhs The first input \\n    /// @param rhs The second input\\n    /// @return The result of the operation\\n    function add(euint64 lhs, euint64 rhs) internal pure returns (euint64) {\\n        if (!isInitialized(lhs)) {\\n            lhs = asEuint64(0);\\n        }\\n        if (!isInitialized(rhs)) {\\n            rhs = asEuint64(0);\\n        }\\n        uint256 unwrappedInput1 = euint64.unwrap(lhs);\\n        uint256 unwrappedInput2 = euint64.unwrap(rhs);\\n\\n        uint256 result = mathHelper(Common.EUINT64_TFHE, unwrappedInput1, unwrappedInput2, FheOps(Precompiles.Fheos).add);\\n        return euint64.wrap(result);\\n    }\\n    /// @notice This functions performs the add operation\\n    /// @dev If any of the inputs are expected to be a ciphertext, it verifies that the value matches a valid ciphertext\\n    ///Pure in this function is marked as a hack/workaround - note that this function is NOT pure as fetches of ciphertexts require state access\\n    /// @param lhs The first input \\n    /// @param rhs The second input\\n    /// @return The result of the operation\\n    function add(euint128 lhs, euint128 rhs) internal pure returns (euint128) {\\n        if (!isInitialized(lhs)) {\\n            lhs = asEuint128(0);\\n        }\\n        if (!isInitialized(rhs)) {\\n            rhs = asEuint128(0);\\n        }\\n        uint256 unwrappedInput1 = euint128.unwrap(lhs);\\n        uint256 unwrappedInput2 = euint128.unwrap(rhs);\\n\\n        uint256 result = mathHelper(Common.EUINT128_TFHE, unwrappedInput1, unwrappedInput2, FheOps(Precompiles.Fheos).add);\\n        return euint128.wrap(result);\\n    }\\n    /// @notice performs the sealoutput function on a ebool ciphertext. This operation returns the plaintext value, sealed for the public key provided \\n    /// @dev Pure in this function is marked as a hack/workaround - note that this function is NOT pure as fetches of ciphertexts require state access\\n    /// @param value Ciphertext to decrypt and seal\\n    /// @param publicKey Public Key that will receive the sealed plaintext\\n    /// @return Plaintext input, sealed for the owner of `publicKey`\\n    function sealoutput(ebool value, bytes32 publicKey) internal pure returns (string memory) {\\n        if (!isInitialized(value)) {\\n            value = asEbool(0);\\n        }\\n        uint256 unwrapped = ebool.unwrap(value);\\n\\n        return Impl.sealoutput(Common.EBOOL_TFHE, unwrapped, publicKey);\\n    }\\n    /// @notice performs the sealoutput function on a euint8 ciphertext. This operation returns the plaintext value, sealed for the public key provided \\n    /// @dev Pure in this function is marked as a hack/workaround - note that this function is NOT pure as fetches of ciphertexts require state access\\n    /// @param value Ciphertext to decrypt and seal\\n    /// @param publicKey Public Key that will receive the sealed plaintext\\n    /// @return Plaintext input, sealed for the owner of `publicKey`\\n    function sealoutput(euint8 value, bytes32 publicKey) internal pure returns (string memory) {\\n        if (!isInitialized(value)) {\\n            value = asEuint8(0);\\n        }\\n        uint256 unwrapped = euint8.unwrap(value);\\n\\n        return Impl.sealoutput(Common.EUINT8_TFHE, unwrapped, publicKey);\\n    }\\n    /// @notice performs the sealoutput function on a euint16 ciphertext. This operation returns the plaintext value, sealed for the public key provided \\n    /// @dev Pure in this function is marked as a hack/workaround - note that this function is NOT pure as fetches of ciphertexts require state access\\n    /// @param value Ciphertext to decrypt and seal\\n    /// @param publicKey Public Key that will receive the sealed plaintext\\n    /// @return Plaintext input, sealed for the owner of `publicKey`\\n    function sealoutput(euint16 value, bytes32 publicKey) internal pure returns (string memory) {\\n        if (!isInitialized(value)) {\\n            value = asEuint16(0);\\n        }\\n        uint256 unwrapped = euint16.unwrap(value);\\n\\n        return Impl.sealoutput(Common.EUINT16_TFHE, unwrapped, publicKey);\\n    }\\n    /// @notice performs the sealoutput function on a euint32 ciphertext. This operation returns the plaintext value, sealed for the public key provided \\n    /// @dev Pure in this function is marked as a hack/workaround - note that this function is NOT pure as fetches of ciphertexts require state access\\n    /// @param value Ciphertext to decrypt and seal\\n    /// @param publicKey Public Key that will receive the sealed plaintext\\n    /// @return Plaintext input, sealed for the owner of `publicKey`\\n    function sealoutput(euint32 value, bytes32 publicKey) internal pure returns (string memory) {\\n        if (!isInitialized(value)) {\\n            value = asEuint32(0);\\n        }\\n        uint256 unwrapped = euint32.unwrap(value);\\n\\n        return Impl.sealoutput(Common.EUINT32_TFHE, unwrapped, publicKey);\\n    }\\n    /// @notice performs the sealoutput function on a euint64 ciphertext. This operation returns the plaintext value, sealed for the public key provided \\n    /// @dev Pure in this function is marked as a hack/workaround - note that this function is NOT pure as fetches of ciphertexts require state access\\n    /// @param value Ciphertext to decrypt and seal\\n    /// @param publicKey Public Key that will receive the sealed plaintext\\n    /// @return Plaintext input, sealed for the owner of `publicKey`\\n    function sealoutput(euint64 value, bytes32 publicKey) internal pure returns (string memory) {\\n        if (!isInitialized(value)) {\\n            value = asEuint64(0);\\n        }\\n        uint256 unwrapped = euint64.unwrap(value);\\n\\n        return Impl.sealoutput(Common.EUINT64_TFHE, unwrapped, publicKey);\\n    }\\n    /// @notice performs the sealoutput function on a euint128 ciphertext. This operation returns the plaintext value, sealed for the public key provided \\n    /// @dev Pure in this function is marked as a hack/workaround - note that this function is NOT pure as fetches of ciphertexts require state access\\n    /// @param value Ciphertext to decrypt and seal\\n    /// @param publicKey Public Key that will receive the sealed plaintext\\n    /// @return Plaintext input, sealed for the owner of `publicKey`\\n    function sealoutput(euint128 value, bytes32 publicKey) internal pure returns (string memory) {\\n        if (!isInitialized(value)) {\\n            value = asEuint128(0);\\n        }\\n        uint256 unwrapped = euint128.unwrap(value);\\n\\n        return Impl.sealoutput(Common.EUINT128_TFHE, unwrapped, publicKey);\\n    }\\n    /// @notice performs the sealoutput function on a euint256 ciphertext. This operation returns the plaintext value, sealed for the public key provided \\n    /// @dev Pure in this function is marked as a hack/workaround - note that this function is NOT pure as fetches of ciphertexts require state access\\n    /// @param value Ciphertext to decrypt and seal\\n    /// @param publicKey Public Key that will receive the sealed plaintext\\n    /// @return Plaintext input, sealed for the owner of `publicKey`\\n    function sealoutput(euint256 value, bytes32 publicKey) internal pure returns (string memory) {\\n        if (!isInitialized(value)) {\\n            value = asEuint256(0);\\n        }\\n        uint256 unwrapped = euint256.unwrap(value);\\n\\n        return Impl.sealoutput(Common.EUINT256_TFHE, unwrapped, publicKey);\\n    }\\n    /// @notice performs the sealoutput function on a eaddress ciphertext. This operation returns the plaintext value, sealed for the public key provided \\n    /// @dev Pure in this function is marked as a hack/workaround - note that this function is NOT pure as fetches of ciphertexts require state access\\n    /// @param value Ciphertext to decrypt and seal\\n    /// @param publicKey Public Key that will receive the sealed plaintext\\n    /// @return Plaintext input, sealed for the owner of `publicKey`\\n    function sealoutput(eaddress value, bytes32 publicKey) internal pure returns (string memory) {\\n        if (!isInitialized(value)) {\\n            value = asEaddress(0);\\n        }\\n        uint256 unwrapped = eaddress.unwrap(value);\\n\\n        return Impl.sealoutput(Common.EADDRESS_TFHE, unwrapped, publicKey);\\n    }\\n    /// @notice Performs the decrypt operation on a ciphertext\\n    /// @dev Verifies that the input value matches a valid ciphertext. Pure in this function is marked as a hack/workaround - note that this function is NOT pure as fetches of ciphertexts require state access\\n    /// @param input1 the input ciphertext\\n    function decrypt(ebool input1) internal pure returns (bool) {\\n        if (!isInitialized(input1)) {\\n            input1 = asEbool(0);\\n        }\\n        uint256 unwrappedInput1 = ebool.unwrap(input1);\\n        bytes memory inputAsBytes = Common.toBytes(unwrappedInput1);\\n        uint256 result = FheOps(Precompiles.Fheos).decrypt(Common.EBOOL_TFHE, inputAsBytes);\\n        return Common.bigIntToBool(result);\\n    }\\n    /// @notice Performs the decrypt operation on a ciphertext\\n    /// @dev Verifies that the input value matches a valid ciphertext. Pure in this function is marked as a hack/workaround - note that this function is NOT pure as fetches of ciphertexts require state access\\n    /// @param input1 the input ciphertext\\n    function decrypt(euint8 input1) internal pure returns (uint8) {\\n        if (!isInitialized(input1)) {\\n            input1 = asEuint8(0);\\n        }\\n        uint256 unwrappedInput1 = euint8.unwrap(input1);\\n        bytes memory inputAsBytes = Common.toBytes(unwrappedInput1);\\n        uint256 result = FheOps(Precompiles.Fheos).decrypt(Common.EUINT8_TFHE, inputAsBytes);\\n        return Common.bigIntToUint8(result);\\n    }\\n    /// @notice Performs the decrypt operation on a ciphertext\\n    /// @dev Verifies that the input value matches a valid ciphertext. Pure in this function is marked as a hack/workaround - note that this function is NOT pure as fetches of ciphertexts require state access\\n    /// @param input1 the input ciphertext\\n    function decrypt(euint16 input1) internal pure returns (uint16) {\\n        if (!isInitialized(input1)) {\\n            input1 = asEuint16(0);\\n        }\\n        uint256 unwrappedInput1 = euint16.unwrap(input1);\\n        bytes memory inputAsBytes = Common.toBytes(unwrappedInput1);\\n        uint256 result = FheOps(Precompiles.Fheos).decrypt(Common.EUINT16_TFHE, inputAsBytes);\\n        return Common.bigIntToUint16(result);\\n    }\\n    /// @notice Performs the decrypt operation on a ciphertext\\n    /// @dev Verifies that the input value matches a valid ciphertext. Pure in this function is marked as a hack/workaround - note that this function is NOT pure as fetches of ciphertexts require state access\\n    /// @param input1 the input ciphertext\\n    function decrypt(euint32 input1) internal pure returns (uint32) {\\n        if (!isInitialized(input1)) {\\n            input1 = asEuint32(0);\\n        }\\n        uint256 unwrappedInput1 = euint32.unwrap(input1);\\n        bytes memory inputAsBytes = Common.toBytes(unwrappedInput1);\\n        uint256 result = FheOps(Precompiles.Fheos).decrypt(Common.EUINT32_TFHE, inputAsBytes);\\n        return Common.bigIntToUint32(result);\\n    }\\n    /// @notice Performs the decrypt operation on a ciphertext\\n    /// @dev Verifies that the input value matches a valid ciphertext. Pure in this function is marked as a hack/workaround - note that this function is NOT pure as fetches of ciphertexts require state access\\n    /// @param input1 the input ciphertext\\n    function decrypt(euint64 input1) internal pure returns (uint64) {\\n        if (!isInitialized(input1)) {\\n            input1 = asEuint64(0);\\n        }\\n        uint256 unwrappedInput1 = euint64.unwrap(input1);\\n        bytes memory inputAsBytes = Common.toBytes(unwrappedInput1);\\n        uint256 result = FheOps(Precompiles.Fheos).decrypt(Common.EUINT64_TFHE, inputAsBytes);\\n        return Common.bigIntToUint64(result);\\n    }\\n    /// @notice Performs the decrypt operation on a ciphertext\\n    /// @dev Verifies that the input value matches a valid ciphertext. Pure in this function is marked as a hack/workaround - note that this function is NOT pure as fetches of ciphertexts require state access\\n    /// @param input1 the input ciphertext\\n    function decrypt(euint128 input1) internal pure returns (uint128) {\\n        if (!isInitialized(input1)) {\\n            input1 = asEuint128(0);\\n        }\\n        uint256 unwrappedInput1 = euint128.unwrap(input1);\\n        bytes memory inputAsBytes = Common.toBytes(unwrappedInput1);\\n        uint256 result = FheOps(Precompiles.Fheos).decrypt(Common.EUINT128_TFHE, inputAsBytes);\\n        return Common.bigIntToUint128(result);\\n    }\\n    /// @notice Performs the decrypt operation on a ciphertext\\n    /// @dev Verifies that the input value matches a valid ciphertext. Pure in this function is marked as a hack/workaround - note that this function is NOT pure as fetches of ciphertexts require state access\\n    /// @param input1 the input ciphertext\\n    function decrypt(euint256 input1) internal pure returns (uint256) {\\n        if (!isInitialized(input1)) {\\n            input1 = asEuint256(0);\\n        }\\n        uint256 unwrappedInput1 = euint256.unwrap(input1);\\n        bytes memory inputAsBytes = Common.toBytes(unwrappedInput1);\\n        uint256 result = FheOps(Precompiles.Fheos).decrypt(Common.EUINT256_TFHE, inputAsBytes);\\n        return Common.bigIntToUint256(result);\\n    }\\n    /// @notice Performs the decrypt operation on a ciphertext\\n    /// @dev Verifies that the input value matches a valid ciphertext. Pure in this function is marked as a hack/workaround - note that this function is NOT pure as fetches of ciphertexts require state access\\n    /// @param input1 the input ciphertext\\n    function decrypt(eaddress input1) internal pure returns (address) {\\n        if (!isInitialized(input1)) {\\n            input1 = asEaddress(0);\\n        }\\n        uint256 unwrappedInput1 = eaddress.unwrap(input1);\\n        bytes memory inputAsBytes = Common.toBytes(unwrappedInput1);\\n        uint256 result = FheOps(Precompiles.Fheos).decrypt(Common.EADDRESS_TFHE, inputAsBytes);\\n        return Common.bigIntToAddress(result);\\n    }\\n    /// @notice This functions performs the lte operation\\n    /// @dev If any of the inputs are expected to be a ciphertext, it verifies that the value matches a valid ciphertext\\n    ///Pure in this function is marked as a hack/workaround - note that this function is NOT pure as fetches of ciphertexts require state access\\n    /// @param lhs The first input \\n    /// @param rhs The second input\\n    /// @return The result of the operation\\n    function lte(euint8 lhs, euint8 rhs) internal pure returns (ebool) {\\n        if (!isInitialized(lhs)) {\\n            lhs = asEuint8(0);\\n        }\\n        if (!isInitialized(rhs)) {\\n            rhs = asEuint8(0);\\n        }\\n        uint256 unwrappedInput1 = euint8.unwrap(lhs);\\n        uint256 unwrappedInput2 = euint8.unwrap(rhs);\\n\\n        uint256 result = mathHelper(Common.EUINT8_TFHE, unwrappedInput1, unwrappedInput2, FheOps(Precompiles.Fheos).lte);\\n        return ebool.wrap(result);\\n    }\\n    /// @notice This functions performs the lte operation\\n    /// @dev If any of the inputs are expected to be a ciphertext, it verifies that the value matches a valid ciphertext\\n    ///Pure in this function is marked as a hack/workaround - note that this function is NOT pure as fetches of ciphertexts require state access\\n    /// @param lhs The first input \\n    /// @param rhs The second input\\n    /// @return The result of the operation\\n    function lte(euint16 lhs, euint16 rhs) internal pure returns (ebool) {\\n        if (!isInitialized(lhs)) {\\n            lhs = asEuint16(0);\\n        }\\n        if (!isInitialized(rhs)) {\\n            rhs = asEuint16(0);\\n        }\\n        uint256 unwrappedInput1 = euint16.unwrap(lhs);\\n        uint256 unwrappedInput2 = euint16.unwrap(rhs);\\n\\n        uint256 result = mathHelper(Common.EUINT16_TFHE, unwrappedInput1, unwrappedInput2, FheOps(Precompiles.Fheos).lte);\\n        return ebool.wrap(result);\\n    }\\n    /// @notice This functions performs the lte operation\\n    /// @dev If any of the inputs are expected to be a ciphertext, it verifies that the value matches a valid ciphertext\\n    ///Pure in this function is marked as a hack/workaround - note that this function is NOT pure as fetches of ciphertexts require state access\\n    /// @param lhs The first input \\n    /// @param rhs The second input\\n    /// @return The result of the operation\\n    function lte(euint32 lhs, euint32 rhs) internal pure returns (ebool) {\\n        if (!isInitialized(lhs)) {\\n            lhs = asEuint32(0);\\n        }\\n        if (!isInitialized(rhs)) {\\n            rhs = asEuint32(0);\\n        }\\n        uint256 unwrappedInput1 = euint32.unwrap(lhs);\\n        uint256 unwrappedInput2 = euint32.unwrap(rhs);\\n\\n        uint256 result = mathHelper(Common.EUINT32_TFHE, unwrappedInput1, unwrappedInput2, FheOps(Precompiles.Fheos).lte);\\n        return ebool.wrap(result);\\n    }\\n    /// @notice This functions performs the lte operation\\n    /// @dev If any of the inputs are expected to be a ciphertext, it verifies that the value matches a valid ciphertext\\n    ///Pure in this function is marked as a hack/workaround - note that this function is NOT pure as fetches of ciphertexts require state access\\n    /// @param lhs The first input \\n    /// @param rhs The second input\\n    /// @return The result of the operation\\n    function lte(euint64 lhs, euint64 rhs) internal pure returns (ebool) {\\n        if (!isInitialized(lhs)) {\\n            lhs = asEuint64(0);\\n        }\\n        if (!isInitialized(rhs)) {\\n            rhs = asEuint64(0);\\n        }\\n        uint256 unwrappedInput1 = euint64.unwrap(lhs);\\n        uint256 unwrappedInput2 = euint64.unwrap(rhs);\\n\\n        uint256 result = mathHelper(Common.EUINT64_TFHE, unwrappedInput1, unwrappedInput2, FheOps(Precompiles.Fheos).lte);\\n        return ebool.wrap(result);\\n    }\\n    /// @notice This functions performs the lte operation\\n    /// @dev If any of the inputs are expected to be a ciphertext, it verifies that the value matches a valid ciphertext\\n    ///Pure in this function is marked as a hack/workaround - note that this function is NOT pure as fetches of ciphertexts require state access\\n    /// @param lhs The first input \\n    /// @param rhs The second input\\n    /// @return The result of the operation\\n    function lte(euint128 lhs, euint128 rhs) internal pure returns (ebool) {\\n        if (!isInitialized(lhs)) {\\n            lhs = asEuint128(0);\\n        }\\n        if (!isInitialized(rhs)) {\\n            rhs = asEuint128(0);\\n        }\\n        uint256 unwrappedInput1 = euint128.unwrap(lhs);\\n        uint256 unwrappedInput2 = euint128.unwrap(rhs);\\n\\n        uint256 result = mathHelper(Common.EUINT128_TFHE, unwrappedInput1, unwrappedInput2, FheOps(Precompiles.Fheos).lte);\\n        return ebool.wrap(result);\\n    }\\n    /// @notice This functions performs the sub operation\\n    /// @dev If any of the inputs are expected to be a ciphertext, it verifies that the value matches a valid ciphertext\\n    ///Pure in this function is marked as a hack/workaround - note that this function is NOT pure as fetches of ciphertexts require state access\\n    /// @param lhs The first input \\n    /// @param rhs The second input\\n    /// @return The result of the operation\\n    function sub(euint8 lhs, euint8 rhs) internal pure returns (euint8) {\\n        if (!isInitialized(lhs)) {\\n            lhs = asEuint8(0);\\n        }\\n        if (!isInitialized(rhs)) {\\n            rhs = asEuint8(0);\\n        }\\n        uint256 unwrappedInput1 = euint8.unwrap(lhs);\\n        uint256 unwrappedInput2 = euint8.unwrap(rhs);\\n\\n        uint256 result = mathHelper(Common.EUINT8_TFHE, unwrappedInput1, unwrappedInput2, FheOps(Precompiles.Fheos).sub);\\n        return euint8.wrap(result);\\n    }\\n    /// @notice This functions performs the sub operation\\n    /// @dev If any of the inputs are expected to be a ciphertext, it verifies that the value matches a valid ciphertext\\n    ///Pure in this function is marked as a hack/workaround - note that this function is NOT pure as fetches of ciphertexts require state access\\n    /// @param lhs The first input \\n    /// @param rhs The second input\\n    /// @return The result of the operation\\n    function sub(euint16 lhs, euint16 rhs) internal pure returns (euint16) {\\n        if (!isInitialized(lhs)) {\\n            lhs = asEuint16(0);\\n        }\\n        if (!isInitialized(rhs)) {\\n            rhs = asEuint16(0);\\n        }\\n        uint256 unwrappedInput1 = euint16.unwrap(lhs);\\n        uint256 unwrappedInput2 = euint16.unwrap(rhs);\\n\\n        uint256 result = mathHelper(Common.EUINT16_TFHE, unwrappedInput1, unwrappedInput2, FheOps(Precompiles.Fheos).sub);\\n        return euint16.wrap(result);\\n    }\\n    /// @notice This functions performs the sub operation\\n    /// @dev If any of the inputs are expected to be a ciphertext, it verifies that the value matches a valid ciphertext\\n    ///Pure in this function is marked as a hack/workaround - note that this function is NOT pure as fetches of ciphertexts require state access\\n    /// @param lhs The first input \\n    /// @param rhs The second input\\n    /// @return The result of the operation\\n    function sub(euint32 lhs, euint32 rhs) internal pure returns (euint32) {\\n        if (!isInitialized(lhs)) {\\n            lhs = asEuint32(0);\\n        }\\n        if (!isInitialized(rhs)) {\\n            rhs = asEuint32(0);\\n        }\\n        uint256 unwrappedInput1 = euint32.unwrap(lhs);\\n        uint256 unwrappedInput2 = euint32.unwrap(rhs);\\n\\n        uint256 result = mathHelper(Common.EUINT32_TFHE, unwrappedInput1, unwrappedInput2, FheOps(Precompiles.Fheos).sub);\\n        return euint32.wrap(result);\\n    }\\n    /// @notice This functions performs the sub operation\\n    /// @dev If any of the inputs are expected to be a ciphertext, it verifies that the value matches a valid ciphertext\\n    ///Pure in this function is marked as a hack/workaround - note that this function is NOT pure as fetches of ciphertexts require state access\\n    /// @param lhs The first input \\n    /// @param rhs The second input\\n    /// @return The result of the operation\\n    function sub(euint64 lhs, euint64 rhs) internal pure returns (euint64) {\\n        if (!isInitialized(lhs)) {\\n            lhs = asEuint64(0);\\n        }\\n        if (!isInitialized(rhs)) {\\n            rhs = asEuint64(0);\\n        }\\n        uint256 unwrappedInput1 = euint64.unwrap(lhs);\\n        uint256 unwrappedInput2 = euint64.unwrap(rhs);\\n\\n        uint256 result = mathHelper(Common.EUINT64_TFHE, unwrappedInput1, unwrappedInput2, FheOps(Precompiles.Fheos).sub);\\n        return euint64.wrap(result);\\n    }\\n    /// @notice This functions performs the sub operation\\n    /// @dev If any of the inputs are expected to be a ciphertext, it verifies that the value matches a valid ciphertext\\n    ///Pure in this function is marked as a hack/workaround - note that this function is NOT pure as fetches of ciphertexts require state access\\n    /// @param lhs The first input \\n    /// @param rhs The second input\\n    /// @return The result of the operation\\n    function sub(euint128 lhs, euint128 rhs) internal pure returns (euint128) {\\n        if (!isInitialized(lhs)) {\\n            lhs = asEuint128(0);\\n        }\\n        if (!isInitialized(rhs)) {\\n            rhs = asEuint128(0);\\n        }\\n        uint256 unwrappedInput1 = euint128.unwrap(lhs);\\n        uint256 unwrappedInput2 = euint128.unwrap(rhs);\\n\\n        uint256 result = mathHelper(Common.EUINT128_TFHE, unwrappedInput1, unwrappedInput2, FheOps(Precompiles.Fheos).sub);\\n        return euint128.wrap(result);\\n    }\\n    /// @notice This functions performs the mul operation\\n    /// @dev If any of the inputs are expected to be a ciphertext, it verifies that the value matches a valid ciphertext\\n    ///Pure in this function is marked as a hack/workaround - note that this function is NOT pure as fetches of ciphertexts require state access\\n    /// @param lhs The first input \\n    /// @param rhs The second input\\n    /// @return The result of the operation\\n    function mul(euint8 lhs, euint8 rhs) internal pure returns (euint8) {\\n        if (!isInitialized(lhs)) {\\n            lhs = asEuint8(0);\\n        }\\n        if (!isInitialized(rhs)) {\\n            rhs = asEuint8(0);\\n        }\\n        uint256 unwrappedInput1 = euint8.unwrap(lhs);\\n        uint256 unwrappedInput2 = euint8.unwrap(rhs);\\n\\n        uint256 result = mathHelper(Common.EUINT8_TFHE, unwrappedInput1, unwrappedInput2, FheOps(Precompiles.Fheos).mul);\\n        return euint8.wrap(result);\\n    }\\n    /// @notice This functions performs the mul operation\\n    /// @dev If any of the inputs are expected to be a ciphertext, it verifies that the value matches a valid ciphertext\\n    ///Pure in this function is marked as a hack/workaround - note that this function is NOT pure as fetches of ciphertexts require state access\\n    /// @param lhs The first input \\n    /// @param rhs The second input\\n    /// @return The result of the operation\\n    function mul(euint16 lhs, euint16 rhs) internal pure returns (euint16) {\\n        if (!isInitialized(lhs)) {\\n            lhs = asEuint16(0);\\n        }\\n        if (!isInitialized(rhs)) {\\n            rhs = asEuint16(0);\\n        }\\n        uint256 unwrappedInput1 = euint16.unwrap(lhs);\\n        uint256 unwrappedInput2 = euint16.unwrap(rhs);\\n\\n        uint256 result = mathHelper(Common.EUINT16_TFHE, unwrappedInput1, unwrappedInput2, FheOps(Precompiles.Fheos).mul);\\n        return euint16.wrap(result);\\n    }\\n    /// @notice This functions performs the mul operation\\n    /// @dev If any of the inputs are expected to be a ciphertext, it verifies that the value matches a valid ciphertext\\n    ///Pure in this function is marked as a hack/workaround - note that this function is NOT pure as fetches of ciphertexts require state access\\n    /// @param lhs The first input \\n    /// @param rhs The second input\\n    /// @return The result of the operation\\n    function mul(euint32 lhs, euint32 rhs) internal pure returns (euint32) {\\n        if (!isInitialized(lhs)) {\\n            lhs = asEuint32(0);\\n        }\\n        if (!isInitialized(rhs)) {\\n            rhs = asEuint32(0);\\n        }\\n        uint256 unwrappedInput1 = euint32.unwrap(lhs);\\n        uint256 unwrappedInput2 = euint32.unwrap(rhs);\\n\\n        uint256 result = mathHelper(Common.EUINT32_TFHE, unwrappedInput1, unwrappedInput2, FheOps(Precompiles.Fheos).mul);\\n        return euint32.wrap(result);\\n    }\\n    /// @notice This functions performs the mul operation\\n    /// @dev If any of the inputs are expected to be a ciphertext, it verifies that the value matches a valid ciphertext\\n    ///Pure in this function is marked as a hack/workaround - note that this function is NOT pure as fetches of ciphertexts require state access\\n    /// @param lhs The first input \\n    /// @param rhs The second input\\n    /// @return The result of the operation\\n    function mul(euint64 lhs, euint64 rhs) internal pure returns (euint64) {\\n        if (!isInitialized(lhs)) {\\n            lhs = asEuint64(0);\\n        }\\n        if (!isInitialized(rhs)) {\\n            rhs = asEuint64(0);\\n        }\\n        uint256 unwrappedInput1 = euint64.unwrap(lhs);\\n        uint256 unwrappedInput2 = euint64.unwrap(rhs);\\n\\n        uint256 result = mathHelper(Common.EUINT64_TFHE, unwrappedInput1, unwrappedInput2, FheOps(Precompiles.Fheos).mul);\\n        return euint64.wrap(result);\\n    }\\n    /// @notice This functions performs the lt operation\\n    /// @dev If any of the inputs are expected to be a ciphertext, it verifies that the value matches a valid ciphertext\\n    ///Pure in this function is marked as a hack/workaround - note that this function is NOT pure as fetches of ciphertexts require state access\\n    /// @param lhs The first input \\n    /// @param rhs The second input\\n    /// @return The result of the operation\\n    function lt(euint8 lhs, euint8 rhs) internal pure returns (ebool) {\\n        if (!isInitialized(lhs)) {\\n            lhs = asEuint8(0);\\n        }\\n        if (!isInitialized(rhs)) {\\n            rhs = asEuint8(0);\\n        }\\n        uint256 unwrappedInput1 = euint8.unwrap(lhs);\\n        uint256 unwrappedInput2 = euint8.unwrap(rhs);\\n\\n        uint256 result = mathHelper(Common.EUINT8_TFHE, unwrappedInput1, unwrappedInput2, FheOps(Precompiles.Fheos).lt);\\n        return ebool.wrap(result);\\n    }\\n    /// @notice This functions performs the lt operation\\n    /// @dev If any of the inputs are expected to be a ciphertext, it verifies that the value matches a valid ciphertext\\n    ///Pure in this function is marked as a hack/workaround - note that this function is NOT pure as fetches of ciphertexts require state access\\n    /// @param lhs The first input \\n    /// @param rhs The second input\\n    /// @return The result of the operation\\n    function lt(euint16 lhs, euint16 rhs) internal pure returns (ebool) {\\n        if (!isInitialized(lhs)) {\\n            lhs = asEuint16(0);\\n        }\\n        if (!isInitialized(rhs)) {\\n            rhs = asEuint16(0);\\n        }\\n        uint256 unwrappedInput1 = euint16.unwrap(lhs);\\n        uint256 unwrappedInput2 = euint16.unwrap(rhs);\\n\\n        uint256 result = mathHelper(Common.EUINT16_TFHE, unwrappedInput1, unwrappedInput2, FheOps(Precompiles.Fheos).lt);\\n        return ebool.wrap(result);\\n    }\\n    /// @notice This functions performs the lt operation\\n    /// @dev If any of the inputs are expected to be a ciphertext, it verifies that the value matches a valid ciphertext\\n    ///Pure in this function is marked as a hack/workaround - note that this function is NOT pure as fetches of ciphertexts require state access\\n    /// @param lhs The first input \\n    /// @param rhs The second input\\n    /// @return The result of the operation\\n    function lt(euint32 lhs, euint32 rhs) internal pure returns (ebool) {\\n        if (!isInitialized(lhs)) {\\n            lhs = asEuint32(0);\\n        }\\n        if (!isInitialized(rhs)) {\\n            rhs = asEuint32(0);\\n        }\\n        uint256 unwrappedInput1 = euint32.unwrap(lhs);\\n        uint256 unwrappedInput2 = euint32.unwrap(rhs);\\n\\n        uint256 result = mathHelper(Common.EUINT32_TFHE, unwrappedInput1, unwrappedInput2, FheOps(Precompiles.Fheos).lt);\\n        return ebool.wrap(result);\\n    }\\n    /// @notice This functions performs the lt operation\\n    /// @dev If any of the inputs are expected to be a ciphertext, it verifies that the value matches a valid ciphertext\\n    ///Pure in this function is marked as a hack/workaround - note that this function is NOT pure as fetches of ciphertexts require state access\\n    /// @param lhs The first input \\n    /// @param rhs The second input\\n    /// @return The result of the operation\\n    function lt(euint64 lhs, euint64 rhs) internal pure returns (ebool) {\\n        if (!isInitialized(lhs)) {\\n            lhs = asEuint64(0);\\n        }\\n        if (!isInitialized(rhs)) {\\n            rhs = asEuint64(0);\\n        }\\n        uint256 unwrappedInput1 = euint64.unwrap(lhs);\\n        uint256 unwrappedInput2 = euint64.unwrap(rhs);\\n\\n        uint256 result = mathHelper(Common.EUINT64_TFHE, unwrappedInput1, unwrappedInput2, FheOps(Precompiles.Fheos).lt);\\n        return ebool.wrap(result);\\n    }\\n    /// @notice This functions performs the lt operation\\n    /// @dev If any of the inputs are expected to be a ciphertext, it verifies that the value matches a valid ciphertext\\n    ///Pure in this function is marked as a hack/workaround - note that this function is NOT pure as fetches of ciphertexts require state access\\n    /// @param lhs The first input \\n    /// @param rhs The second input\\n    /// @return The result of the operation\\n    function lt(euint128 lhs, euint128 rhs) internal pure returns (ebool) {\\n        if (!isInitialized(lhs)) {\\n            lhs = asEuint128(0);\\n        }\\n        if (!isInitialized(rhs)) {\\n            rhs = asEuint128(0);\\n        }\\n        uint256 unwrappedInput1 = euint128.unwrap(lhs);\\n        uint256 unwrappedInput2 = euint128.unwrap(rhs);\\n\\n        uint256 result = mathHelper(Common.EUINT128_TFHE, unwrappedInput1, unwrappedInput2, FheOps(Precompiles.Fheos).lt);\\n        return ebool.wrap(result);\\n    }\\n\\n    function select(ebool input1, ebool input2, ebool input3) internal pure returns (ebool) {\\n        if (!isInitialized(input1)) {\\n            input1 = asEbool(0);\\n        }\\n        if (!isInitialized(input2)) {\\n            input2 = asEbool(0);\\n        }\\n        if (!isInitialized(input3)) {\\n            input3 = asEbool(0);\\n        }\\n\\n        uint256 unwrappedInput1 = ebool.unwrap(input1);\\n        uint256 unwrappedInput2 = ebool.unwrap(input2);\\n        uint256 unwrappedInput3 = ebool.unwrap(input3);\\n\\n        uint256 result = Impl.select(Common.EBOOL_TFHE, unwrappedInput1, unwrappedInput2, unwrappedInput3);\\n        return ebool.wrap(result);\\n    }\\n\\n    function select(ebool input1, euint8 input2, euint8 input3) internal pure returns (euint8) {\\n        if (!isInitialized(input1)) {\\n            input1 = asEbool(0);\\n        }\\n        if (!isInitialized(input2)) {\\n            input2 = asEuint8(0);\\n        }\\n        if (!isInitialized(input3)) {\\n            input3 = asEuint8(0);\\n        }\\n\\n        uint256 unwrappedInput1 = ebool.unwrap(input1);\\n        uint256 unwrappedInput2 = euint8.unwrap(input2);\\n        uint256 unwrappedInput3 = euint8.unwrap(input3);\\n\\n        uint256 result = Impl.select(Common.EUINT8_TFHE, unwrappedInput1, unwrappedInput2, unwrappedInput3);\\n        return euint8.wrap(result);\\n    }\\n\\n    function select(ebool input1, euint16 input2, euint16 input3) internal pure returns (euint16) {\\n        if (!isInitialized(input1)) {\\n            input1 = asEbool(0);\\n        }\\n        if (!isInitialized(input2)) {\\n            input2 = asEuint16(0);\\n        }\\n        if (!isInitialized(input3)) {\\n            input3 = asEuint16(0);\\n        }\\n\\n        uint256 unwrappedInput1 = ebool.unwrap(input1);\\n        uint256 unwrappedInput2 = euint16.unwrap(input2);\\n        uint256 unwrappedInput3 = euint16.unwrap(input3);\\n\\n        uint256 result = Impl.select(Common.EUINT16_TFHE, unwrappedInput1, unwrappedInput2, unwrappedInput3);\\n        return euint16.wrap(result);\\n    }\\n\\n    function select(ebool input1, euint32 input2, euint32 input3) internal pure returns (euint32) {\\n        if (!isInitialized(input1)) {\\n            input1 = asEbool(0);\\n        }\\n        if (!isInitialized(input2)) {\\n            input2 = asEuint32(0);\\n        }\\n        if (!isInitialized(input3)) {\\n            input3 = asEuint32(0);\\n        }\\n\\n        uint256 unwrappedInput1 = ebool.unwrap(input1);\\n        uint256 unwrappedInput2 = euint32.unwrap(input2);\\n        uint256 unwrappedInput3 = euint32.unwrap(input3);\\n\\n        uint256 result = Impl.select(Common.EUINT32_TFHE, unwrappedInput1, unwrappedInput2, unwrappedInput3);\\n        return euint32.wrap(result);\\n    }\\n\\n    function select(ebool input1, euint64 input2, euint64 input3) internal pure returns (euint64) {\\n        if (!isInitialized(input1)) {\\n            input1 = asEbool(0);\\n        }\\n        if (!isInitialized(input2)) {\\n            input2 = asEuint64(0);\\n        }\\n        if (!isInitialized(input3)) {\\n            input3 = asEuint64(0);\\n        }\\n\\n        uint256 unwrappedInput1 = ebool.unwrap(input1);\\n        uint256 unwrappedInput2 = euint64.unwrap(input2);\\n        uint256 unwrappedInput3 = euint64.unwrap(input3);\\n\\n        uint256 result = Impl.select(Common.EUINT64_TFHE, unwrappedInput1, unwrappedInput2, unwrappedInput3);\\n        return euint64.wrap(result);\\n    }\\n\\n    function select(ebool input1, euint128 input2, euint128 input3) internal pure returns (euint128) {\\n        if (!isInitialized(input1)) {\\n            input1 = asEbool(0);\\n        }\\n        if (!isInitialized(input2)) {\\n            input2 = asEuint128(0);\\n        }\\n        if (!isInitialized(input3)) {\\n            input3 = asEuint128(0);\\n        }\\n\\n        uint256 unwrappedInput1 = ebool.unwrap(input1);\\n        uint256 unwrappedInput2 = euint128.unwrap(input2);\\n        uint256 unwrappedInput3 = euint128.unwrap(input3);\\n\\n        uint256 result = Impl.select(Common.EUINT128_TFHE, unwrappedInput1, unwrappedInput2, unwrappedInput3);\\n        return euint128.wrap(result);\\n    }\\n\\n    function select(ebool input1, euint256 input2, euint256 input3) internal pure returns (euint256) {\\n        if (!isInitialized(input1)) {\\n            input1 = asEbool(0);\\n        }\\n        if (!isInitialized(input2)) {\\n            input2 = asEuint256(0);\\n        }\\n        if (!isInitialized(input3)) {\\n            input3 = asEuint256(0);\\n        }\\n\\n        uint256 unwrappedInput1 = ebool.unwrap(input1);\\n        uint256 unwrappedInput2 = euint256.unwrap(input2);\\n        uint256 unwrappedInput3 = euint256.unwrap(input3);\\n\\n        uint256 result = Impl.select(Common.EUINT256_TFHE, unwrappedInput1, unwrappedInput2, unwrappedInput3);\\n        return euint256.wrap(result);\\n    }\\n\\n    function select(ebool input1, eaddress input2, eaddress input3) internal pure returns (eaddress) {\\n        if (!isInitialized(input1)) {\\n            input1 = asEbool(0);\\n        }\\n        if (!isInitialized(input2)) {\\n            input2 = asEaddress(0);\\n        }\\n        if (!isInitialized(input3)) {\\n            input3 = asEaddress(0);\\n        }\\n\\n        uint256 unwrappedInput1 = ebool.unwrap(input1);\\n        uint256 unwrappedInput2 = eaddress.unwrap(input2);\\n        uint256 unwrappedInput3 = eaddress.unwrap(input3);\\n\\n        uint256 result = Impl.select(Common.EADDRESS_TFHE, unwrappedInput1, unwrappedInput2, unwrappedInput3);\\n        return eaddress.wrap(result);\\n    }\\n    /// @notice Performs the req operation on a ciphertext\\n    /// @dev Verifies that the input value matches a valid ciphertext. Pure in this function is marked as a hack/workaround - note that this function is NOT pure as fetches of ciphertexts require state access\\n    /// @param input1 the input ciphertext\\n    function req(ebool input1) internal pure  {\\n        if (!isInitialized(input1)) {\\n            input1 = asEbool(0);\\n        }\\n        uint256 unwrappedInput1 = ebool.unwrap(input1);\\n        bytes memory inputAsBytes = Common.toBytes(unwrappedInput1);\\n        FheOps(Precompiles.Fheos).req(Common.EBOOL_TFHE, inputAsBytes);\\n    }\\n    /// @notice Performs the req operation on a ciphertext\\n    /// @dev Verifies that the input value matches a valid ciphertext. Pure in this function is marked as a hack/workaround - note that this function is NOT pure as fetches of ciphertexts require state access\\n    /// @param input1 the input ciphertext\\n    function req(euint8 input1) internal pure  {\\n        if (!isInitialized(input1)) {\\n            input1 = asEuint8(0);\\n        }\\n        uint256 unwrappedInput1 = euint8.unwrap(input1);\\n        bytes memory inputAsBytes = Common.toBytes(unwrappedInput1);\\n        FheOps(Precompiles.Fheos).req(Common.EUINT8_TFHE, inputAsBytes);\\n    }\\n    /// @notice Performs the req operation on a ciphertext\\n    /// @dev Verifies that the input value matches a valid ciphertext. Pure in this function is marked as a hack/workaround - note that this function is NOT pure as fetches of ciphertexts require state access\\n    /// @param input1 the input ciphertext\\n    function req(euint16 input1) internal pure  {\\n        if (!isInitialized(input1)) {\\n            input1 = asEuint16(0);\\n        }\\n        uint256 unwrappedInput1 = euint16.unwrap(input1);\\n        bytes memory inputAsBytes = Common.toBytes(unwrappedInput1);\\n        FheOps(Precompiles.Fheos).req(Common.EUINT16_TFHE, inputAsBytes);\\n    }\\n    /// @notice Performs the req operation on a ciphertext\\n    /// @dev Verifies that the input value matches a valid ciphertext. Pure in this function is marked as a hack/workaround - note that this function is NOT pure as fetches of ciphertexts require state access\\n    /// @param input1 the input ciphertext\\n    function req(euint32 input1) internal pure  {\\n        if (!isInitialized(input1)) {\\n            input1 = asEuint32(0);\\n        }\\n        uint256 unwrappedInput1 = euint32.unwrap(input1);\\n        bytes memory inputAsBytes = Common.toBytes(unwrappedInput1);\\n        FheOps(Precompiles.Fheos).req(Common.EUINT32_TFHE, inputAsBytes);\\n    }\\n    /// @notice Performs the req operation on a ciphertext\\n    /// @dev Verifies that the input value matches a valid ciphertext. Pure in this function is marked as a hack/workaround - note that this function is NOT pure as fetches of ciphertexts require state access\\n    /// @param input1 the input ciphertext\\n    function req(euint64 input1) internal pure  {\\n        if (!isInitialized(input1)) {\\n            input1 = asEuint64(0);\\n        }\\n        uint256 unwrappedInput1 = euint64.unwrap(input1);\\n        bytes memory inputAsBytes = Common.toBytes(unwrappedInput1);\\n        FheOps(Precompiles.Fheos).req(Common.EUINT64_TFHE, inputAsBytes);\\n    }\\n    /// @notice Performs the req operation on a ciphertext\\n    /// @dev Verifies that the input value matches a valid ciphertext. Pure in this function is marked as a hack/workaround - note that this function is NOT pure as fetches of ciphertexts require state access\\n    /// @param input1 the input ciphertext\\n    function req(euint128 input1) internal pure  {\\n        if (!isInitialized(input1)) {\\n            input1 = asEuint128(0);\\n        }\\n        uint256 unwrappedInput1 = euint128.unwrap(input1);\\n        bytes memory inputAsBytes = Common.toBytes(unwrappedInput1);\\n        FheOps(Precompiles.Fheos).req(Common.EUINT128_TFHE, inputAsBytes);\\n    }\\n    /// @notice Performs the req operation on a ciphertext\\n    /// @dev Verifies that the input value matches a valid ciphertext. Pure in this function is marked as a hack/workaround - note that this function is NOT pure as fetches of ciphertexts require state access\\n    /// @param input1 the input ciphertext\\n    function req(euint256 input1) internal pure  {\\n        if (!isInitialized(input1)) {\\n            input1 = asEuint256(0);\\n        }\\n        uint256 unwrappedInput1 = euint256.unwrap(input1);\\n        bytes memory inputAsBytes = Common.toBytes(unwrappedInput1);\\n        FheOps(Precompiles.Fheos).req(Common.EUINT256_TFHE, inputAsBytes);\\n    }\\n    /// @notice This functions performs the div operation\\n    /// @dev If any of the inputs are expected to be a ciphertext, it verifies that the value matches a valid ciphertext\\n    ///Pure in this function is marked as a hack/workaround - note that this function is NOT pure as fetches of ciphertexts require state access\\n    /// @param lhs The first input \\n    /// @param rhs The second input\\n    /// @return The result of the operation\\n    function div(euint8 lhs, euint8 rhs) internal pure returns (euint8) {\\n        if (!isInitialized(lhs)) {\\n            lhs = asEuint8(0);\\n        }\\n        if (!isInitialized(rhs)) {\\n            rhs = asEuint8(0);\\n        }\\n        uint256 unwrappedInput1 = euint8.unwrap(lhs);\\n        uint256 unwrappedInput2 = euint8.unwrap(rhs);\\n\\n        uint256 result = mathHelper(Common.EUINT8_TFHE, unwrappedInput1, unwrappedInput2, FheOps(Precompiles.Fheos).div);\\n        return euint8.wrap(result);\\n    }\\n    /// @notice This functions performs the div operation\\n    /// @dev If any of the inputs are expected to be a ciphertext, it verifies that the value matches a valid ciphertext\\n    ///Pure in this function is marked as a hack/workaround - note that this function is NOT pure as fetches of ciphertexts require state access\\n    /// @param lhs The first input \\n    /// @param rhs The second input\\n    /// @return The result of the operation\\n    function div(euint16 lhs, euint16 rhs) internal pure returns (euint16) {\\n        if (!isInitialized(lhs)) {\\n            lhs = asEuint16(0);\\n        }\\n        if (!isInitialized(rhs)) {\\n            rhs = asEuint16(0);\\n        }\\n        uint256 unwrappedInput1 = euint16.unwrap(lhs);\\n        uint256 unwrappedInput2 = euint16.unwrap(rhs);\\n\\n        uint256 result = mathHelper(Common.EUINT16_TFHE, unwrappedInput1, unwrappedInput2, FheOps(Precompiles.Fheos).div);\\n        return euint16.wrap(result);\\n    }\\n    /// @notice This functions performs the div operation\\n    /// @dev If any of the inputs are expected to be a ciphertext, it verifies that the value matches a valid ciphertext\\n    ///Pure in this function is marked as a hack/workaround - note that this function is NOT pure as fetches of ciphertexts require state access\\n    /// @param lhs The first input \\n    /// @param rhs The second input\\n    /// @return The result of the operation\\n    function div(euint32 lhs, euint32 rhs) internal pure returns (euint32) {\\n        if (!isInitialized(lhs)) {\\n            lhs = asEuint32(0);\\n        }\\n        if (!isInitialized(rhs)) {\\n            rhs = asEuint32(0);\\n        }\\n        uint256 unwrappedInput1 = euint32.unwrap(lhs);\\n        uint256 unwrappedInput2 = euint32.unwrap(rhs);\\n\\n        uint256 result = mathHelper(Common.EUINT32_TFHE, unwrappedInput1, unwrappedInput2, FheOps(Precompiles.Fheos).div);\\n        return euint32.wrap(result);\\n    }\\n    /// @notice This functions performs the gt operation\\n    /// @dev If any of the inputs are expected to be a ciphertext, it verifies that the value matches a valid ciphertext\\n    ///Pure in this function is marked as a hack/workaround - note that this function is NOT pure as fetches of ciphertexts require state access\\n    /// @param lhs The first input \\n    /// @param rhs The second input\\n    /// @return The result of the operation\\n    function gt(euint8 lhs, euint8 rhs) internal pure returns (ebool) {\\n        if (!isInitialized(lhs)) {\\n            lhs = asEuint8(0);\\n        }\\n        if (!isInitialized(rhs)) {\\n            rhs = asEuint8(0);\\n        }\\n        uint256 unwrappedInput1 = euint8.unwrap(lhs);\\n        uint256 unwrappedInput2 = euint8.unwrap(rhs);\\n\\n        uint256 result = mathHelper(Common.EUINT8_TFHE, unwrappedInput1, unwrappedInput2, FheOps(Precompiles.Fheos).gt);\\n        return ebool.wrap(result);\\n    }\\n    /// @notice This functions performs the gt operation\\n    /// @dev If any of the inputs are expected to be a ciphertext, it verifies that the value matches a valid ciphertext\\n    ///Pure in this function is marked as a hack/workaround - note that this function is NOT pure as fetches of ciphertexts require state access\\n    /// @param lhs The first input \\n    /// @param rhs The second input\\n    /// @return The result of the operation\\n    function gt(euint16 lhs, euint16 rhs) internal pure returns (ebool) {\\n        if (!isInitialized(lhs)) {\\n            lhs = asEuint16(0);\\n        }\\n        if (!isInitialized(rhs)) {\\n            rhs = asEuint16(0);\\n        }\\n        uint256 unwrappedInput1 = euint16.unwrap(lhs);\\n        uint256 unwrappedInput2 = euint16.unwrap(rhs);\\n\\n        uint256 result = mathHelper(Common.EUINT16_TFHE, unwrappedInput1, unwrappedInput2, FheOps(Precompiles.Fheos).gt);\\n        return ebool.wrap(result);\\n    }\\n    /// @notice This functions performs the gt operation\\n    /// @dev If any of the inputs are expected to be a ciphertext, it verifies that the value matches a valid ciphertext\\n    ///Pure in this function is marked as a hack/workaround - note that this function is NOT pure as fetches of ciphertexts require state access\\n    /// @param lhs The first input \\n    /// @param rhs The second input\\n    /// @return The result of the operation\\n    function gt(euint32 lhs, euint32 rhs) internal pure returns (ebool) {\\n        if (!isInitialized(lhs)) {\\n            lhs = asEuint32(0);\\n        }\\n        if (!isInitialized(rhs)) {\\n            rhs = asEuint32(0);\\n        }\\n        uint256 unwrappedInput1 = euint32.unwrap(lhs);\\n        uint256 unwrappedInput2 = euint32.unwrap(rhs);\\n\\n        uint256 result = mathHelper(Common.EUINT32_TFHE, unwrappedInput1, unwrappedInput2, FheOps(Precompiles.Fheos).gt);\\n        return ebool.wrap(result);\\n    }\\n    /// @notice This functions performs the gt operation\\n    /// @dev If any of the inputs are expected to be a ciphertext, it verifies that the value matches a valid ciphertext\\n    ///Pure in this function is marked as a hack/workaround - note that this function is NOT pure as fetches of ciphertexts require state access\\n    /// @param lhs The first input \\n    /// @param rhs The second input\\n    /// @return The result of the operation\\n    function gt(euint64 lhs, euint64 rhs) internal pure returns (ebool) {\\n        if (!isInitialized(lhs)) {\\n            lhs = asEuint64(0);\\n        }\\n        if (!isInitialized(rhs)) {\\n            rhs = asEuint64(0);\\n        }\\n        uint256 unwrappedInput1 = euint64.unwrap(lhs);\\n        uint256 unwrappedInput2 = euint64.unwrap(rhs);\\n\\n        uint256 result = mathHelper(Common.EUINT64_TFHE, unwrappedInput1, unwrappedInput2, FheOps(Precompiles.Fheos).gt);\\n        return ebool.wrap(result);\\n    }\\n    /// @notice This functions performs the gt operation\\n    /// @dev If any of the inputs are expected to be a ciphertext, it verifies that the value matches a valid ciphertext\\n    ///Pure in this function is marked as a hack/workaround - note that this function is NOT pure as fetches of ciphertexts require state access\\n    /// @param lhs The first input \\n    /// @param rhs The second input\\n    /// @return The result of the operation\\n    function gt(euint128 lhs, euint128 rhs) internal pure returns (ebool) {\\n        if (!isInitialized(lhs)) {\\n            lhs = asEuint128(0);\\n        }\\n        if (!isInitialized(rhs)) {\\n            rhs = asEuint128(0);\\n        }\\n        uint256 unwrappedInput1 = euint128.unwrap(lhs);\\n        uint256 unwrappedInput2 = euint128.unwrap(rhs);\\n\\n        uint256 result = mathHelper(Common.EUINT128_TFHE, unwrappedInput1, unwrappedInput2, FheOps(Precompiles.Fheos).gt);\\n        return ebool.wrap(result);\\n    }\\n    /// @notice This functions performs the gte operation\\n    /// @dev If any of the inputs are expected to be a ciphertext, it verifies that the value matches a valid ciphertext\\n    ///Pure in this function is marked as a hack/workaround - note that this function is NOT pure as fetches of ciphertexts require state access\\n    /// @param lhs The first input \\n    /// @param rhs The second input\\n    /// @return The result of the operation\\n    function gte(euint8 lhs, euint8 rhs) internal pure returns (ebool) {\\n        if (!isInitialized(lhs)) {\\n            lhs = asEuint8(0);\\n        }\\n        if (!isInitialized(rhs)) {\\n            rhs = asEuint8(0);\\n        }\\n        uint256 unwrappedInput1 = euint8.unwrap(lhs);\\n        uint256 unwrappedInput2 = euint8.unwrap(rhs);\\n\\n        uint256 result = mathHelper(Common.EUINT8_TFHE, unwrappedInput1, unwrappedInput2, FheOps(Precompiles.Fheos).gte);\\n        return ebool.wrap(result);\\n    }\\n    /// @notice This functions performs the gte operation\\n    /// @dev If any of the inputs are expected to be a ciphertext, it verifies that the value matches a valid ciphertext\\n    ///Pure in this function is marked as a hack/workaround - note that this function is NOT pure as fetches of ciphertexts require state access\\n    /// @param lhs The first input \\n    /// @param rhs The second input\\n    /// @return The result of the operation\\n    function gte(euint16 lhs, euint16 rhs) internal pure returns (ebool) {\\n        if (!isInitialized(lhs)) {\\n            lhs = asEuint16(0);\\n        }\\n        if (!isInitialized(rhs)) {\\n            rhs = asEuint16(0);\\n        }\\n        uint256 unwrappedInput1 = euint16.unwrap(lhs);\\n        uint256 unwrappedInput2 = euint16.unwrap(rhs);\\n\\n        uint256 result = mathHelper(Common.EUINT16_TFHE, unwrappedInput1, unwrappedInput2, FheOps(Precompiles.Fheos).gte);\\n        return ebool.wrap(result);\\n    }\\n    /// @notice This functions performs the gte operation\\n    /// @dev If any of the inputs are expected to be a ciphertext, it verifies that the value matches a valid ciphertext\\n    ///Pure in this function is marked as a hack/workaround - note that this function is NOT pure as fetches of ciphertexts require state access\\n    /// @param lhs The first input \\n    /// @param rhs The second input\\n    /// @return The result of the operation\\n    function gte(euint32 lhs, euint32 rhs) internal pure returns (ebool) {\\n        if (!isInitialized(lhs)) {\\n            lhs = asEuint32(0);\\n        }\\n        if (!isInitialized(rhs)) {\\n            rhs = asEuint32(0);\\n        }\\n        uint256 unwrappedInput1 = euint32.unwrap(lhs);\\n        uint256 unwrappedInput2 = euint32.unwrap(rhs);\\n\\n        uint256 result = mathHelper(Common.EUINT32_TFHE, unwrappedInput1, unwrappedInput2, FheOps(Precompiles.Fheos).gte);\\n        return ebool.wrap(result);\\n    }\\n    /// @notice This functions performs the gte operation\\n    /// @dev If any of the inputs are expected to be a ciphertext, it verifies that the value matches a valid ciphertext\\n    ///Pure in this function is marked as a hack/workaround - note that this function is NOT pure as fetches of ciphertexts require state access\\n    /// @param lhs The first input \\n    /// @param rhs The second input\\n    /// @return The result of the operation\\n    function gte(euint64 lhs, euint64 rhs) internal pure returns (ebool) {\\n        if (!isInitialized(lhs)) {\\n            lhs = asEuint64(0);\\n        }\\n        if (!isInitialized(rhs)) {\\n            rhs = asEuint64(0);\\n        }\\n        uint256 unwrappedInput1 = euint64.unwrap(lhs);\\n        uint256 unwrappedInput2 = euint64.unwrap(rhs);\\n\\n        uint256 result = mathHelper(Common.EUINT64_TFHE, unwrappedInput1, unwrappedInput2, FheOps(Precompiles.Fheos).gte);\\n        return ebool.wrap(result);\\n    }\\n    /// @notice This functions performs the gte operation\\n    /// @dev If any of the inputs are expected to be a ciphertext, it verifies that the value matches a valid ciphertext\\n    ///Pure in this function is marked as a hack/workaround - note that this function is NOT pure as fetches of ciphertexts require state access\\n    /// @param lhs The first input \\n    /// @param rhs The second input\\n    /// @return The result of the operation\\n    function gte(euint128 lhs, euint128 rhs) internal pure returns (ebool) {\\n        if (!isInitialized(lhs)) {\\n            lhs = asEuint128(0);\\n        }\\n        if (!isInitialized(rhs)) {\\n            rhs = asEuint128(0);\\n        }\\n        uint256 unwrappedInput1 = euint128.unwrap(lhs);\\n        uint256 unwrappedInput2 = euint128.unwrap(rhs);\\n\\n        uint256 result = mathHelper(Common.EUINT128_TFHE, unwrappedInput1, unwrappedInput2, FheOps(Precompiles.Fheos).gte);\\n        return ebool.wrap(result);\\n    }\\n    /// @notice This functions performs the rem operation\\n    /// @dev If any of the inputs are expected to be a ciphertext, it verifies that the value matches a valid ciphertext\\n    ///Pure in this function is marked as a hack/workaround - note that this function is NOT pure as fetches of ciphertexts require state access\\n    /// @param lhs The first input \\n    /// @param rhs The second input\\n    /// @return The result of the operation\\n    function rem(euint8 lhs, euint8 rhs) internal pure returns (euint8) {\\n        if (!isInitialized(lhs)) {\\n            lhs = asEuint8(0);\\n        }\\n        if (!isInitialized(rhs)) {\\n            rhs = asEuint8(0);\\n        }\\n        uint256 unwrappedInput1 = euint8.unwrap(lhs);\\n        uint256 unwrappedInput2 = euint8.unwrap(rhs);\\n\\n        uint256 result = mathHelper(Common.EUINT8_TFHE, unwrappedInput1, unwrappedInput2, FheOps(Precompiles.Fheos).rem);\\n        return euint8.wrap(result);\\n    }\\n    /// @notice This functions performs the rem operation\\n    /// @dev If any of the inputs are expected to be a ciphertext, it verifies that the value matches a valid ciphertext\\n    ///Pure in this function is marked as a hack/workaround - note that this function is NOT pure as fetches of ciphertexts require state access\\n    /// @param lhs The first input \\n    /// @param rhs The second input\\n    /// @return The result of the operation\\n    function rem(euint16 lhs, euint16 rhs) internal pure returns (euint16) {\\n        if (!isInitialized(lhs)) {\\n            lhs = asEuint16(0);\\n        }\\n        if (!isInitialized(rhs)) {\\n            rhs = asEuint16(0);\\n        }\\n        uint256 unwrappedInput1 = euint16.unwrap(lhs);\\n        uint256 unwrappedInput2 = euint16.unwrap(rhs);\\n\\n        uint256 result = mathHelper(Common.EUINT16_TFHE, unwrappedInput1, unwrappedInput2, FheOps(Precompiles.Fheos).rem);\\n        return euint16.wrap(result);\\n    }\\n    /// @notice This functions performs the rem operation\\n    /// @dev If any of the inputs are expected to be a ciphertext, it verifies that the value matches a valid ciphertext\\n    ///Pure in this function is marked as a hack/workaround - note that this function is NOT pure as fetches of ciphertexts require state access\\n    /// @param lhs The first input \\n    /// @param rhs The second input\\n    /// @return The result of the operation\\n    function rem(euint32 lhs, euint32 rhs) internal pure returns (euint32) {\\n        if (!isInitialized(lhs)) {\\n            lhs = asEuint32(0);\\n        }\\n        if (!isInitialized(rhs)) {\\n            rhs = asEuint32(0);\\n        }\\n        uint256 unwrappedInput1 = euint32.unwrap(lhs);\\n        uint256 unwrappedInput2 = euint32.unwrap(rhs);\\n\\n        uint256 result = mathHelper(Common.EUINT32_TFHE, unwrappedInput1, unwrappedInput2, FheOps(Precompiles.Fheos).rem);\\n        return euint32.wrap(result);\\n    }\\n    /// @notice This functions performs the and operation\\n    /// @dev If any of the inputs are expected to be a ciphertext, it verifies that the value matches a valid ciphertext\\n    ///Pure in this function is marked as a hack/workaround - note that this function is NOT pure as fetches of ciphertexts require state access\\n    /// @param lhs The first input \\n    /// @param rhs The second input\\n    /// @return The result of the operation\\n    function and(ebool lhs, ebool rhs) internal pure returns (ebool) {\\n        if (!isInitialized(lhs)) {\\n            lhs = asEbool(0);\\n        }\\n        if (!isInitialized(rhs)) {\\n            rhs = asEbool(0);\\n        }\\n        uint256 unwrappedInput1 = ebool.unwrap(lhs);\\n        uint256 unwrappedInput2 = ebool.unwrap(rhs);\\n\\n        uint256 result = mathHelper(Common.EBOOL_TFHE, unwrappedInput1, unwrappedInput2, FheOps(Precompiles.Fheos).and);\\n        return ebool.wrap(result);\\n    }\\n    /// @notice This functions performs the and operation\\n    /// @dev If any of the inputs are expected to be a ciphertext, it verifies that the value matches a valid ciphertext\\n    ///Pure in this function is marked as a hack/workaround - note that this function is NOT pure as fetches of ciphertexts require state access\\n    /// @param lhs The first input \\n    /// @param rhs The second input\\n    /// @return The result of the operation\\n    function and(euint8 lhs, euint8 rhs) internal pure returns (euint8) {\\n        if (!isInitialized(lhs)) {\\n            lhs = asEuint8(0);\\n        }\\n        if (!isInitialized(rhs)) {\\n            rhs = asEuint8(0);\\n        }\\n        uint256 unwrappedInput1 = euint8.unwrap(lhs);\\n        uint256 unwrappedInput2 = euint8.unwrap(rhs);\\n\\n        uint256 result = mathHelper(Common.EUINT8_TFHE, unwrappedInput1, unwrappedInput2, FheOps(Precompiles.Fheos).and);\\n        return euint8.wrap(result);\\n    }\\n    /// @notice This functions performs the and operation\\n    /// @dev If any of the inputs are expected to be a ciphertext, it verifies that the value matches a valid ciphertext\\n    ///Pure in this function is marked as a hack/workaround - note that this function is NOT pure as fetches of ciphertexts require state access\\n    /// @param lhs The first input \\n    /// @param rhs The second input\\n    /// @return The result of the operation\\n    function and(euint16 lhs, euint16 rhs) internal pure returns (euint16) {\\n        if (!isInitialized(lhs)) {\\n            lhs = asEuint16(0);\\n        }\\n        if (!isInitialized(rhs)) {\\n            rhs = asEuint16(0);\\n        }\\n        uint256 unwrappedInput1 = euint16.unwrap(lhs);\\n        uint256 unwrappedInput2 = euint16.unwrap(rhs);\\n\\n        uint256 result = mathHelper(Common.EUINT16_TFHE, unwrappedInput1, unwrappedInput2, FheOps(Precompiles.Fheos).and);\\n        return euint16.wrap(result);\\n    }\\n    /// @notice This functions performs the and operation\\n    /// @dev If any of the inputs are expected to be a ciphertext, it verifies that the value matches a valid ciphertext\\n    ///Pure in this function is marked as a hack/workaround - note that this function is NOT pure as fetches of ciphertexts require state access\\n    /// @param lhs The first input \\n    /// @param rhs The second input\\n    /// @return The result of the operation\\n    function and(euint32 lhs, euint32 rhs) internal pure returns (euint32) {\\n        if (!isInitialized(lhs)) {\\n            lhs = asEuint32(0);\\n        }\\n        if (!isInitialized(rhs)) {\\n            rhs = asEuint32(0);\\n        }\\n        uint256 unwrappedInput1 = euint32.unwrap(lhs);\\n        uint256 unwrappedInput2 = euint32.unwrap(rhs);\\n\\n        uint256 result = mathHelper(Common.EUINT32_TFHE, unwrappedInput1, unwrappedInput2, FheOps(Precompiles.Fheos).and);\\n        return euint32.wrap(result);\\n    }\\n    /// @notice This functions performs the and operation\\n    /// @dev If any of the inputs are expected to be a ciphertext, it verifies that the value matches a valid ciphertext\\n    ///Pure in this function is marked as a hack/workaround - note that this function is NOT pure as fetches of ciphertexts require state access\\n    /// @param lhs The first input \\n    /// @param rhs The second input\\n    /// @return The result of the operation\\n    function and(euint64 lhs, euint64 rhs) internal pure returns (euint64) {\\n        if (!isInitialized(lhs)) {\\n            lhs = asEuint64(0);\\n        }\\n        if (!isInitialized(rhs)) {\\n            rhs = asEuint64(0);\\n        }\\n        uint256 unwrappedInput1 = euint64.unwrap(lhs);\\n        uint256 unwrappedInput2 = euint64.unwrap(rhs);\\n\\n        uint256 result = mathHelper(Common.EUINT64_TFHE, unwrappedInput1, unwrappedInput2, FheOps(Precompiles.Fheos).and);\\n        return euint64.wrap(result);\\n    }\\n    /// @notice This functions performs the and operation\\n    /// @dev If any of the inputs are expected to be a ciphertext, it verifies that the value matches a valid ciphertext\\n    ///Pure in this function is marked as a hack/workaround - note that this function is NOT pure as fetches of ciphertexts require state access\\n    /// @param lhs The first input \\n    /// @param rhs The second input\\n    /// @return The result of the operation\\n    function and(euint128 lhs, euint128 rhs) internal pure returns (euint128) {\\n        if (!isInitialized(lhs)) {\\n            lhs = asEuint128(0);\\n        }\\n        if (!isInitialized(rhs)) {\\n            rhs = asEuint128(0);\\n        }\\n        uint256 unwrappedInput1 = euint128.unwrap(lhs);\\n        uint256 unwrappedInput2 = euint128.unwrap(rhs);\\n\\n        uint256 result = mathHelper(Common.EUINT128_TFHE, unwrappedInput1, unwrappedInput2, FheOps(Precompiles.Fheos).and);\\n        return euint128.wrap(result);\\n    }\\n    /// @notice This functions performs the or operation\\n    /// @dev If any of the inputs are expected to be a ciphertext, it verifies that the value matches a valid ciphertext\\n    ///Pure in this function is marked as a hack/workaround - note that this function is NOT pure as fetches of ciphertexts require state access\\n    /// @param lhs The first input \\n    /// @param rhs The second input\\n    /// @return The result of the operation\\n    function or(ebool lhs, ebool rhs) internal pure returns (ebool) {\\n        if (!isInitialized(lhs)) {\\n            lhs = asEbool(0);\\n        }\\n        if (!isInitialized(rhs)) {\\n            rhs = asEbool(0);\\n        }\\n        uint256 unwrappedInput1 = ebool.unwrap(lhs);\\n        uint256 unwrappedInput2 = ebool.unwrap(rhs);\\n\\n        uint256 result = mathHelper(Common.EBOOL_TFHE, unwrappedInput1, unwrappedInput2, FheOps(Precompiles.Fheos).or);\\n        return ebool.wrap(result);\\n    }\\n    /// @notice This functions performs the or operation\\n    /// @dev If any of the inputs are expected to be a ciphertext, it verifies that the value matches a valid ciphertext\\n    ///Pure in this function is marked as a hack/workaround - note that this function is NOT pure as fetches of ciphertexts require state access\\n    /// @param lhs The first input \\n    /// @param rhs The second input\\n    /// @return The result of the operation\\n    function or(euint8 lhs, euint8 rhs) internal pure returns (euint8) {\\n        if (!isInitialized(lhs)) {\\n            lhs = asEuint8(0);\\n        }\\n        if (!isInitialized(rhs)) {\\n            rhs = asEuint8(0);\\n        }\\n        uint256 unwrappedInput1 = euint8.unwrap(lhs);\\n        uint256 unwrappedInput2 = euint8.unwrap(rhs);\\n\\n        uint256 result = mathHelper(Common.EUINT8_TFHE, unwrappedInput1, unwrappedInput2, FheOps(Precompiles.Fheos).or);\\n        return euint8.wrap(result);\\n    }\\n    /// @notice This functions performs the or operation\\n    /// @dev If any of the inputs are expected to be a ciphertext, it verifies that the value matches a valid ciphertext\\n    ///Pure in this function is marked as a hack/workaround - note that this function is NOT pure as fetches of ciphertexts require state access\\n    /// @param lhs The first input \\n    /// @param rhs The second input\\n    /// @return The result of the operation\\n    function or(euint16 lhs, euint16 rhs) internal pure returns (euint16) {\\n        if (!isInitialized(lhs)) {\\n            lhs = asEuint16(0);\\n        }\\n        if (!isInitialized(rhs)) {\\n            rhs = asEuint16(0);\\n        }\\n        uint256 unwrappedInput1 = euint16.unwrap(lhs);\\n        uint256 unwrappedInput2 = euint16.unwrap(rhs);\\n\\n        uint256 result = mathHelper(Common.EUINT16_TFHE, unwrappedInput1, unwrappedInput2, FheOps(Precompiles.Fheos).or);\\n        return euint16.wrap(result);\\n    }\\n    /// @notice This functions performs the or operation\\n    /// @dev If any of the inputs are expected to be a ciphertext, it verifies that the value matches a valid ciphertext\\n    ///Pure in this function is marked as a hack/workaround - note that this function is NOT pure as fetches of ciphertexts require state access\\n    /// @param lhs The first input \\n    /// @param rhs The second input\\n    /// @return The result of the operation\\n    function or(euint32 lhs, euint32 rhs) internal pure returns (euint32) {\\n        if (!isInitialized(lhs)) {\\n            lhs = asEuint32(0);\\n        }\\n        if (!isInitialized(rhs)) {\\n            rhs = asEuint32(0);\\n        }\\n        uint256 unwrappedInput1 = euint32.unwrap(lhs);\\n        uint256 unwrappedInput2 = euint32.unwrap(rhs);\\n\\n        uint256 result = mathHelper(Common.EUINT32_TFHE, unwrappedInput1, unwrappedInput2, FheOps(Precompiles.Fheos).or);\\n        return euint32.wrap(result);\\n    }\\n    /// @notice This functions performs the or operation\\n    /// @dev If any of the inputs are expected to be a ciphertext, it verifies that the value matches a valid ciphertext\\n    ///Pure in this function is marked as a hack/workaround - note that this function is NOT pure as fetches of ciphertexts require state access\\n    /// @param lhs The first input \\n    /// @param rhs The second input\\n    /// @return The result of the operation\\n    function or(euint64 lhs, euint64 rhs) internal pure returns (euint64) {\\n        if (!isInitialized(lhs)) {\\n            lhs = asEuint64(0);\\n        }\\n        if (!isInitialized(rhs)) {\\n            rhs = asEuint64(0);\\n        }\\n        uint256 unwrappedInput1 = euint64.unwrap(lhs);\\n        uint256 unwrappedInput2 = euint64.unwrap(rhs);\\n\\n        uint256 result = mathHelper(Common.EUINT64_TFHE, unwrappedInput1, unwrappedInput2, FheOps(Precompiles.Fheos).or);\\n        return euint64.wrap(result);\\n    }\\n    /// @notice This functions performs the or operation\\n    /// @dev If any of the inputs are expected to be a ciphertext, it verifies that the value matches a valid ciphertext\\n    ///Pure in this function is marked as a hack/workaround - note that this function is NOT pure as fetches of ciphertexts require state access\\n    /// @param lhs The first input \\n    /// @param rhs The second input\\n    /// @return The result of the operation\\n    function or(euint128 lhs, euint128 rhs) internal pure returns (euint128) {\\n        if (!isInitialized(lhs)) {\\n            lhs = asEuint128(0);\\n        }\\n        if (!isInitialized(rhs)) {\\n            rhs = asEuint128(0);\\n        }\\n        uint256 unwrappedInput1 = euint128.unwrap(lhs);\\n        uint256 unwrappedInput2 = euint128.unwrap(rhs);\\n\\n        uint256 result = mathHelper(Common.EUINT128_TFHE, unwrappedInput1, unwrappedInput2, FheOps(Precompiles.Fheos).or);\\n        return euint128.wrap(result);\\n    }\\n    /// @notice This functions performs the xor operation\\n    /// @dev If any of the inputs are expected to be a ciphertext, it verifies that the value matches a valid ciphertext\\n    ///Pure in this function is marked as a hack/workaround - note that this function is NOT pure as fetches of ciphertexts require state access\\n    /// @param lhs The first input \\n    /// @param rhs The second input\\n    /// @return The result of the operation\\n    function xor(ebool lhs, ebool rhs) internal pure returns (ebool) {\\n        if (!isInitialized(lhs)) {\\n            lhs = asEbool(0);\\n        }\\n        if (!isInitialized(rhs)) {\\n            rhs = asEbool(0);\\n        }\\n        uint256 unwrappedInput1 = ebool.unwrap(lhs);\\n        uint256 unwrappedInput2 = ebool.unwrap(rhs);\\n\\n        uint256 result = mathHelper(Common.EBOOL_TFHE, unwrappedInput1, unwrappedInput2, FheOps(Precompiles.Fheos).xor);\\n        return ebool.wrap(result);\\n    }\\n    /// @notice This functions performs the xor operation\\n    /// @dev If any of the inputs are expected to be a ciphertext, it verifies that the value matches a valid ciphertext\\n    ///Pure in this function is marked as a hack/workaround - note that this function is NOT pure as fetches of ciphertexts require state access\\n    /// @param lhs The first input \\n    /// @param rhs The second input\\n    /// @return The result of the operation\\n    function xor(euint8 lhs, euint8 rhs) internal pure returns (euint8) {\\n        if (!isInitialized(lhs)) {\\n            lhs = asEuint8(0);\\n        }\\n        if (!isInitialized(rhs)) {\\n            rhs = asEuint8(0);\\n        }\\n        uint256 unwrappedInput1 = euint8.unwrap(lhs);\\n        uint256 unwrappedInput2 = euint8.unwrap(rhs);\\n\\n        uint256 result = mathHelper(Common.EUINT8_TFHE, unwrappedInput1, unwrappedInput2, FheOps(Precompiles.Fheos).xor);\\n        return euint8.wrap(result);\\n    }\\n    /// @notice This functions performs the xor operation\\n    /// @dev If any of the inputs are expected to be a ciphertext, it verifies that the value matches a valid ciphertext\\n    ///Pure in this function is marked as a hack/workaround - note that this function is NOT pure as fetches of ciphertexts require state access\\n    /// @param lhs The first input \\n    /// @param rhs The second input\\n    /// @return The result of the operation\\n    function xor(euint16 lhs, euint16 rhs) internal pure returns (euint16) {\\n        if (!isInitialized(lhs)) {\\n            lhs = asEuint16(0);\\n        }\\n        if (!isInitialized(rhs)) {\\n            rhs = asEuint16(0);\\n        }\\n        uint256 unwrappedInput1 = euint16.unwrap(lhs);\\n        uint256 unwrappedInput2 = euint16.unwrap(rhs);\\n\\n        uint256 result = mathHelper(Common.EUINT16_TFHE, unwrappedInput1, unwrappedInput2, FheOps(Precompiles.Fheos).xor);\\n        return euint16.wrap(result);\\n    }\\n    /// @notice This functions performs the xor operation\\n    /// @dev If any of the inputs are expected to be a ciphertext, it verifies that the value matches a valid ciphertext\\n    ///Pure in this function is marked as a hack/workaround - note that this function is NOT pure as fetches of ciphertexts require state access\\n    /// @param lhs The first input \\n    /// @param rhs The second input\\n    /// @return The result of the operation\\n    function xor(euint32 lhs, euint32 rhs) internal pure returns (euint32) {\\n        if (!isInitialized(lhs)) {\\n            lhs = asEuint32(0);\\n        }\\n        if (!isInitialized(rhs)) {\\n            rhs = asEuint32(0);\\n        }\\n        uint256 unwrappedInput1 = euint32.unwrap(lhs);\\n        uint256 unwrappedInput2 = euint32.unwrap(rhs);\\n\\n        uint256 result = mathHelper(Common.EUINT32_TFHE, unwrappedInput1, unwrappedInput2, FheOps(Precompiles.Fheos).xor);\\n        return euint32.wrap(result);\\n    }\\n    /// @notice This functions performs the xor operation\\n    /// @dev If any of the inputs are expected to be a ciphertext, it verifies that the value matches a valid ciphertext\\n    ///Pure in this function is marked as a hack/workaround - note that this function is NOT pure as fetches of ciphertexts require state access\\n    /// @param lhs The first input \\n    /// @param rhs The second input\\n    /// @return The result of the operation\\n    function xor(euint64 lhs, euint64 rhs) internal pure returns (euint64) {\\n        if (!isInitialized(lhs)) {\\n            lhs = asEuint64(0);\\n        }\\n        if (!isInitialized(rhs)) {\\n            rhs = asEuint64(0);\\n        }\\n        uint256 unwrappedInput1 = euint64.unwrap(lhs);\\n        uint256 unwrappedInput2 = euint64.unwrap(rhs);\\n\\n        uint256 result = mathHelper(Common.EUINT64_TFHE, unwrappedInput1, unwrappedInput2, FheOps(Precompiles.Fheos).xor);\\n        return euint64.wrap(result);\\n    }\\n    /// @notice This functions performs the xor operation\\n    /// @dev If any of the inputs are expected to be a ciphertext, it verifies that the value matches a valid ciphertext\\n    ///Pure in this function is marked as a hack/workaround - note that this function is NOT pure as fetches of ciphertexts require state access\\n    /// @param lhs The first input \\n    /// @param rhs The second input\\n    /// @return The result of the operation\\n    function xor(euint128 lhs, euint128 rhs) internal pure returns (euint128) {\\n        if (!isInitialized(lhs)) {\\n            lhs = asEuint128(0);\\n        }\\n        if (!isInitialized(rhs)) {\\n            rhs = asEuint128(0);\\n        }\\n        uint256 unwrappedInput1 = euint128.unwrap(lhs);\\n        uint256 unwrappedInput2 = euint128.unwrap(rhs);\\n\\n        uint256 result = mathHelper(Common.EUINT128_TFHE, unwrappedInput1, unwrappedInput2, FheOps(Precompiles.Fheos).xor);\\n        return euint128.wrap(result);\\n    }\\n    /// @notice This functions performs the eq operation\\n    /// @dev If any of the inputs are expected to be a ciphertext, it verifies that the value matches a valid ciphertext\\n    ///Pure in this function is marked as a hack/workaround - note that this function is NOT pure as fetches of ciphertexts require state access\\n    /// @param lhs The first input \\n    /// @param rhs The second input\\n    /// @return The result of the operation\\n    function eq(ebool lhs, ebool rhs) internal pure returns (ebool) {\\n        if (!isInitialized(lhs)) {\\n            lhs = asEbool(0);\\n        }\\n        if (!isInitialized(rhs)) {\\n            rhs = asEbool(0);\\n        }\\n        uint256 unwrappedInput1 = ebool.unwrap(lhs);\\n        uint256 unwrappedInput2 = ebool.unwrap(rhs);\\n\\n        uint256 result = mathHelper(Common.EBOOL_TFHE, unwrappedInput1, unwrappedInput2, FheOps(Precompiles.Fheos).eq);\\n        return ebool.wrap(result);\\n    }\\n    /// @notice This functions performs the eq operation\\n    /// @dev If any of the inputs are expected to be a ciphertext, it verifies that the value matches a valid ciphertext\\n    ///Pure in this function is marked as a hack/workaround - note that this function is NOT pure as fetches of ciphertexts require state access\\n    /// @param lhs The first input \\n    /// @param rhs The second input\\n    /// @return The result of the operation\\n    function eq(euint8 lhs, euint8 rhs) internal pure returns (ebool) {\\n        if (!isInitialized(lhs)) {\\n            lhs = asEuint8(0);\\n        }\\n        if (!isInitialized(rhs)) {\\n            rhs = asEuint8(0);\\n        }\\n        uint256 unwrappedInput1 = euint8.unwrap(lhs);\\n        uint256 unwrappedInput2 = euint8.unwrap(rhs);\\n\\n        uint256 result = mathHelper(Common.EUINT8_TFHE, unwrappedInput1, unwrappedInput2, FheOps(Precompiles.Fheos).eq);\\n        return ebool.wrap(result);\\n    }\\n    /// @notice This functions performs the eq operation\\n    /// @dev If any of the inputs are expected to be a ciphertext, it verifies that the value matches a valid ciphertext\\n    ///Pure in this function is marked as a hack/workaround - note that this function is NOT pure as fetches of ciphertexts require state access\\n    /// @param lhs The first input \\n    /// @param rhs The second input\\n    /// @return The result of the operation\\n    function eq(euint16 lhs, euint16 rhs) internal pure returns (ebool) {\\n        if (!isInitialized(lhs)) {\\n            lhs = asEuint16(0);\\n        }\\n        if (!isInitialized(rhs)) {\\n            rhs = asEuint16(0);\\n        }\\n        uint256 unwrappedInput1 = euint16.unwrap(lhs);\\n        uint256 unwrappedInput2 = euint16.unwrap(rhs);\\n\\n        uint256 result = mathHelper(Common.EUINT16_TFHE, unwrappedInput1, unwrappedInput2, FheOps(Precompiles.Fheos).eq);\\n        return ebool.wrap(result);\\n    }\\n    /// @notice This functions performs the eq operation\\n    /// @dev If any of the inputs are expected to be a ciphertext, it verifies that the value matches a valid ciphertext\\n    ///Pure in this function is marked as a hack/workaround - note that this function is NOT pure as fetches of ciphertexts require state access\\n    /// @param lhs The first input \\n    /// @param rhs The second input\\n    /// @return The result of the operation\\n    function eq(euint32 lhs, euint32 rhs) internal pure returns (ebool) {\\n        if (!isInitialized(lhs)) {\\n            lhs = asEuint32(0);\\n        }\\n        if (!isInitialized(rhs)) {\\n            rhs = asEuint32(0);\\n        }\\n        uint256 unwrappedInput1 = euint32.unwrap(lhs);\\n        uint256 unwrappedInput2 = euint32.unwrap(rhs);\\n\\n        uint256 result = mathHelper(Common.EUINT32_TFHE, unwrappedInput1, unwrappedInput2, FheOps(Precompiles.Fheos).eq);\\n        return ebool.wrap(result);\\n    }\\n    /// @notice This functions performs the eq operation\\n    /// @dev If any of the inputs are expected to be a ciphertext, it verifies that the value matches a valid ciphertext\\n    ///Pure in this function is marked as a hack/workaround - note that this function is NOT pure as fetches of ciphertexts require state access\\n    /// @param lhs The first input \\n    /// @param rhs The second input\\n    /// @return The result of the operation\\n    function eq(euint64 lhs, euint64 rhs) internal pure returns (ebool) {\\n        if (!isInitialized(lhs)) {\\n            lhs = asEuint64(0);\\n        }\\n        if (!isInitialized(rhs)) {\\n            rhs = asEuint64(0);\\n        }\\n        uint256 unwrappedInput1 = euint64.unwrap(lhs);\\n        uint256 unwrappedInput2 = euint64.unwrap(rhs);\\n\\n        uint256 result = mathHelper(Common.EUINT64_TFHE, unwrappedInput1, unwrappedInput2, FheOps(Precompiles.Fheos).eq);\\n        return ebool.wrap(result);\\n    }\\n    /// @notice This functions performs the eq operation\\n    /// @dev If any of the inputs are expected to be a ciphertext, it verifies that the value matches a valid ciphertext\\n    ///Pure in this function is marked as a hack/workaround - note that this function is NOT pure as fetches of ciphertexts require state access\\n    /// @param lhs The first input \\n    /// @param rhs The second input\\n    /// @return The result of the operation\\n    function eq(euint128 lhs, euint128 rhs) internal pure returns (ebool) {\\n        if (!isInitialized(lhs)) {\\n            lhs = asEuint128(0);\\n        }\\n        if (!isInitialized(rhs)) {\\n            rhs = asEuint128(0);\\n        }\\n        uint256 unwrappedInput1 = euint128.unwrap(lhs);\\n        uint256 unwrappedInput2 = euint128.unwrap(rhs);\\n\\n        uint256 result = mathHelper(Common.EUINT128_TFHE, unwrappedInput1, unwrappedInput2, FheOps(Precompiles.Fheos).eq);\\n        return ebool.wrap(result);\\n    }\\n    /// @notice This functions performs the eq operation\\n    /// @dev If any of the inputs are expected to be a ciphertext, it verifies that the value matches a valid ciphertext\\n    ///Pure in this function is marked as a hack/workaround - note that this function is NOT pure as fetches of ciphertexts require state access\\n    /// @param lhs The first input \\n    /// @param rhs The second input\\n    /// @return The result of the operation\\n    function eq(euint256 lhs, euint256 rhs) internal pure returns (ebool) {\\n        if (!isInitialized(lhs)) {\\n            lhs = asEuint256(0);\\n        }\\n        if (!isInitialized(rhs)) {\\n            rhs = asEuint256(0);\\n        }\\n        uint256 unwrappedInput1 = euint256.unwrap(lhs);\\n        uint256 unwrappedInput2 = euint256.unwrap(rhs);\\n\\n        uint256 result = mathHelper(Common.EUINT256_TFHE, unwrappedInput1, unwrappedInput2, FheOps(Precompiles.Fheos).eq);\\n        return ebool.wrap(result);\\n    }\\n    /// @notice This functions performs the eq operation\\n    /// @dev If any of the inputs are expected to be a ciphertext, it verifies that the value matches a valid ciphertext\\n    ///Pure in this function is marked as a hack/workaround - note that this function is NOT pure as fetches of ciphertexts require state access\\n    /// @param lhs The first input \\n    /// @param rhs The second input\\n    /// @return The result of the operation\\n    function eq(eaddress lhs, eaddress rhs) internal pure returns (ebool) {\\n        if (!isInitialized(lhs)) {\\n            lhs = asEaddress(0);\\n        }\\n        if (!isInitialized(rhs)) {\\n            rhs = asEaddress(0);\\n        }\\n        uint256 unwrappedInput1 = eaddress.unwrap(lhs);\\n        uint256 unwrappedInput2 = eaddress.unwrap(rhs);\\n\\n        uint256 result = mathHelper(Common.EADDRESS_TFHE, unwrappedInput1, unwrappedInput2, FheOps(Precompiles.Fheos).eq);\\n        return ebool.wrap(result);\\n    }\\n    /// @notice This functions performs the ne operation\\n    /// @dev If any of the inputs are expected to be a ciphertext, it verifies that the value matches a valid ciphertext\\n    ///Pure in this function is marked as a hack/workaround - note that this function is NOT pure as fetches of ciphertexts require state access\\n    /// @param lhs The first input \\n    /// @param rhs The second input\\n    /// @return The result of the operation\\n    function ne(ebool lhs, ebool rhs) internal pure returns (ebool) {\\n        if (!isInitialized(lhs)) {\\n            lhs = asEbool(0);\\n        }\\n        if (!isInitialized(rhs)) {\\n            rhs = asEbool(0);\\n        }\\n        uint256 unwrappedInput1 = ebool.unwrap(lhs);\\n        uint256 unwrappedInput2 = ebool.unwrap(rhs);\\n\\n        uint256 result = mathHelper(Common.EBOOL_TFHE, unwrappedInput1, unwrappedInput2, FheOps(Precompiles.Fheos).ne);\\n        return ebool.wrap(result);\\n    }\\n    /// @notice This functions performs the ne operation\\n    /// @dev If any of the inputs are expected to be a ciphertext, it verifies that the value matches a valid ciphertext\\n    ///Pure in this function is marked as a hack/workaround - note that this function is NOT pure as fetches of ciphertexts require state access\\n    /// @param lhs The first input \\n    /// @param rhs The second input\\n    /// @return The result of the operation\\n    function ne(euint8 lhs, euint8 rhs) internal pure returns (ebool) {\\n        if (!isInitialized(lhs)) {\\n            lhs = asEuint8(0);\\n        }\\n        if (!isInitialized(rhs)) {\\n            rhs = asEuint8(0);\\n        }\\n        uint256 unwrappedInput1 = euint8.unwrap(lhs);\\n        uint256 unwrappedInput2 = euint8.unwrap(rhs);\\n\\n        uint256 result = mathHelper(Common.EUINT8_TFHE, unwrappedInput1, unwrappedInput2, FheOps(Precompiles.Fheos).ne);\\n        return ebool.wrap(result);\\n    }\\n    /// @notice This functions performs the ne operation\\n    /// @dev If any of the inputs are expected to be a ciphertext, it verifies that the value matches a valid ciphertext\\n    ///Pure in this function is marked as a hack/workaround - note that this function is NOT pure as fetches of ciphertexts require state access\\n    /// @param lhs The first input \\n    /// @param rhs The second input\\n    /// @return The result of the operation\\n    function ne(euint16 lhs, euint16 rhs) internal pure returns (ebool) {\\n        if (!isInitialized(lhs)) {\\n            lhs = asEuint16(0);\\n        }\\n        if (!isInitialized(rhs)) {\\n            rhs = asEuint16(0);\\n        }\\n        uint256 unwrappedInput1 = euint16.unwrap(lhs);\\n        uint256 unwrappedInput2 = euint16.unwrap(rhs);\\n\\n        uint256 result = mathHelper(Common.EUINT16_TFHE, unwrappedInput1, unwrappedInput2, FheOps(Precompiles.Fheos).ne);\\n        return ebool.wrap(result);\\n    }\\n    /// @notice This functions performs the ne operation\\n    /// @dev If any of the inputs are expected to be a ciphertext, it verifies that the value matches a valid ciphertext\\n    ///Pure in this function is marked as a hack/workaround - note that this function is NOT pure as fetches of ciphertexts require state access\\n    /// @param lhs The first input \\n    /// @param rhs The second input\\n    /// @return The result of the operation\\n    function ne(euint32 lhs, euint32 rhs) internal pure returns (ebool) {\\n        if (!isInitialized(lhs)) {\\n            lhs = asEuint32(0);\\n        }\\n        if (!isInitialized(rhs)) {\\n            rhs = asEuint32(0);\\n        }\\n        uint256 unwrappedInput1 = euint32.unwrap(lhs);\\n        uint256 unwrappedInput2 = euint32.unwrap(rhs);\\n\\n        uint256 result = mathHelper(Common.EUINT32_TFHE, unwrappedInput1, unwrappedInput2, FheOps(Precompiles.Fheos).ne);\\n        return ebool.wrap(result);\\n    }\\n    /// @notice This functions performs the ne operation\\n    /// @dev If any of the inputs are expected to be a ciphertext, it verifies that the value matches a valid ciphertext\\n    ///Pure in this function is marked as a hack/workaround - note that this function is NOT pure as fetches of ciphertexts require state access\\n    /// @param lhs The first input \\n    /// @param rhs The second input\\n    /// @return The result of the operation\\n    function ne(euint64 lhs, euint64 rhs) internal pure returns (ebool) {\\n        if (!isInitialized(lhs)) {\\n            lhs = asEuint64(0);\\n        }\\n        if (!isInitialized(rhs)) {\\n            rhs = asEuint64(0);\\n        }\\n        uint256 unwrappedInput1 = euint64.unwrap(lhs);\\n        uint256 unwrappedInput2 = euint64.unwrap(rhs);\\n\\n        uint256 result = mathHelper(Common.EUINT64_TFHE, unwrappedInput1, unwrappedInput2, FheOps(Precompiles.Fheos).ne);\\n        return ebool.wrap(result);\\n    }\\n    /// @notice This functions performs the ne operation\\n    /// @dev If any of the inputs are expected to be a ciphertext, it verifies that the value matches a valid ciphertext\\n    ///Pure in this function is marked as a hack/workaround - note that this function is NOT pure as fetches of ciphertexts require state access\\n    /// @param lhs The first input \\n    /// @param rhs The second input\\n    /// @return The result of the operation\\n    function ne(euint128 lhs, euint128 rhs) internal pure returns (ebool) {\\n        if (!isInitialized(lhs)) {\\n            lhs = asEuint128(0);\\n        }\\n        if (!isInitialized(rhs)) {\\n            rhs = asEuint128(0);\\n        }\\n        uint256 unwrappedInput1 = euint128.unwrap(lhs);\\n        uint256 unwrappedInput2 = euint128.unwrap(rhs);\\n\\n        uint256 result = mathHelper(Common.EUINT128_TFHE, unwrappedInput1, unwrappedInput2, FheOps(Precompiles.Fheos).ne);\\n        return ebool.wrap(result);\\n    }\\n    /// @notice This functions performs the ne operation\\n    /// @dev If any of the inputs are expected to be a ciphertext, it verifies that the value matches a valid ciphertext\\n    ///Pure in this function is marked as a hack/workaround - note that this function is NOT pure as fetches of ciphertexts require state access\\n    /// @param lhs The first input \\n    /// @param rhs The second input\\n    /// @return The result of the operation\\n    function ne(euint256 lhs, euint256 rhs) internal pure returns (ebool) {\\n        if (!isInitialized(lhs)) {\\n            lhs = asEuint256(0);\\n        }\\n        if (!isInitialized(rhs)) {\\n            rhs = asEuint256(0);\\n        }\\n        uint256 unwrappedInput1 = euint256.unwrap(lhs);\\n        uint256 unwrappedInput2 = euint256.unwrap(rhs);\\n\\n        uint256 result = mathHelper(Common.EUINT256_TFHE, unwrappedInput1, unwrappedInput2, FheOps(Precompiles.Fheos).ne);\\n        return ebool.wrap(result);\\n    }\\n    /// @notice This functions performs the ne operation\\n    /// @dev If any of the inputs are expected to be a ciphertext, it verifies that the value matches a valid ciphertext\\n    ///Pure in this function is marked as a hack/workaround - note that this function is NOT pure as fetches of ciphertexts require state access\\n    /// @param lhs The first input \\n    /// @param rhs The second input\\n    /// @return The result of the operation\\n    function ne(eaddress lhs, eaddress rhs) internal pure returns (ebool) {\\n        if (!isInitialized(lhs)) {\\n            lhs = asEaddress(0);\\n        }\\n        if (!isInitialized(rhs)) {\\n            rhs = asEaddress(0);\\n        }\\n        uint256 unwrappedInput1 = eaddress.unwrap(lhs);\\n        uint256 unwrappedInput2 = eaddress.unwrap(rhs);\\n\\n        uint256 result = mathHelper(Common.EADDRESS_TFHE, unwrappedInput1, unwrappedInput2, FheOps(Precompiles.Fheos).ne);\\n        return ebool.wrap(result);\\n    }\\n    /// @notice This functions performs the min operation\\n    /// @dev If any of the inputs are expected to be a ciphertext, it verifies that the value matches a valid ciphertext\\n    ///Pure in this function is marked as a hack/workaround - note that this function is NOT pure as fetches of ciphertexts require state access\\n    /// @param lhs The first input \\n    /// @param rhs The second input\\n    /// @return The result of the operation\\n    function min(euint8 lhs, euint8 rhs) internal pure returns (euint8) {\\n        if (!isInitialized(lhs)) {\\n            lhs = asEuint8(0);\\n        }\\n        if (!isInitialized(rhs)) {\\n            rhs = asEuint8(0);\\n        }\\n        uint256 unwrappedInput1 = euint8.unwrap(lhs);\\n        uint256 unwrappedInput2 = euint8.unwrap(rhs);\\n\\n        uint256 result = mathHelper(Common.EUINT8_TFHE, unwrappedInput1, unwrappedInput2, FheOps(Precompiles.Fheos).min);\\n        return euint8.wrap(result);\\n    }\\n    /// @notice This functions performs the min operation\\n    /// @dev If any of the inputs are expected to be a ciphertext, it verifies that the value matches a valid ciphertext\\n    ///Pure in this function is marked as a hack/workaround - note that this function is NOT pure as fetches of ciphertexts require state access\\n    /// @param lhs The first input \\n    /// @param rhs The second input\\n    /// @return The result of the operation\\n    function min(euint16 lhs, euint16 rhs) internal pure returns (euint16) {\\n        if (!isInitialized(lhs)) {\\n            lhs = asEuint16(0);\\n        }\\n        if (!isInitialized(rhs)) {\\n            rhs = asEuint16(0);\\n        }\\n        uint256 unwrappedInput1 = euint16.unwrap(lhs);\\n        uint256 unwrappedInput2 = euint16.unwrap(rhs);\\n\\n        uint256 result = mathHelper(Common.EUINT16_TFHE, unwrappedInput1, unwrappedInput2, FheOps(Precompiles.Fheos).min);\\n        return euint16.wrap(result);\\n    }\\n    /// @notice This functions performs the min operation\\n    /// @dev If any of the inputs are expected to be a ciphertext, it verifies that the value matches a valid ciphertext\\n    ///Pure in this function is marked as a hack/workaround - note that this function is NOT pure as fetches of ciphertexts require state access\\n    /// @param lhs The first input \\n    /// @param rhs The second input\\n    /// @return The result of the operation\\n    function min(euint32 lhs, euint32 rhs) internal pure returns (euint32) {\\n        if (!isInitialized(lhs)) {\\n            lhs = asEuint32(0);\\n        }\\n        if (!isInitialized(rhs)) {\\n            rhs = asEuint32(0);\\n        }\\n        uint256 unwrappedInput1 = euint32.unwrap(lhs);\\n        uint256 unwrappedInput2 = euint32.unwrap(rhs);\\n\\n        uint256 result = mathHelper(Common.EUINT32_TFHE, unwrappedInput1, unwrappedInput2, FheOps(Precompiles.Fheos).min);\\n        return euint32.wrap(result);\\n    }\\n    /// @notice This functions performs the min operation\\n    /// @dev If any of the inputs are expected to be a ciphertext, it verifies that the value matches a valid ciphertext\\n    ///Pure in this function is marked as a hack/workaround - note that this function is NOT pure as fetches of ciphertexts require state access\\n    /// @param lhs The first input \\n    /// @param rhs The second input\\n    /// @return The result of the operation\\n    function min(euint64 lhs, euint64 rhs) internal pure returns (euint64) {\\n        if (!isInitialized(lhs)) {\\n            lhs = asEuint64(0);\\n        }\\n        if (!isInitialized(rhs)) {\\n            rhs = asEuint64(0);\\n        }\\n        uint256 unwrappedInput1 = euint64.unwrap(lhs);\\n        uint256 unwrappedInput2 = euint64.unwrap(rhs);\\n\\n        uint256 result = mathHelper(Common.EUINT64_TFHE, unwrappedInput1, unwrappedInput2, FheOps(Precompiles.Fheos).min);\\n        return euint64.wrap(result);\\n    }\\n    /// @notice This functions performs the min operation\\n    /// @dev If any of the inputs are expected to be a ciphertext, it verifies that the value matches a valid ciphertext\\n    ///Pure in this function is marked as a hack/workaround - note that this function is NOT pure as fetches of ciphertexts require state access\\n    /// @param lhs The first input \\n    /// @param rhs The second input\\n    /// @return The result of the operation\\n    function min(euint128 lhs, euint128 rhs) internal pure returns (euint128) {\\n        if (!isInitialized(lhs)) {\\n            lhs = asEuint128(0);\\n        }\\n        if (!isInitialized(rhs)) {\\n            rhs = asEuint128(0);\\n        }\\n        uint256 unwrappedInput1 = euint128.unwrap(lhs);\\n        uint256 unwrappedInput2 = euint128.unwrap(rhs);\\n\\n        uint256 result = mathHelper(Common.EUINT128_TFHE, unwrappedInput1, unwrappedInput2, FheOps(Precompiles.Fheos).min);\\n        return euint128.wrap(result);\\n    }\\n    /// @notice This functions performs the max operation\\n    /// @dev If any of the inputs are expected to be a ciphertext, it verifies that the value matches a valid ciphertext\\n    ///Pure in this function is marked as a hack/workaround - note that this function is NOT pure as fetches of ciphertexts require state access\\n    /// @param lhs The first input \\n    /// @param rhs The second input\\n    /// @return The result of the operation\\n    function max(euint8 lhs, euint8 rhs) internal pure returns (euint8) {\\n        if (!isInitialized(lhs)) {\\n            lhs = asEuint8(0);\\n        }\\n        if (!isInitialized(rhs)) {\\n            rhs = asEuint8(0);\\n        }\\n        uint256 unwrappedInput1 = euint8.unwrap(lhs);\\n        uint256 unwrappedInput2 = euint8.unwrap(rhs);\\n\\n        uint256 result = mathHelper(Common.EUINT8_TFHE, unwrappedInput1, unwrappedInput2, FheOps(Precompiles.Fheos).max);\\n        return euint8.wrap(result);\\n    }\\n    /// @notice This functions performs the max operation\\n    /// @dev If any of the inputs are expected to be a ciphertext, it verifies that the value matches a valid ciphertext\\n    ///Pure in this function is marked as a hack/workaround - note that this function is NOT pure as fetches of ciphertexts require state access\\n    /// @param lhs The first input \\n    /// @param rhs The second input\\n    /// @return The result of the operation\\n    function max(euint16 lhs, euint16 rhs) internal pure returns (euint16) {\\n        if (!isInitialized(lhs)) {\\n            lhs = asEuint16(0);\\n        }\\n        if (!isInitialized(rhs)) {\\n            rhs = asEuint16(0);\\n        }\\n        uint256 unwrappedInput1 = euint16.unwrap(lhs);\\n        uint256 unwrappedInput2 = euint16.unwrap(rhs);\\n\\n        uint256 result = mathHelper(Common.EUINT16_TFHE, unwrappedInput1, unwrappedInput2, FheOps(Precompiles.Fheos).max);\\n        return euint16.wrap(result);\\n    }\\n    /// @notice This functions performs the max operation\\n    /// @dev If any of the inputs are expected to be a ciphertext, it verifies that the value matches a valid ciphertext\\n    ///Pure in this function is marked as a hack/workaround - note that this function is NOT pure as fetches of ciphertexts require state access\\n    /// @param lhs The first input \\n    /// @param rhs The second input\\n    /// @return The result of the operation\\n    function max(euint32 lhs, euint32 rhs) internal pure returns (euint32) {\\n        if (!isInitialized(lhs)) {\\n            lhs = asEuint32(0);\\n        }\\n        if (!isInitialized(rhs)) {\\n            rhs = asEuint32(0);\\n        }\\n        uint256 unwrappedInput1 = euint32.unwrap(lhs);\\n        uint256 unwrappedInput2 = euint32.unwrap(rhs);\\n\\n        uint256 result = mathHelper(Common.EUINT32_TFHE, unwrappedInput1, unwrappedInput2, FheOps(Precompiles.Fheos).max);\\n        return euint32.wrap(result);\\n    }\\n    /// @notice This functions performs the max operation\\n    /// @dev If any of the inputs are expected to be a ciphertext, it verifies that the value matches a valid ciphertext\\n    ///Pure in this function is marked as a hack/workaround - note that this function is NOT pure as fetches of ciphertexts require state access\\n    /// @param lhs The first input \\n    /// @param rhs The second input\\n    /// @return The result of the operation\\n    function max(euint64 lhs, euint64 rhs) internal pure returns (euint64) {\\n        if (!isInitialized(lhs)) {\\n            lhs = asEuint64(0);\\n        }\\n        if (!isInitialized(rhs)) {\\n            rhs = asEuint64(0);\\n        }\\n        uint256 unwrappedInput1 = euint64.unwrap(lhs);\\n        uint256 unwrappedInput2 = euint64.unwrap(rhs);\\n\\n        uint256 result = mathHelper(Common.EUINT64_TFHE, unwrappedInput1, unwrappedInput2, FheOps(Precompiles.Fheos).max);\\n        return euint64.wrap(result);\\n    }\\n    /// @notice This functions performs the max operation\\n    /// @dev If any of the inputs are expected to be a ciphertext, it verifies that the value matches a valid ciphertext\\n    ///Pure in this function is marked as a hack/workaround - note that this function is NOT pure as fetches of ciphertexts require state access\\n    /// @param lhs The first input \\n    /// @param rhs The second input\\n    /// @return The result of the operation\\n    function max(euint128 lhs, euint128 rhs) internal pure returns (euint128) {\\n        if (!isInitialized(lhs)) {\\n            lhs = asEuint128(0);\\n        }\\n        if (!isInitialized(rhs)) {\\n            rhs = asEuint128(0);\\n        }\\n        uint256 unwrappedInput1 = euint128.unwrap(lhs);\\n        uint256 unwrappedInput2 = euint128.unwrap(rhs);\\n\\n        uint256 result = mathHelper(Common.EUINT128_TFHE, unwrappedInput1, unwrappedInput2, FheOps(Precompiles.Fheos).max);\\n        return euint128.wrap(result);\\n    }\\n    /// @notice This functions performs the shl operation\\n    /// @dev If any of the inputs are expected to be a ciphertext, it verifies that the value matches a valid ciphertext\\n    ///Pure in this function is marked as a hack/workaround - note that this function is NOT pure as fetches of ciphertexts require state access\\n    /// @param lhs The first input \\n    /// @param rhs The second input\\n    /// @return The result of the operation\\n    function shl(euint8 lhs, euint8 rhs) internal pure returns (euint8) {\\n        if (!isInitialized(lhs)) {\\n            lhs = asEuint8(0);\\n        }\\n        if (!isInitialized(rhs)) {\\n            rhs = asEuint8(0);\\n        }\\n        uint256 unwrappedInput1 = euint8.unwrap(lhs);\\n        uint256 unwrappedInput2 = euint8.unwrap(rhs);\\n\\n        uint256 result = mathHelper(Common.EUINT8_TFHE, unwrappedInput1, unwrappedInput2, FheOps(Precompiles.Fheos).shl);\\n        return euint8.wrap(result);\\n    }\\n    /// @notice This functions performs the shl operation\\n    /// @dev If any of the inputs are expected to be a ciphertext, it verifies that the value matches a valid ciphertext\\n    ///Pure in this function is marked as a hack/workaround - note that this function is NOT pure as fetches of ciphertexts require state access\\n    /// @param lhs The first input \\n    /// @param rhs The second input\\n    /// @return The result of the operation\\n    function shl(euint16 lhs, euint16 rhs) internal pure returns (euint16) {\\n        if (!isInitialized(lhs)) {\\n            lhs = asEuint16(0);\\n        }\\n        if (!isInitialized(rhs)) {\\n            rhs = asEuint16(0);\\n        }\\n        uint256 unwrappedInput1 = euint16.unwrap(lhs);\\n        uint256 unwrappedInput2 = euint16.unwrap(rhs);\\n\\n        uint256 result = mathHelper(Common.EUINT16_TFHE, unwrappedInput1, unwrappedInput2, FheOps(Precompiles.Fheos).shl);\\n        return euint16.wrap(result);\\n    }\\n    /// @notice This functions performs the shl operation\\n    /// @dev If any of the inputs are expected to be a ciphertext, it verifies that the value matches a valid ciphertext\\n    ///Pure in this function is marked as a hack/workaround - note that this function is NOT pure as fetches of ciphertexts require state access\\n    /// @param lhs The first input \\n    /// @param rhs The second input\\n    /// @return The result of the operation\\n    function shl(euint32 lhs, euint32 rhs) internal pure returns (euint32) {\\n        if (!isInitialized(lhs)) {\\n            lhs = asEuint32(0);\\n        }\\n        if (!isInitialized(rhs)) {\\n            rhs = asEuint32(0);\\n        }\\n        uint256 unwrappedInput1 = euint32.unwrap(lhs);\\n        uint256 unwrappedInput2 = euint32.unwrap(rhs);\\n\\n        uint256 result = mathHelper(Common.EUINT32_TFHE, unwrappedInput1, unwrappedInput2, FheOps(Precompiles.Fheos).shl);\\n        return euint32.wrap(result);\\n    }\\n    /// @notice This functions performs the shl operation\\n    /// @dev If any of the inputs are expected to be a ciphertext, it verifies that the value matches a valid ciphertext\\n    ///Pure in this function is marked as a hack/workaround - note that this function is NOT pure as fetches of ciphertexts require state access\\n    /// @param lhs The first input \\n    /// @param rhs The second input\\n    /// @return The result of the operation\\n    function shl(euint64 lhs, euint64 rhs) internal pure returns (euint64) {\\n        if (!isInitialized(lhs)) {\\n            lhs = asEuint64(0);\\n        }\\n        if (!isInitialized(rhs)) {\\n            rhs = asEuint64(0);\\n        }\\n        uint256 unwrappedInput1 = euint64.unwrap(lhs);\\n        uint256 unwrappedInput2 = euint64.unwrap(rhs);\\n\\n        uint256 result = mathHelper(Common.EUINT64_TFHE, unwrappedInput1, unwrappedInput2, FheOps(Precompiles.Fheos).shl);\\n        return euint64.wrap(result);\\n    }\\n    /// @notice This functions performs the shl operation\\n    /// @dev If any of the inputs are expected to be a ciphertext, it verifies that the value matches a valid ciphertext\\n    ///Pure in this function is marked as a hack/workaround - note that this function is NOT pure as fetches of ciphertexts require state access\\n    /// @param lhs The first input \\n    /// @param rhs The second input\\n    /// @return The result of the operation\\n    function shl(euint128 lhs, euint128 rhs) internal pure returns (euint128) {\\n        if (!isInitialized(lhs)) {\\n            lhs = asEuint128(0);\\n        }\\n        if (!isInitialized(rhs)) {\\n            rhs = asEuint128(0);\\n        }\\n        uint256 unwrappedInput1 = euint128.unwrap(lhs);\\n        uint256 unwrappedInput2 = euint128.unwrap(rhs);\\n\\n        uint256 result = mathHelper(Common.EUINT128_TFHE, unwrappedInput1, unwrappedInput2, FheOps(Precompiles.Fheos).shl);\\n        return euint128.wrap(result);\\n    }\\n    /// @notice This functions performs the shr operation\\n    /// @dev If any of the inputs are expected to be a ciphertext, it verifies that the value matches a valid ciphertext\\n    ///Pure in this function is marked as a hack/workaround - note that this function is NOT pure as fetches of ciphertexts require state access\\n    /// @param lhs The first input \\n    /// @param rhs The second input\\n    /// @return The result of the operation\\n    function shr(euint8 lhs, euint8 rhs) internal pure returns (euint8) {\\n        if (!isInitialized(lhs)) {\\n            lhs = asEuint8(0);\\n        }\\n        if (!isInitialized(rhs)) {\\n            rhs = asEuint8(0);\\n        }\\n        uint256 unwrappedInput1 = euint8.unwrap(lhs);\\n        uint256 unwrappedInput2 = euint8.unwrap(rhs);\\n\\n        uint256 result = mathHelper(Common.EUINT8_TFHE, unwrappedInput1, unwrappedInput2, FheOps(Precompiles.Fheos).shr);\\n        return euint8.wrap(result);\\n    }\\n    /// @notice This functions performs the shr operation\\n    /// @dev If any of the inputs are expected to be a ciphertext, it verifies that the value matches a valid ciphertext\\n    ///Pure in this function is marked as a hack/workaround - note that this function is NOT pure as fetches of ciphertexts require state access\\n    /// @param lhs The first input \\n    /// @param rhs The second input\\n    /// @return The result of the operation\\n    function shr(euint16 lhs, euint16 rhs) internal pure returns (euint16) {\\n        if (!isInitialized(lhs)) {\\n            lhs = asEuint16(0);\\n        }\\n        if (!isInitialized(rhs)) {\\n            rhs = asEuint16(0);\\n        }\\n        uint256 unwrappedInput1 = euint16.unwrap(lhs);\\n        uint256 unwrappedInput2 = euint16.unwrap(rhs);\\n\\n        uint256 result = mathHelper(Common.EUINT16_TFHE, unwrappedInput1, unwrappedInput2, FheOps(Precompiles.Fheos).shr);\\n        return euint16.wrap(result);\\n    }\\n    /// @notice This functions performs the shr operation\\n    /// @dev If any of the inputs are expected to be a ciphertext, it verifies that the value matches a valid ciphertext\\n    ///Pure in this function is marked as a hack/workaround - note that this function is NOT pure as fetches of ciphertexts require state access\\n    /// @param lhs The first input \\n    /// @param rhs The second input\\n    /// @return The result of the operation\\n    function shr(euint32 lhs, euint32 rhs) internal pure returns (euint32) {\\n        if (!isInitialized(lhs)) {\\n            lhs = asEuint32(0);\\n        }\\n        if (!isInitialized(rhs)) {\\n            rhs = asEuint32(0);\\n        }\\n        uint256 unwrappedInput1 = euint32.unwrap(lhs);\\n        uint256 unwrappedInput2 = euint32.unwrap(rhs);\\n\\n        uint256 result = mathHelper(Common.EUINT32_TFHE, unwrappedInput1, unwrappedInput2, FheOps(Precompiles.Fheos).shr);\\n        return euint32.wrap(result);\\n    }\\n    /// @notice This functions performs the shr operation\\n    /// @dev If any of the inputs are expected to be a ciphertext, it verifies that the value matches a valid ciphertext\\n    ///Pure in this function is marked as a hack/workaround - note that this function is NOT pure as fetches of ciphertexts require state access\\n    /// @param lhs The first input \\n    /// @param rhs The second input\\n    /// @return The result of the operation\\n    function shr(euint64 lhs, euint64 rhs) internal pure returns (euint64) {\\n        if (!isInitialized(lhs)) {\\n            lhs = asEuint64(0);\\n        }\\n        if (!isInitialized(rhs)) {\\n            rhs = asEuint64(0);\\n        }\\n        uint256 unwrappedInput1 = euint64.unwrap(lhs);\\n        uint256 unwrappedInput2 = euint64.unwrap(rhs);\\n\\n        uint256 result = mathHelper(Common.EUINT64_TFHE, unwrappedInput1, unwrappedInput2, FheOps(Precompiles.Fheos).shr);\\n        return euint64.wrap(result);\\n    }\\n    /// @notice This functions performs the shr operation\\n    /// @dev If any of the inputs are expected to be a ciphertext, it verifies that the value matches a valid ciphertext\\n    ///Pure in this function is marked as a hack/workaround - note that this function is NOT pure as fetches of ciphertexts require state access\\n    /// @param lhs The first input \\n    /// @param rhs The second input\\n    /// @return The result of the operation\\n    function shr(euint128 lhs, euint128 rhs) internal pure returns (euint128) {\\n        if (!isInitialized(lhs)) {\\n            lhs = asEuint128(0);\\n        }\\n        if (!isInitialized(rhs)) {\\n            rhs = asEuint128(0);\\n        }\\n        uint256 unwrappedInput1 = euint128.unwrap(lhs);\\n        uint256 unwrappedInput2 = euint128.unwrap(rhs);\\n\\n        uint256 result = mathHelper(Common.EUINT128_TFHE, unwrappedInput1, unwrappedInput2, FheOps(Precompiles.Fheos).shr);\\n        return euint128.wrap(result);\\n    }\\n\\n    /// @notice Performs the \\\"not\\\" for the ebool type\\n    /// @dev Implemented by a workaround due to ebool being a euint8 type behind the scenes, therefore xor is needed to assure that not(true) = false and vise-versa\\n    /// @param value input ebool ciphertext\\n    /// @return Result of the not operation on `value` \\n    function not(ebool value) internal pure returns (ebool) {\\n        return xor(value, asEbool(true));\\n    }\\n    /// @notice Performs the not operation on a ciphertext\\n    /// @dev Verifies that the input value matches a valid ciphertext. Pure in this function is marked as a hack/workaround - note that this function is NOT pure as fetches of ciphertexts require state access\\n    /// @param input1 the input ciphertext\\n    function not(euint8 input1) internal pure returns (euint8) {\\n        if (!isInitialized(input1)) {\\n            input1 = asEuint8(0);\\n        }\\n        uint256 unwrappedInput1 = euint8.unwrap(input1);\\n        bytes memory inputAsBytes = Common.toBytes(unwrappedInput1);\\n        bytes memory b = FheOps(Precompiles.Fheos).not(Common.EUINT8_TFHE, inputAsBytes);\\n        uint256 result = Impl.getValue(b);\\n        return euint8.wrap(result);\\n    }\\n    /// @notice Performs the not operation on a ciphertext\\n    /// @dev Verifies that the input value matches a valid ciphertext. Pure in this function is marked as a hack/workaround - note that this function is NOT pure as fetches of ciphertexts require state access\\n    /// @param input1 the input ciphertext\\n    function not(euint16 input1) internal pure returns (euint16) {\\n        if (!isInitialized(input1)) {\\n            input1 = asEuint16(0);\\n        }\\n        uint256 unwrappedInput1 = euint16.unwrap(input1);\\n        bytes memory inputAsBytes = Common.toBytes(unwrappedInput1);\\n        bytes memory b = FheOps(Precompiles.Fheos).not(Common.EUINT16_TFHE, inputAsBytes);\\n        uint256 result = Impl.getValue(b);\\n        return euint16.wrap(result);\\n    }\\n    /// @notice Performs the not operation on a ciphertext\\n    /// @dev Verifies that the input value matches a valid ciphertext. Pure in this function is marked as a hack/workaround - note that this function is NOT pure as fetches of ciphertexts require state access\\n    /// @param input1 the input ciphertext\\n    function not(euint32 input1) internal pure returns (euint32) {\\n        if (!isInitialized(input1)) {\\n            input1 = asEuint32(0);\\n        }\\n        uint256 unwrappedInput1 = euint32.unwrap(input1);\\n        bytes memory inputAsBytes = Common.toBytes(unwrappedInput1);\\n        bytes memory b = FheOps(Precompiles.Fheos).not(Common.EUINT32_TFHE, inputAsBytes);\\n        uint256 result = Impl.getValue(b);\\n        return euint32.wrap(result);\\n    }\\n    /// @notice Performs the not operation on a ciphertext\\n    /// @dev Verifies that the input value matches a valid ciphertext. Pure in this function is marked as a hack/workaround - note that this function is NOT pure as fetches of ciphertexts require state access\\n    /// @param input1 the input ciphertext\\n    function not(euint64 input1) internal pure returns (euint64) {\\n        if (!isInitialized(input1)) {\\n            input1 = asEuint64(0);\\n        }\\n        uint256 unwrappedInput1 = euint64.unwrap(input1);\\n        bytes memory inputAsBytes = Common.toBytes(unwrappedInput1);\\n        bytes memory b = FheOps(Precompiles.Fheos).not(Common.EUINT64_TFHE, inputAsBytes);\\n        uint256 result = Impl.getValue(b);\\n        return euint64.wrap(result);\\n    }\\n    /// @notice Performs the not operation on a ciphertext\\n    /// @dev Verifies that the input value matches a valid ciphertext. Pure in this function is marked as a hack/workaround - note that this function is NOT pure as fetches of ciphertexts require state access\\n    /// @param input1 the input ciphertext\\n    function not(euint128 input1) internal pure returns (euint128) {\\n        if (!isInitialized(input1)) {\\n            input1 = asEuint128(0);\\n        }\\n        uint256 unwrappedInput1 = euint128.unwrap(input1);\\n        bytes memory inputAsBytes = Common.toBytes(unwrappedInput1);\\n        bytes memory b = FheOps(Precompiles.Fheos).not(Common.EUINT128_TFHE, inputAsBytes);\\n        uint256 result = Impl.getValue(b);\\n        return euint128.wrap(result);\\n    }\\n\\n    // ********** TYPE CASTING ************* //\\n    /// @notice Parses input ciphertexts from the user. Converts from encrypted raw bytes to an ebool\\n    /// @dev Also performs validation that the ciphertext is valid and has been encrypted using the network encryption key\\n    /// @return a ciphertext representation of the input\\n    function asEbool(inEbool memory value) internal pure returns (ebool) {\\n        return FHE.asEbool(value.data);\\n    }\\n    /// @notice Converts a ebool to an euint8\\n    function asEuint8(ebool value) internal pure returns (euint8) {\\n        return euint8.wrap(Impl.cast(Common.EBOOL_TFHE, ebool.unwrap(value), Common.EUINT8_TFHE));\\n    }\\n    /// @notice Converts a ebool to an euint16\\n    function asEuint16(ebool value) internal pure returns (euint16) {\\n        return euint16.wrap(Impl.cast(Common.EBOOL_TFHE, ebool.unwrap(value), Common.EUINT16_TFHE));\\n    }\\n    /// @notice Converts a ebool to an euint32\\n    function asEuint32(ebool value) internal pure returns (euint32) {\\n        return euint32.wrap(Impl.cast(Common.EBOOL_TFHE, ebool.unwrap(value), Common.EUINT32_TFHE));\\n    }\\n    /// @notice Converts a ebool to an euint64\\n    function asEuint64(ebool value) internal pure returns (euint64) {\\n        return euint64.wrap(Impl.cast(Common.EBOOL_TFHE, ebool.unwrap(value), Common.EUINT64_TFHE));\\n    }\\n    /// @notice Converts a ebool to an euint128\\n    function asEuint128(ebool value) internal pure returns (euint128) {\\n        return euint128.wrap(Impl.cast(Common.EBOOL_TFHE, ebool.unwrap(value), Common.EUINT128_TFHE));\\n    }\\n    /// @notice Converts a ebool to an euint256\\n    function asEuint256(ebool value) internal pure returns (euint256) {\\n        return euint256.wrap(Impl.cast(Common.EBOOL_TFHE, ebool.unwrap(value), Common.EUINT256_TFHE));\\n    }\\n    /// @notice Converts a ebool to an eaddress\\n    function asEaddress(ebool value) internal pure returns (eaddress) {\\n        return eaddress.wrap(Impl.cast(Common.EBOOL_TFHE, ebool.unwrap(value), Common.EADDRESS_TFHE));\\n    }\\n    \\n    /// @notice Converts a euint8 to an ebool\\n    function asEbool(euint8 value) internal pure returns (ebool) {\\n        return ne(value, asEuint8(0));\\n    }\\n    /// @notice Parses input ciphertexts from the user. Converts from encrypted raw bytes to an euint8\\n    /// @dev Also performs validation that the ciphertext is valid and has been encrypted using the network encryption key\\n    /// @return a ciphertext representation of the input\\n    function asEuint8(inEuint8 memory value) internal pure returns (euint8) {\\n        return FHE.asEuint8(value.data);\\n    }\\n    /// @notice Converts a euint8 to an euint16\\n    function asEuint16(euint8 value) internal pure returns (euint16) {\\n        return euint16.wrap(Impl.cast(Common.EUINT8_TFHE, euint8.unwrap(value), Common.EUINT16_TFHE));\\n    }\\n    /// @notice Converts a euint8 to an euint32\\n    function asEuint32(euint8 value) internal pure returns (euint32) {\\n        return euint32.wrap(Impl.cast(Common.EUINT8_TFHE, euint8.unwrap(value), Common.EUINT32_TFHE));\\n    }\\n    /// @notice Converts a euint8 to an euint64\\n    function asEuint64(euint8 value) internal pure returns (euint64) {\\n        return euint64.wrap(Impl.cast(Common.EUINT8_TFHE, euint8.unwrap(value), Common.EUINT64_TFHE));\\n    }\\n    /// @notice Converts a euint8 to an euint128\\n    function asEuint128(euint8 value) internal pure returns (euint128) {\\n        return euint128.wrap(Impl.cast(Common.EUINT8_TFHE, euint8.unwrap(value), Common.EUINT128_TFHE));\\n    }\\n    /// @notice Converts a euint8 to an euint256\\n    function asEuint256(euint8 value) internal pure returns (euint256) {\\n        return euint256.wrap(Impl.cast(Common.EUINT8_TFHE, euint8.unwrap(value), Common.EUINT256_TFHE));\\n    }\\n    /// @notice Converts a euint8 to an eaddress\\n    function asEaddress(euint8 value) internal pure returns (eaddress) {\\n        return eaddress.wrap(Impl.cast(Common.EUINT8_TFHE, euint8.unwrap(value), Common.EADDRESS_TFHE));\\n    }\\n    \\n    /// @notice Converts a euint16 to an ebool\\n    function asEbool(euint16 value) internal pure returns (ebool) {\\n        return ne(value, asEuint16(0));\\n    }\\n    /// @notice Converts a euint16 to an euint8\\n    function asEuint8(euint16 value) internal pure returns (euint8) {\\n        return euint8.wrap(Impl.cast(Common.EUINT16_TFHE, euint16.unwrap(value), Common.EUINT8_TFHE));\\n    }\\n    /// @notice Parses input ciphertexts from the user. Converts from encrypted raw bytes to an euint16\\n    /// @dev Also performs validation that the ciphertext is valid and has been encrypted using the network encryption key\\n    /// @return a ciphertext representation of the input\\n    function asEuint16(inEuint16 memory value) internal pure returns (euint16) {\\n        return FHE.asEuint16(value.data);\\n    }\\n    /// @notice Converts a euint16 to an euint32\\n    function asEuint32(euint16 value) internal pure returns (euint32) {\\n        return euint32.wrap(Impl.cast(Common.EUINT16_TFHE, euint16.unwrap(value), Common.EUINT32_TFHE));\\n    }\\n    /// @notice Converts a euint16 to an euint64\\n    function asEuint64(euint16 value) internal pure returns (euint64) {\\n        return euint64.wrap(Impl.cast(Common.EUINT16_TFHE, euint16.unwrap(value), Common.EUINT64_TFHE));\\n    }\\n    /// @notice Converts a euint16 to an euint128\\n    function asEuint128(euint16 value) internal pure returns (euint128) {\\n        return euint128.wrap(Impl.cast(Common.EUINT16_TFHE, euint16.unwrap(value), Common.EUINT128_TFHE));\\n    }\\n    /// @notice Converts a euint16 to an euint256\\n    function asEuint256(euint16 value) internal pure returns (euint256) {\\n        return euint256.wrap(Impl.cast(Common.EUINT16_TFHE, euint16.unwrap(value), Common.EUINT256_TFHE));\\n    }\\n    /// @notice Converts a euint16 to an eaddress\\n    function asEaddress(euint16 value) internal pure returns (eaddress) {\\n        return eaddress.wrap(Impl.cast(Common.EUINT16_TFHE, euint16.unwrap(value), Common.EADDRESS_TFHE));\\n    }\\n    \\n    /// @notice Converts a euint32 to an ebool\\n    function asEbool(euint32 value) internal pure returns (ebool) {\\n        return ne(value, asEuint32(0));\\n    }\\n    /// @notice Converts a euint32 to an euint8\\n    function asEuint8(euint32 value) internal pure returns (euint8) {\\n        return euint8.wrap(Impl.cast(Common.EUINT32_TFHE, euint32.unwrap(value), Common.EUINT8_TFHE));\\n    }\\n    /// @notice Converts a euint32 to an euint16\\n    function asEuint16(euint32 value) internal pure returns (euint16) {\\n        return euint16.wrap(Impl.cast(Common.EUINT32_TFHE, euint32.unwrap(value), Common.EUINT16_TFHE));\\n    }\\n    /// @notice Parses input ciphertexts from the user. Converts from encrypted raw bytes to an euint32\\n    /// @dev Also performs validation that the ciphertext is valid and has been encrypted using the network encryption key\\n    /// @return a ciphertext representation of the input\\n    function asEuint32(inEuint32 memory value) internal pure returns (euint32) {\\n        return FHE.asEuint32(value.data);\\n    }\\n    /// @notice Converts a euint32 to an euint64\\n    function asEuint64(euint32 value) internal pure returns (euint64) {\\n        return euint64.wrap(Impl.cast(Common.EUINT32_TFHE, euint32.unwrap(value), Common.EUINT64_TFHE));\\n    }\\n    /// @notice Converts a euint32 to an euint128\\n    function asEuint128(euint32 value) internal pure returns (euint128) {\\n        return euint128.wrap(Impl.cast(Common.EUINT32_TFHE, euint32.unwrap(value), Common.EUINT128_TFHE));\\n    }\\n    /// @notice Converts a euint32 to an euint256\\n    function asEuint256(euint32 value) internal pure returns (euint256) {\\n        return euint256.wrap(Impl.cast(Common.EUINT32_TFHE, euint32.unwrap(value), Common.EUINT256_TFHE));\\n    }\\n    /// @notice Converts a euint32 to an eaddress\\n    function asEaddress(euint32 value) internal pure returns (eaddress) {\\n        return eaddress.wrap(Impl.cast(Common.EUINT32_TFHE, euint32.unwrap(value), Common.EADDRESS_TFHE));\\n    }\\n    \\n    /// @notice Converts a euint64 to an ebool\\n    function asEbool(euint64 value) internal pure returns (ebool) {\\n        return ne(value, asEuint64(0));\\n    }\\n    /// @notice Converts a euint64 to an euint8\\n    function asEuint8(euint64 value) internal pure returns (euint8) {\\n        return euint8.wrap(Impl.cast(Common.EUINT64_TFHE, euint64.unwrap(value), Common.EUINT8_TFHE));\\n    }\\n    /// @notice Converts a euint64 to an euint16\\n    function asEuint16(euint64 value) internal pure returns (euint16) {\\n        return euint16.wrap(Impl.cast(Common.EUINT64_TFHE, euint64.unwrap(value), Common.EUINT16_TFHE));\\n    }\\n    /// @notice Converts a euint64 to an euint32\\n    function asEuint32(euint64 value) internal pure returns (euint32) {\\n        return euint32.wrap(Impl.cast(Common.EUINT64_TFHE, euint64.unwrap(value), Common.EUINT32_TFHE));\\n    }\\n    /// @notice Parses input ciphertexts from the user. Converts from encrypted raw bytes to an euint64\\n    /// @dev Also performs validation that the ciphertext is valid and has been encrypted using the network encryption key\\n    /// @return a ciphertext representation of the input\\n    function asEuint64(inEuint64 memory value) internal pure returns (euint64) {\\n        return FHE.asEuint64(value.data);\\n    }\\n    /// @notice Converts a euint64 to an euint128\\n    function asEuint128(euint64 value) internal pure returns (euint128) {\\n        return euint128.wrap(Impl.cast(Common.EUINT64_TFHE, euint64.unwrap(value), Common.EUINT128_TFHE));\\n    }\\n    /// @notice Converts a euint64 to an euint256\\n    function asEuint256(euint64 value) internal pure returns (euint256) {\\n        return euint256.wrap(Impl.cast(Common.EUINT64_TFHE, euint64.unwrap(value), Common.EUINT256_TFHE));\\n    }\\n    /// @notice Converts a euint64 to an eaddress\\n    function asEaddress(euint64 value) internal pure returns (eaddress) {\\n        return eaddress.wrap(Impl.cast(Common.EUINT64_TFHE, euint64.unwrap(value), Common.EADDRESS_TFHE));\\n    }\\n    \\n    /// @notice Converts a euint128 to an ebool\\n    function asEbool(euint128 value) internal pure returns (ebool) {\\n        return ne(value, asEuint128(0));\\n    }\\n    /// @notice Converts a euint128 to an euint8\\n    function asEuint8(euint128 value) internal pure returns (euint8) {\\n        return euint8.wrap(Impl.cast(Common.EUINT128_TFHE, euint128.unwrap(value), Common.EUINT8_TFHE));\\n    }\\n    /// @notice Converts a euint128 to an euint16\\n    function asEuint16(euint128 value) internal pure returns (euint16) {\\n        return euint16.wrap(Impl.cast(Common.EUINT128_TFHE, euint128.unwrap(value), Common.EUINT16_TFHE));\\n    }\\n    /// @notice Converts a euint128 to an euint32\\n    function asEuint32(euint128 value) internal pure returns (euint32) {\\n        return euint32.wrap(Impl.cast(Common.EUINT128_TFHE, euint128.unwrap(value), Common.EUINT32_TFHE));\\n    }\\n    /// @notice Converts a euint128 to an euint64\\n    function asEuint64(euint128 value) internal pure returns (euint64) {\\n        return euint64.wrap(Impl.cast(Common.EUINT128_TFHE, euint128.unwrap(value), Common.EUINT64_TFHE));\\n    }\\n    /// @notice Parses input ciphertexts from the user. Converts from encrypted raw bytes to an euint128\\n    /// @dev Also performs validation that the ciphertext is valid and has been encrypted using the network encryption key\\n    /// @return a ciphertext representation of the input\\n    function asEuint128(inEuint128 memory value) internal pure returns (euint128) {\\n        return FHE.asEuint128(value.data);\\n    }\\n    /// @notice Converts a euint128 to an euint256\\n    function asEuint256(euint128 value) internal pure returns (euint256) {\\n        return euint256.wrap(Impl.cast(Common.EUINT128_TFHE, euint128.unwrap(value), Common.EUINT256_TFHE));\\n    }\\n    /// @notice Converts a euint128 to an eaddress\\n    function asEaddress(euint128 value) internal pure returns (eaddress) {\\n        return eaddress.wrap(Impl.cast(Common.EUINT128_TFHE, euint128.unwrap(value), Common.EADDRESS_TFHE));\\n    }\\n    \\n    /// @notice Converts a euint256 to an ebool\\n    function asEbool(euint256 value) internal pure returns (ebool) {\\n        return ne(value, asEuint256(0));\\n    }\\n    /// @notice Converts a euint256 to an euint8\\n    function asEuint8(euint256 value) internal pure returns (euint8) {\\n        return euint8.wrap(Impl.cast(Common.EUINT256_TFHE, euint256.unwrap(value), Common.EUINT8_TFHE));\\n    }\\n    /// @notice Converts a euint256 to an euint16\\n    function asEuint16(euint256 value) internal pure returns (euint16) {\\n        return euint16.wrap(Impl.cast(Common.EUINT256_TFHE, euint256.unwrap(value), Common.EUINT16_TFHE));\\n    }\\n    /// @notice Converts a euint256 to an euint32\\n    function asEuint32(euint256 value) internal pure returns (euint32) {\\n        return euint32.wrap(Impl.cast(Common.EUINT256_TFHE, euint256.unwrap(value), Common.EUINT32_TFHE));\\n    }\\n    /// @notice Converts a euint256 to an euint64\\n    function asEuint64(euint256 value) internal pure returns (euint64) {\\n        return euint64.wrap(Impl.cast(Common.EUINT256_TFHE, euint256.unwrap(value), Common.EUINT64_TFHE));\\n    }\\n    /// @notice Converts a euint256 to an euint128\\n    function asEuint128(euint256 value) internal pure returns (euint128) {\\n        return euint128.wrap(Impl.cast(Common.EUINT256_TFHE, euint256.unwrap(value), Common.EUINT128_TFHE));\\n    }\\n    /// @notice Parses input ciphertexts from the user. Converts from encrypted raw bytes to an euint256\\n    /// @dev Also performs validation that the ciphertext is valid and has been encrypted using the network encryption key\\n    /// @return a ciphertext representation of the input\\n    function asEuint256(inEuint256 memory value) internal pure returns (euint256) {\\n        return FHE.asEuint256(value.data);\\n    }\\n    /// @notice Converts a euint256 to an eaddress\\n    function asEaddress(euint256 value) internal pure returns (eaddress) {\\n        return eaddress.wrap(Impl.cast(Common.EUINT256_TFHE, euint256.unwrap(value), Common.EADDRESS_TFHE));\\n    }\\n    \\n    /// @notice Converts a eaddress to an ebool\\n    function asEbool(eaddress value) internal pure returns (ebool) {\\n        return ne(value, asEaddress(0));\\n    }\\n    /// @notice Converts a eaddress to an euint8\\n    function asEuint8(eaddress value) internal pure returns (euint8) {\\n        return euint8.wrap(Impl.cast(Common.EADDRESS_TFHE, eaddress.unwrap(value), Common.EUINT8_TFHE));\\n    }\\n    /// @notice Converts a eaddress to an euint16\\n    function asEuint16(eaddress value) internal pure returns (euint16) {\\n        return euint16.wrap(Impl.cast(Common.EADDRESS_TFHE, eaddress.unwrap(value), Common.EUINT16_TFHE));\\n    }\\n    /// @notice Converts a eaddress to an euint32\\n    function asEuint32(eaddress value) internal pure returns (euint32) {\\n        return euint32.wrap(Impl.cast(Common.EADDRESS_TFHE, eaddress.unwrap(value), Common.EUINT32_TFHE));\\n    }\\n    /// @notice Converts a eaddress to an euint64\\n    function asEuint64(eaddress value) internal pure returns (euint64) {\\n        return euint64.wrap(Impl.cast(Common.EADDRESS_TFHE, eaddress.unwrap(value), Common.EUINT64_TFHE));\\n    }\\n    /// @notice Converts a eaddress to an euint128\\n    function asEuint128(eaddress value) internal pure returns (euint128) {\\n        return euint128.wrap(Impl.cast(Common.EADDRESS_TFHE, eaddress.unwrap(value), Common.EUINT128_TFHE));\\n    }\\n    /// @notice Converts a eaddress to an euint256\\n    function asEuint256(eaddress value) internal pure returns (euint256) {\\n        return euint256.wrap(Impl.cast(Common.EADDRESS_TFHE, eaddress.unwrap(value), Common.EUINT256_TFHE));\\n    }\\n    /// @notice Parses input ciphertexts from the user. Converts from encrypted raw bytes to an eaddress\\n    /// @dev Also performs validation that the ciphertext is valid and has been encrypted using the network encryption key\\n    /// @return a ciphertext representation of the input\\n    function asEaddress(inEaddress memory value) internal pure returns (eaddress) {\\n        return FHE.asEaddress(value.data);\\n    }\\n    /// @notice Converts a uint256 to an ebool\\n    function asEbool(uint256 value) internal pure returns (ebool) {\\n        return ebool.wrap(Impl.trivialEncrypt(value, Common.EBOOL_TFHE));\\n    }\\n    /// @notice Converts a uint256 to an euint8\\n    function asEuint8(uint256 value) internal pure returns (euint8) {\\n        return euint8.wrap(Impl.trivialEncrypt(value, Common.EUINT8_TFHE));\\n    }\\n    /// @notice Converts a uint256 to an euint16\\n    function asEuint16(uint256 value) internal pure returns (euint16) {\\n        return euint16.wrap(Impl.trivialEncrypt(value, Common.EUINT16_TFHE));\\n    }\\n    /// @notice Converts a uint256 to an euint32\\n    function asEuint32(uint256 value) internal pure returns (euint32) {\\n        return euint32.wrap(Impl.trivialEncrypt(value, Common.EUINT32_TFHE));\\n    }\\n    /// @notice Converts a uint256 to an euint64\\n    function asEuint64(uint256 value) internal pure returns (euint64) {\\n        return euint64.wrap(Impl.trivialEncrypt(value, Common.EUINT64_TFHE));\\n    }\\n    /// @notice Converts a uint256 to an euint128\\n    function asEuint128(uint256 value) internal pure returns (euint128) {\\n        return euint128.wrap(Impl.trivialEncrypt(value, Common.EUINT128_TFHE));\\n    }\\n    /// @notice Converts a uint256 to an euint256\\n    function asEuint256(uint256 value) internal pure returns (euint256) {\\n        return euint256.wrap(Impl.trivialEncrypt(value, Common.EUINT256_TFHE));\\n    }\\n    /// @notice Converts a uint256 to an eaddress\\n    function asEaddress(uint256 value) internal pure returns (eaddress) {\\n        return eaddress.wrap(Impl.trivialEncrypt(value, Common.EADDRESS_TFHE));\\n    }\\n    /// @notice Parses input ciphertexts from the user. Converts from encrypted raw bytes to an ebool\\n    /// @dev Also performs validation that the ciphertext is valid and has been encrypted using the network encryption key\\n    /// @return a ciphertext representation of the input\\n    function asEbool(bytes memory value) internal pure returns (ebool) {\\n        return ebool.wrap(Impl.verify(value, Common.EBOOL_TFHE));\\n    }\\n    /// @notice Parses input ciphertexts from the user. Converts from encrypted raw bytes to an euint8\\n    /// @dev Also performs validation that the ciphertext is valid and has been encrypted using the network encryption key\\n    /// @return a ciphertext representation of the input\\n    function asEuint8(bytes memory value) internal pure returns (euint8) {\\n        return euint8.wrap(Impl.verify(value, Common.EUINT8_TFHE));\\n    }\\n    /// @notice Parses input ciphertexts from the user. Converts from encrypted raw bytes to an euint16\\n    /// @dev Also performs validation that the ciphertext is valid and has been encrypted using the network encryption key\\n    /// @return a ciphertext representation of the input\\n    function asEuint16(bytes memory value) internal pure returns (euint16) {\\n        return euint16.wrap(Impl.verify(value, Common.EUINT16_TFHE));\\n    }\\n    /// @notice Parses input ciphertexts from the user. Converts from encrypted raw bytes to an euint32\\n    /// @dev Also performs validation that the ciphertext is valid and has been encrypted using the network encryption key\\n    /// @return a ciphertext representation of the input\\n    function asEuint32(bytes memory value) internal pure returns (euint32) {\\n        return euint32.wrap(Impl.verify(value, Common.EUINT32_TFHE));\\n    }\\n    /// @notice Parses input ciphertexts from the user. Converts from encrypted raw bytes to an euint64\\n    /// @dev Also performs validation that the ciphertext is valid and has been encrypted using the network encryption key\\n    /// @return a ciphertext representation of the input\\n    function asEuint64(bytes memory value) internal pure returns (euint64) {\\n        return euint64.wrap(Impl.verify(value, Common.EUINT64_TFHE));\\n    }\\n    /// @notice Parses input ciphertexts from the user. Converts from encrypted raw bytes to an euint128\\n    /// @dev Also performs validation that the ciphertext is valid and has been encrypted using the network encryption key\\n    /// @return a ciphertext representation of the input\\n    function asEuint128(bytes memory value) internal pure returns (euint128) {\\n        return euint128.wrap(Impl.verify(value, Common.EUINT128_TFHE));\\n    }\\n    /// @notice Parses input ciphertexts from the user. Converts from encrypted raw bytes to an euint256\\n    /// @dev Also performs validation that the ciphertext is valid and has been encrypted using the network encryption key\\n    /// @return a ciphertext representation of the input\\n    function asEuint256(bytes memory value) internal pure returns (euint256) {\\n        return euint256.wrap(Impl.verify(value, Common.EUINT256_TFHE));\\n    }\\n    /// @notice Parses input ciphertexts from the user. Converts from encrypted raw bytes to an eaddress\\n    /// @dev Also performs validation that the ciphertext is valid and has been encrypted using the network encryption key\\n    /// @return a ciphertext representation of the input\\n    function asEaddress(bytes memory value) internal pure returns (eaddress) {\\n        return eaddress.wrap(Impl.verify(value, Common.EADDRESS_TFHE));\\n    }\\n    /// @notice Converts a address to an eaddress\\n    /// Allows for a better user experience when working with eaddresses\\n    function asEaddress(address value) internal pure returns (eaddress) {\\n        return eaddress.wrap(Impl.trivialEncrypt(uint256(uint160(value)), Common.EADDRESS_TFHE));\\n    }\\n    /// @notice Converts a plaintext boolean value to a ciphertext ebool\\n    /// @dev Privacy: The input value is public, therefore the ciphertext should be considered public and should be used\\n    ///only for mathematical operations, not to represent data that should be private\\n    /// @return A ciphertext representation of the input \\n    function asEbool(bool value) internal pure returns (ebool) {\\n        uint256 sVal = 0;\\n        if (value) {\\n            sVal = 1;\\n        }\\n\\n        return asEbool(sVal);\\n    }\\n}\\n\\n// ********** OPERATOR OVERLOADING ************* //\\n\\nusing {operatorAddEuint8 as +} for euint8 global;\\n/// @notice Performs the add operation\\nfunction operatorAddEuint8(euint8 lhs, euint8 rhs) pure returns (euint8) {\\n    return FHE.add(lhs, rhs);\\n}\\n\\nusing {operatorAddEuint16 as +} for euint16 global;\\n/// @notice Performs the add operation\\nfunction operatorAddEuint16(euint16 lhs, euint16 rhs) pure returns (euint16) {\\n    return FHE.add(lhs, rhs);\\n}\\n\\nusing {operatorAddEuint32 as +} for euint32 global;\\n/// @notice Performs the add operation\\nfunction operatorAddEuint32(euint32 lhs, euint32 rhs) pure returns (euint32) {\\n    return FHE.add(lhs, rhs);\\n}\\n\\nusing {operatorAddEuint64 as +} for euint64 global;\\n/// @notice Performs the add operation\\nfunction operatorAddEuint64(euint64 lhs, euint64 rhs) pure returns (euint64) {\\n    return FHE.add(lhs, rhs);\\n}\\n\\nusing {operatorAddEuint128 as +} for euint128 global;\\n/// @notice Performs the add operation\\nfunction operatorAddEuint128(euint128 lhs, euint128 rhs) pure returns (euint128) {\\n    return FHE.add(lhs, rhs);\\n}\\n\\nusing {operatorSubEuint8 as -} for euint8 global;\\n/// @notice Performs the sub operation\\nfunction operatorSubEuint8(euint8 lhs, euint8 rhs) pure returns (euint8) {\\n    return FHE.sub(lhs, rhs);\\n}\\n\\nusing {operatorSubEuint16 as -} for euint16 global;\\n/// @notice Performs the sub operation\\nfunction operatorSubEuint16(euint16 lhs, euint16 rhs) pure returns (euint16) {\\n    return FHE.sub(lhs, rhs);\\n}\\n\\nusing {operatorSubEuint32 as -} for euint32 global;\\n/// @notice Performs the sub operation\\nfunction operatorSubEuint32(euint32 lhs, euint32 rhs) pure returns (euint32) {\\n    return FHE.sub(lhs, rhs);\\n}\\n\\nusing {operatorSubEuint64 as -} for euint64 global;\\n/// @notice Performs the sub operation\\nfunction operatorSubEuint64(euint64 lhs, euint64 rhs) pure returns (euint64) {\\n    return FHE.sub(lhs, rhs);\\n}\\n\\nusing {operatorSubEuint128 as -} for euint128 global;\\n/// @notice Performs the sub operation\\nfunction operatorSubEuint128(euint128 lhs, euint128 rhs) pure returns (euint128) {\\n    return FHE.sub(lhs, rhs);\\n}\\n\\nusing {operatorMulEuint8 as *} for euint8 global;\\n/// @notice Performs the mul operation\\nfunction operatorMulEuint8(euint8 lhs, euint8 rhs) pure returns (euint8) {\\n    return FHE.mul(lhs, rhs);\\n}\\n\\nusing {operatorMulEuint16 as *} for euint16 global;\\n/// @notice Performs the mul operation\\nfunction operatorMulEuint16(euint16 lhs, euint16 rhs) pure returns (euint16) {\\n    return FHE.mul(lhs, rhs);\\n}\\n\\nusing {operatorMulEuint32 as *} for euint32 global;\\n/// @notice Performs the mul operation\\nfunction operatorMulEuint32(euint32 lhs, euint32 rhs) pure returns (euint32) {\\n    return FHE.mul(lhs, rhs);\\n}\\n\\nusing {operatorMulEuint64 as *} for euint64 global;\\n/// @notice Performs the mul operation\\nfunction operatorMulEuint64(euint64 lhs, euint64 rhs) pure returns (euint64) {\\n    return FHE.mul(lhs, rhs);\\n}\\n\\nusing {operatorDivEuint8 as /} for euint8 global;\\n/// @notice Performs the div operation\\nfunction operatorDivEuint8(euint8 lhs, euint8 rhs) pure returns (euint8) {\\n    return FHE.div(lhs, rhs);\\n}\\n\\nusing {operatorDivEuint16 as /} for euint16 global;\\n/// @notice Performs the div operation\\nfunction operatorDivEuint16(euint16 lhs, euint16 rhs) pure returns (euint16) {\\n    return FHE.div(lhs, rhs);\\n}\\n\\nusing {operatorDivEuint32 as /} for euint32 global;\\n/// @notice Performs the div operation\\nfunction operatorDivEuint32(euint32 lhs, euint32 rhs) pure returns (euint32) {\\n    return FHE.div(lhs, rhs);\\n}\\n\\nusing {operatorOrEbool as |} for ebool global;\\n/// @notice Performs the or operation\\nfunction operatorOrEbool(ebool lhs, ebool rhs) pure returns (ebool) {\\n    return FHE.or(lhs, rhs);\\n}\\n\\nusing {operatorOrEuint8 as |} for euint8 global;\\n/// @notice Performs the or operation\\nfunction operatorOrEuint8(euint8 lhs, euint8 rhs) pure returns (euint8) {\\n    return FHE.or(lhs, rhs);\\n}\\n\\nusing {operatorOrEuint16 as |} for euint16 global;\\n/// @notice Performs the or operation\\nfunction operatorOrEuint16(euint16 lhs, euint16 rhs) pure returns (euint16) {\\n    return FHE.or(lhs, rhs);\\n}\\n\\nusing {operatorOrEuint32 as |} for euint32 global;\\n/// @notice Performs the or operation\\nfunction operatorOrEuint32(euint32 lhs, euint32 rhs) pure returns (euint32) {\\n    return FHE.or(lhs, rhs);\\n}\\n\\nusing {operatorOrEuint64 as |} for euint64 global;\\n/// @notice Performs the or operation\\nfunction operatorOrEuint64(euint64 lhs, euint64 rhs) pure returns (euint64) {\\n    return FHE.or(lhs, rhs);\\n}\\n\\nusing {operatorOrEuint128 as |} for euint128 global;\\n/// @notice Performs the or operation\\nfunction operatorOrEuint128(euint128 lhs, euint128 rhs) pure returns (euint128) {\\n    return FHE.or(lhs, rhs);\\n}\\n\\nusing {operatorAndEbool as &} for ebool global;\\n/// @notice Performs the and operation\\nfunction operatorAndEbool(ebool lhs, ebool rhs) pure returns (ebool) {\\n    return FHE.and(lhs, rhs);\\n}\\n\\nusing {operatorAndEuint8 as &} for euint8 global;\\n/// @notice Performs the and operation\\nfunction operatorAndEuint8(euint8 lhs, euint8 rhs) pure returns (euint8) {\\n    return FHE.and(lhs, rhs);\\n}\\n\\nusing {operatorAndEuint16 as &} for euint16 global;\\n/// @notice Performs the and operation\\nfunction operatorAndEuint16(euint16 lhs, euint16 rhs) pure returns (euint16) {\\n    return FHE.and(lhs, rhs);\\n}\\n\\nusing {operatorAndEuint32 as &} for euint32 global;\\n/// @notice Performs the and operation\\nfunction operatorAndEuint32(euint32 lhs, euint32 rhs) pure returns (euint32) {\\n    return FHE.and(lhs, rhs);\\n}\\n\\nusing {operatorAndEuint64 as &} for euint64 global;\\n/// @notice Performs the and operation\\nfunction operatorAndEuint64(euint64 lhs, euint64 rhs) pure returns (euint64) {\\n    return FHE.and(lhs, rhs);\\n}\\n\\nusing {operatorAndEuint128 as &} for euint128 global;\\n/// @notice Performs the and operation\\nfunction operatorAndEuint128(euint128 lhs, euint128 rhs) pure returns (euint128) {\\n    return FHE.and(lhs, rhs);\\n}\\n\\nusing {operatorXorEbool as ^} for ebool global;\\n/// @notice Performs the xor operation\\nfunction operatorXorEbool(ebool lhs, ebool rhs) pure returns (ebool) {\\n    return FHE.xor(lhs, rhs);\\n}\\n\\nusing {operatorXorEuint8 as ^} for euint8 global;\\n/// @notice Performs the xor operation\\nfunction operatorXorEuint8(euint8 lhs, euint8 rhs) pure returns (euint8) {\\n    return FHE.xor(lhs, rhs);\\n}\\n\\nusing {operatorXorEuint16 as ^} for euint16 global;\\n/// @notice Performs the xor operation\\nfunction operatorXorEuint16(euint16 lhs, euint16 rhs) pure returns (euint16) {\\n    return FHE.xor(lhs, rhs);\\n}\\n\\nusing {operatorXorEuint32 as ^} for euint32 global;\\n/// @notice Performs the xor operation\\nfunction operatorXorEuint32(euint32 lhs, euint32 rhs) pure returns (euint32) {\\n    return FHE.xor(lhs, rhs);\\n}\\n\\nusing {operatorXorEuint64 as ^} for euint64 global;\\n/// @notice Performs the xor operation\\nfunction operatorXorEuint64(euint64 lhs, euint64 rhs) pure returns (euint64) {\\n    return FHE.xor(lhs, rhs);\\n}\\n\\nusing {operatorXorEuint128 as ^} for euint128 global;\\n/// @notice Performs the xor operation\\nfunction operatorXorEuint128(euint128 lhs, euint128 rhs) pure returns (euint128) {\\n    return FHE.xor(lhs, rhs);\\n}\\n\\nusing {operatorRemEuint8 as %} for euint8 global;\\n/// @notice Performs the rem operation\\nfunction operatorRemEuint8(euint8 lhs, euint8 rhs) pure returns (euint8) {\\n    return FHE.rem(lhs, rhs);\\n}\\n\\nusing {operatorRemEuint16 as %} for euint16 global;\\n/// @notice Performs the rem operation\\nfunction operatorRemEuint16(euint16 lhs, euint16 rhs) pure returns (euint16) {\\n    return FHE.rem(lhs, rhs);\\n}\\n\\nusing {operatorRemEuint32 as %} for euint32 global;\\n/// @notice Performs the rem operation\\nfunction operatorRemEuint32(euint32 lhs, euint32 rhs) pure returns (euint32) {\\n    return FHE.rem(lhs, rhs);\\n}\\n\\n// ********** BINDING DEFS ************* //\\n\\nusing BindingsEbool for ebool global;\\nlibrary BindingsEbool {\\n    \\n    /// @notice Performs the eq operation\\n    /// @dev Pure in this function is marked as a hack/workaround - note that this function is NOT pure as fetches of ciphertexts require state access\\n    /// @param lhs input of type ebool\\n    /// @return the result of the eq\\n    function eq(ebool lhs, ebool rhs) internal pure returns (ebool) {\\n        return FHE.eq(lhs, rhs);\\n    }\\n    \\n    /// @notice Performs the ne operation\\n    /// @dev Pure in this function is marked as a hack/workaround - note that this function is NOT pure as fetches of ciphertexts require state access\\n    /// @param lhs input of type ebool\\n    /// @return the result of the ne\\n    function ne(ebool lhs, ebool rhs) internal pure returns (ebool) {\\n        return FHE.ne(lhs, rhs);\\n    }\\n    \\n    /// @notice Performs the and operation\\n    /// @dev Pure in this function is marked as a hack/workaround - note that this function is NOT pure as fetches of ciphertexts require state access\\n    /// @param lhs input of type ebool\\n    /// @return the result of the and\\n    function and(ebool lhs, ebool rhs) internal pure returns (ebool) {\\n        return FHE.and(lhs, rhs);\\n    }\\n    \\n    /// @notice Performs the or operation\\n    /// @dev Pure in this function is marked as a hack/workaround - note that this function is NOT pure as fetches of ciphertexts require state access\\n    /// @param lhs input of type ebool\\n    /// @return the result of the or\\n    function or(ebool lhs, ebool rhs) internal pure returns (ebool) {\\n        return FHE.or(lhs, rhs);\\n    }\\n    \\n    /// @notice Performs the xor operation\\n    /// @dev Pure in this function is marked as a hack/workaround - note that this function is NOT pure as fetches of ciphertexts require state access\\n    /// @param lhs input of type ebool\\n    /// @return the result of the xor\\n    function xor(ebool lhs, ebool rhs) internal pure returns (ebool) {\\n        return FHE.xor(lhs, rhs);\\n    }\\n    function toU8(ebool value) internal pure returns (euint8) {\\n        return FHE.asEuint8(value);\\n    }\\n    function toU16(ebool value) internal pure returns (euint16) {\\n        return FHE.asEuint16(value);\\n    }\\n    function toU32(ebool value) internal pure returns (euint32) {\\n        return FHE.asEuint32(value);\\n    }\\n    function toU64(ebool value) internal pure returns (euint64) {\\n        return FHE.asEuint64(value);\\n    }\\n    function toU128(ebool value) internal pure returns (euint128) {\\n        return FHE.asEuint128(value);\\n    }\\n    function toU256(ebool value) internal pure returns (euint256) {\\n        return FHE.asEuint256(value);\\n    }\\n    function toEaddress(ebool value) internal pure returns (eaddress) {\\n        return FHE.asEaddress(value);\\n    }\\n    function seal(ebool value, bytes32 publicKey) internal pure returns (string memory) {\\n        return FHE.sealoutput(value, publicKey);\\n    }\\n    function decrypt(ebool value) internal pure returns (bool) {\\n        return FHE.decrypt(value);\\n    }\\n}\\n\\nusing BindingsEuint8 for euint8 global;\\nlibrary BindingsEuint8 {\\n    \\n    /// @notice Performs the add operation\\n    /// @dev Pure in this function is marked as a hack/workaround - note that this function is NOT pure as fetches of ciphertexts require state access\\n    /// @param lhs input of type euint8\\n    /// @return the result of the add\\n    function add(euint8 lhs, euint8 rhs) internal pure returns (euint8) {\\n        return FHE.add(lhs, rhs);\\n    }\\n    \\n    /// @notice Performs the mul operation\\n    /// @dev Pure in this function is marked as a hack/workaround - note that this function is NOT pure as fetches of ciphertexts require state access\\n    /// @param lhs input of type euint8\\n    /// @return the result of the mul\\n    function mul(euint8 lhs, euint8 rhs) internal pure returns (euint8) {\\n        return FHE.mul(lhs, rhs);\\n    }\\n    \\n    /// @notice Performs the div operation\\n    /// @dev Pure in this function is marked as a hack/workaround - note that this function is NOT pure as fetches of ciphertexts require state access\\n    /// @param lhs input of type euint8\\n    /// @return the result of the div\\n    function div(euint8 lhs, euint8 rhs) internal pure returns (euint8) {\\n        return FHE.div(lhs, rhs);\\n    }\\n    \\n    /// @notice Performs the sub operation\\n    /// @dev Pure in this function is marked as a hack/workaround - note that this function is NOT pure as fetches of ciphertexts require state access\\n    /// @param lhs input of type euint8\\n    /// @return the result of the sub\\n    function sub(euint8 lhs, euint8 rhs) internal pure returns (euint8) {\\n        return FHE.sub(lhs, rhs);\\n    }\\n    \\n    /// @notice Performs the eq operation\\n    /// @dev Pure in this function is marked as a hack/workaround - note that this function is NOT pure as fetches of ciphertexts require state access\\n    /// @param lhs input of type euint8\\n    /// @return the result of the eq\\n    function eq(euint8 lhs, euint8 rhs) internal pure returns (ebool) {\\n        return FHE.eq(lhs, rhs);\\n    }\\n    \\n    /// @notice Performs the ne operation\\n    /// @dev Pure in this function is marked as a hack/workaround - note that this function is NOT pure as fetches of ciphertexts require state access\\n    /// @param lhs input of type euint8\\n    /// @return the result of the ne\\n    function ne(euint8 lhs, euint8 rhs) internal pure returns (ebool) {\\n        return FHE.ne(lhs, rhs);\\n    }\\n    \\n    /// @notice Performs the and operation\\n    /// @dev Pure in this function is marked as a hack/workaround - note that this function is NOT pure as fetches of ciphertexts require state access\\n    /// @param lhs input of type euint8\\n    /// @return the result of the and\\n    function and(euint8 lhs, euint8 rhs) internal pure returns (euint8) {\\n        return FHE.and(lhs, rhs);\\n    }\\n    \\n    /// @notice Performs the or operation\\n    /// @dev Pure in this function is marked as a hack/workaround - note that this function is NOT pure as fetches of ciphertexts require state access\\n    /// @param lhs input of type euint8\\n    /// @return the result of the or\\n    function or(euint8 lhs, euint8 rhs) internal pure returns (euint8) {\\n        return FHE.or(lhs, rhs);\\n    }\\n    \\n    /// @notice Performs the xor operation\\n    /// @dev Pure in this function is marked as a hack/workaround - note that this function is NOT pure as fetches of ciphertexts require state access\\n    /// @param lhs input of type euint8\\n    /// @return the result of the xor\\n    function xor(euint8 lhs, euint8 rhs) internal pure returns (euint8) {\\n        return FHE.xor(lhs, rhs);\\n    }\\n    \\n    /// @notice Performs the gt operation\\n    /// @dev Pure in this function is marked as a hack/workaround - note that this function is NOT pure as fetches of ciphertexts require state access\\n    /// @param lhs input of type euint8\\n    /// @return the result of the gt\\n    function gt(euint8 lhs, euint8 rhs) internal pure returns (ebool) {\\n        return FHE.gt(lhs, rhs);\\n    }\\n    \\n    /// @notice Performs the gte operation\\n    /// @dev Pure in this function is marked as a hack/workaround - note that this function is NOT pure as fetches of ciphertexts require state access\\n    /// @param lhs input of type euint8\\n    /// @return the result of the gte\\n    function gte(euint8 lhs, euint8 rhs) internal pure returns (ebool) {\\n        return FHE.gte(lhs, rhs);\\n    }\\n    \\n    /// @notice Performs the lt operation\\n    /// @dev Pure in this function is marked as a hack/workaround - note that this function is NOT pure as fetches of ciphertexts require state access\\n    /// @param lhs input of type euint8\\n    /// @return the result of the lt\\n    function lt(euint8 lhs, euint8 rhs) internal pure returns (ebool) {\\n        return FHE.lt(lhs, rhs);\\n    }\\n    \\n    /// @notice Performs the lte operation\\n    /// @dev Pure in this function is marked as a hack/workaround - note that this function is NOT pure as fetches of ciphertexts require state access\\n    /// @param lhs input of type euint8\\n    /// @return the result of the lte\\n    function lte(euint8 lhs, euint8 rhs) internal pure returns (ebool) {\\n        return FHE.lte(lhs, rhs);\\n    }\\n    \\n    /// @notice Performs the rem operation\\n    /// @dev Pure in this function is marked as a hack/workaround - note that this function is NOT pure as fetches of ciphertexts require state access\\n    /// @param lhs input of type euint8\\n    /// @return the result of the rem\\n    function rem(euint8 lhs, euint8 rhs) internal pure returns (euint8) {\\n        return FHE.rem(lhs, rhs);\\n    }\\n    \\n    /// @notice Performs the max operation\\n    /// @dev Pure in this function is marked as a hack/workaround - note that this function is NOT pure as fetches of ciphertexts require state access\\n    /// @param lhs input of type euint8\\n    /// @return the result of the max\\n    function max(euint8 lhs, euint8 rhs) internal pure returns (euint8) {\\n        return FHE.max(lhs, rhs);\\n    }\\n    \\n    /// @notice Performs the min operation\\n    /// @dev Pure in this function is marked as a hack/workaround - note that this function is NOT pure as fetches of ciphertexts require state access\\n    /// @param lhs input of type euint8\\n    /// @return the result of the min\\n    function min(euint8 lhs, euint8 rhs) internal pure returns (euint8) {\\n        return FHE.min(lhs, rhs);\\n    }\\n    \\n    /// @notice Performs the shl operation\\n    /// @dev Pure in this function is marked as a hack/workaround - note that this function is NOT pure as fetches of ciphertexts require state access\\n    /// @param lhs input of type euint8\\n    /// @return the result of the shl\\n    function shl(euint8 lhs, euint8 rhs) internal pure returns (euint8) {\\n        return FHE.shl(lhs, rhs);\\n    }\\n    \\n    /// @notice Performs the shr operation\\n    /// @dev Pure in this function is marked as a hack/workaround - note that this function is NOT pure as fetches of ciphertexts require state access\\n    /// @param lhs input of type euint8\\n    /// @return the result of the shr\\n    function shr(euint8 lhs, euint8 rhs) internal pure returns (euint8) {\\n        return FHE.shr(lhs, rhs);\\n    }\\n    function toBool(euint8 value) internal pure returns (ebool) {\\n        return FHE.asEbool(value);\\n    }\\n    function toU16(euint8 value) internal pure returns (euint16) {\\n        return FHE.asEuint16(value);\\n    }\\n    function toU32(euint8 value) internal pure returns (euint32) {\\n        return FHE.asEuint32(value);\\n    }\\n    function toU64(euint8 value) internal pure returns (euint64) {\\n        return FHE.asEuint64(value);\\n    }\\n    function toU128(euint8 value) internal pure returns (euint128) {\\n        return FHE.asEuint128(value);\\n    }\\n    function toU256(euint8 value) internal pure returns (euint256) {\\n        return FHE.asEuint256(value);\\n    }\\n    function toEaddress(euint8 value) internal pure returns (eaddress) {\\n        return FHE.asEaddress(value);\\n    }\\n    function seal(euint8 value, bytes32 publicKey) internal pure returns (string memory) {\\n        return FHE.sealoutput(value, publicKey);\\n    }\\n    function decrypt(euint8 value) internal pure returns (uint8) {\\n        return FHE.decrypt(value);\\n    }\\n}\\n\\nusing BindingsEuint16 for euint16 global;\\nlibrary BindingsEuint16 {\\n    \\n    /// @notice Performs the add operation\\n    /// @dev Pure in this function is marked as a hack/workaround - note that this function is NOT pure as fetches of ciphertexts require state access\\n    /// @param lhs input of type euint16\\n    /// @return the result of the add\\n    function add(euint16 lhs, euint16 rhs) internal pure returns (euint16) {\\n        return FHE.add(lhs, rhs);\\n    }\\n    \\n    /// @notice Performs the mul operation\\n    /// @dev Pure in this function is marked as a hack/workaround - note that this function is NOT pure as fetches of ciphertexts require state access\\n    /// @param lhs input of type euint16\\n    /// @return the result of the mul\\n    function mul(euint16 lhs, euint16 rhs) internal pure returns (euint16) {\\n        return FHE.mul(lhs, rhs);\\n    }\\n    \\n    /// @notice Performs the div operation\\n    /// @dev Pure in this function is marked as a hack/workaround - note that this function is NOT pure as fetches of ciphertexts require state access\\n    /// @param lhs input of type euint16\\n    /// @return the result of the div\\n    function div(euint16 lhs, euint16 rhs) internal pure returns (euint16) {\\n        return FHE.div(lhs, rhs);\\n    }\\n    \\n    /// @notice Performs the sub operation\\n    /// @dev Pure in this function is marked as a hack/workaround - note that this function is NOT pure as fetches of ciphertexts require state access\\n    /// @param lhs input of type euint16\\n    /// @return the result of the sub\\n    function sub(euint16 lhs, euint16 rhs) internal pure returns (euint16) {\\n        return FHE.sub(lhs, rhs);\\n    }\\n    \\n    /// @notice Performs the eq operation\\n    /// @dev Pure in this function is marked as a hack/workaround - note that this function is NOT pure as fetches of ciphertexts require state access\\n    /// @param lhs input of type euint16\\n    /// @return the result of the eq\\n    function eq(euint16 lhs, euint16 rhs) internal pure returns (ebool) {\\n        return FHE.eq(lhs, rhs);\\n    }\\n    \\n    /// @notice Performs the ne operation\\n    /// @dev Pure in this function is marked as a hack/workaround - note that this function is NOT pure as fetches of ciphertexts require state access\\n    /// @param lhs input of type euint16\\n    /// @return the result of the ne\\n    function ne(euint16 lhs, euint16 rhs) internal pure returns (ebool) {\\n        return FHE.ne(lhs, rhs);\\n    }\\n    \\n    /// @notice Performs the and operation\\n    /// @dev Pure in this function is marked as a hack/workaround - note that this function is NOT pure as fetches of ciphertexts require state access\\n    /// @param lhs input of type euint16\\n    /// @return the result of the and\\n    function and(euint16 lhs, euint16 rhs) internal pure returns (euint16) {\\n        return FHE.and(lhs, rhs);\\n    }\\n    \\n    /// @notice Performs the or operation\\n    /// @dev Pure in this function is marked as a hack/workaround - note that this function is NOT pure as fetches of ciphertexts require state access\\n    /// @param lhs input of type euint16\\n    /// @return the result of the or\\n    function or(euint16 lhs, euint16 rhs) internal pure returns (euint16) {\\n        return FHE.or(lhs, rhs);\\n    }\\n    \\n    /// @notice Performs the xor operation\\n    /// @dev Pure in this function is marked as a hack/workaround - note that this function is NOT pure as fetches of ciphertexts require state access\\n    /// @param lhs input of type euint16\\n    /// @return the result of the xor\\n    function xor(euint16 lhs, euint16 rhs) internal pure returns (euint16) {\\n        return FHE.xor(lhs, rhs);\\n    }\\n    \\n    /// @notice Performs the gt operation\\n    /// @dev Pure in this function is marked as a hack/workaround - note that this function is NOT pure as fetches of ciphertexts require state access\\n    /// @param lhs input of type euint16\\n    /// @return the result of the gt\\n    function gt(euint16 lhs, euint16 rhs) internal pure returns (ebool) {\\n        return FHE.gt(lhs, rhs);\\n    }\\n    \\n    /// @notice Performs the gte operation\\n    /// @dev Pure in this function is marked as a hack/workaround - note that this function is NOT pure as fetches of ciphertexts require state access\\n    /// @param lhs input of type euint16\\n    /// @return the result of the gte\\n    function gte(euint16 lhs, euint16 rhs) internal pure returns (ebool) {\\n        return FHE.gte(lhs, rhs);\\n    }\\n    \\n    /// @notice Performs the lt operation\\n    /// @dev Pure in this function is marked as a hack/workaround - note that this function is NOT pure as fetches of ciphertexts require state access\\n    /// @param lhs input of type euint16\\n    /// @return the result of the lt\\n    function lt(euint16 lhs, euint16 rhs) internal pure returns (ebool) {\\n        return FHE.lt(lhs, rhs);\\n    }\\n    \\n    /// @notice Performs the lte operation\\n    /// @dev Pure in this function is marked as a hack/workaround - note that this function is NOT pure as fetches of ciphertexts require state access\\n    /// @param lhs input of type euint16\\n    /// @return the result of the lte\\n    function lte(euint16 lhs, euint16 rhs) internal pure returns (ebool) {\\n        return FHE.lte(lhs, rhs);\\n    }\\n    \\n    /// @notice Performs the rem operation\\n    /// @dev Pure in this function is marked as a hack/workaround - note that this function is NOT pure as fetches of ciphertexts require state access\\n    /// @param lhs input of type euint16\\n    /// @return the result of the rem\\n    function rem(euint16 lhs, euint16 rhs) internal pure returns (euint16) {\\n        return FHE.rem(lhs, rhs);\\n    }\\n    \\n    /// @notice Performs the max operation\\n    /// @dev Pure in this function is marked as a hack/workaround - note that this function is NOT pure as fetches of ciphertexts require state access\\n    /// @param lhs input of type euint16\\n    /// @return the result of the max\\n    function max(euint16 lhs, euint16 rhs) internal pure returns (euint16) {\\n        return FHE.max(lhs, rhs);\\n    }\\n    \\n    /// @notice Performs the min operation\\n    /// @dev Pure in this function is marked as a hack/workaround - note that this function is NOT pure as fetches of ciphertexts require state access\\n    /// @param lhs input of type euint16\\n    /// @return the result of the min\\n    function min(euint16 lhs, euint16 rhs) internal pure returns (euint16) {\\n        return FHE.min(lhs, rhs);\\n    }\\n    \\n    /// @notice Performs the shl operation\\n    /// @dev Pure in this function is marked as a hack/workaround - note that this function is NOT pure as fetches of ciphertexts require state access\\n    /// @param lhs input of type euint16\\n    /// @return the result of the shl\\n    function shl(euint16 lhs, euint16 rhs) internal pure returns (euint16) {\\n        return FHE.shl(lhs, rhs);\\n    }\\n    \\n    /// @notice Performs the shr operation\\n    /// @dev Pure in this function is marked as a hack/workaround - note that this function is NOT pure as fetches of ciphertexts require state access\\n    /// @param lhs input of type euint16\\n    /// @return the result of the shr\\n    function shr(euint16 lhs, euint16 rhs) internal pure returns (euint16) {\\n        return FHE.shr(lhs, rhs);\\n    }\\n    function toBool(euint16 value) internal pure returns (ebool) {\\n        return FHE.asEbool(value);\\n    }\\n    function toU8(euint16 value) internal pure returns (euint8) {\\n        return FHE.asEuint8(value);\\n    }\\n    function toU32(euint16 value) internal pure returns (euint32) {\\n        return FHE.asEuint32(value);\\n    }\\n    function toU64(euint16 value) internal pure returns (euint64) {\\n        return FHE.asEuint64(value);\\n    }\\n    function toU128(euint16 value) internal pure returns (euint128) {\\n        return FHE.asEuint128(value);\\n    }\\n    function toU256(euint16 value) internal pure returns (euint256) {\\n        return FHE.asEuint256(value);\\n    }\\n    function toEaddress(euint16 value) internal pure returns (eaddress) {\\n        return FHE.asEaddress(value);\\n    }\\n    function seal(euint16 value, bytes32 publicKey) internal pure returns (string memory) {\\n        return FHE.sealoutput(value, publicKey);\\n    }\\n    function decrypt(euint16 value) internal pure returns (uint16) {\\n        return FHE.decrypt(value);\\n    }\\n}\\n\\nusing BindingsEuint32 for euint32 global;\\nlibrary BindingsEuint32 {\\n    \\n    /// @notice Performs the add operation\\n    /// @dev Pure in this function is marked as a hack/workaround - note that this function is NOT pure as fetches of ciphertexts require state access\\n    /// @param lhs input of type euint32\\n    /// @return the result of the add\\n    function add(euint32 lhs, euint32 rhs) internal pure returns (euint32) {\\n        return FHE.add(lhs, rhs);\\n    }\\n    \\n    /// @notice Performs the mul operation\\n    /// @dev Pure in this function is marked as a hack/workaround - note that this function is NOT pure as fetches of ciphertexts require state access\\n    /// @param lhs input of type euint32\\n    /// @return the result of the mul\\n    function mul(euint32 lhs, euint32 rhs) internal pure returns (euint32) {\\n        return FHE.mul(lhs, rhs);\\n    }\\n    \\n    /// @notice Performs the div operation\\n    /// @dev Pure in this function is marked as a hack/workaround - note that this function is NOT pure as fetches of ciphertexts require state access\\n    /// @param lhs input of type euint32\\n    /// @return the result of the div\\n    function div(euint32 lhs, euint32 rhs) internal pure returns (euint32) {\\n        return FHE.div(lhs, rhs);\\n    }\\n    \\n    /// @notice Performs the sub operation\\n    /// @dev Pure in this function is marked as a hack/workaround - note that this function is NOT pure as fetches of ciphertexts require state access\\n    /// @param lhs input of type euint32\\n    /// @return the result of the sub\\n    function sub(euint32 lhs, euint32 rhs) internal pure returns (euint32) {\\n        return FHE.sub(lhs, rhs);\\n    }\\n    \\n    /// @notice Performs the eq operation\\n    /// @dev Pure in this function is marked as a hack/workaround - note that this function is NOT pure as fetches of ciphertexts require state access\\n    /// @param lhs input of type euint32\\n    /// @return the result of the eq\\n    function eq(euint32 lhs, euint32 rhs) internal pure returns (ebool) {\\n        return FHE.eq(lhs, rhs);\\n    }\\n    \\n    /// @notice Performs the ne operation\\n    /// @dev Pure in this function is marked as a hack/workaround - note that this function is NOT pure as fetches of ciphertexts require state access\\n    /// @param lhs input of type euint32\\n    /// @return the result of the ne\\n    function ne(euint32 lhs, euint32 rhs) internal pure returns (ebool) {\\n        return FHE.ne(lhs, rhs);\\n    }\\n    \\n    /// @notice Performs the and operation\\n    /// @dev Pure in this function is marked as a hack/workaround - note that this function is NOT pure as fetches of ciphertexts require state access\\n    /// @param lhs input of type euint32\\n    /// @return the result of the and\\n    function and(euint32 lhs, euint32 rhs) internal pure returns (euint32) {\\n        return FHE.and(lhs, rhs);\\n    }\\n    \\n    /// @notice Performs the or operation\\n    /// @dev Pure in this function is marked as a hack/workaround - note that this function is NOT pure as fetches of ciphertexts require state access\\n    /// @param lhs input of type euint32\\n    /// @return the result of the or\\n    function or(euint32 lhs, euint32 rhs) internal pure returns (euint32) {\\n        return FHE.or(lhs, rhs);\\n    }\\n    \\n    /// @notice Performs the xor operation\\n    /// @dev Pure in this function is marked as a hack/workaround - note that this function is NOT pure as fetches of ciphertexts require state access\\n    /// @param lhs input of type euint32\\n    /// @return the result of the xor\\n    function xor(euint32 lhs, euint32 rhs) internal pure returns (euint32) {\\n        return FHE.xor(lhs, rhs);\\n    }\\n    \\n    /// @notice Performs the gt operation\\n    /// @dev Pure in this function is marked as a hack/workaround - note that this function is NOT pure as fetches of ciphertexts require state access\\n    /// @param lhs input of type euint32\\n    /// @return the result of the gt\\n    function gt(euint32 lhs, euint32 rhs) internal pure returns (ebool) {\\n        return FHE.gt(lhs, rhs);\\n    }\\n    \\n    /// @notice Performs the gte operation\\n    /// @dev Pure in this function is marked as a hack/workaround - note that this function is NOT pure as fetches of ciphertexts require state access\\n    /// @param lhs input of type euint32\\n    /// @return the result of the gte\\n    function gte(euint32 lhs, euint32 rhs) internal pure returns (ebool) {\\n        return FHE.gte(lhs, rhs);\\n    }\\n    \\n    /// @notice Performs the lt operation\\n    /// @dev Pure in this function is marked as a hack/workaround - note that this function is NOT pure as fetches of ciphertexts require state access\\n    /// @param lhs input of type euint32\\n    /// @return the result of the lt\\n    function lt(euint32 lhs, euint32 rhs) internal pure returns (ebool) {\\n        return FHE.lt(lhs, rhs);\\n    }\\n    \\n    /// @notice Performs the lte operation\\n    /// @dev Pure in this function is marked as a hack/workaround - note that this function is NOT pure as fetches of ciphertexts require state access\\n    /// @param lhs input of type euint32\\n    /// @return the result of the lte\\n    function lte(euint32 lhs, euint32 rhs) internal pure returns (ebool) {\\n        return FHE.lte(lhs, rhs);\\n    }\\n    \\n    /// @notice Performs the rem operation\\n    /// @dev Pure in this function is marked as a hack/workaround - note that this function is NOT pure as fetches of ciphertexts require state access\\n    /// @param lhs input of type euint32\\n    /// @return the result of the rem\\n    function rem(euint32 lhs, euint32 rhs) internal pure returns (euint32) {\\n        return FHE.rem(lhs, rhs);\\n    }\\n    \\n    /// @notice Performs the max operation\\n    /// @dev Pure in this function is marked as a hack/workaround - note that this function is NOT pure as fetches of ciphertexts require state access\\n    /// @param lhs input of type euint32\\n    /// @return the result of the max\\n    function max(euint32 lhs, euint32 rhs) internal pure returns (euint32) {\\n        return FHE.max(lhs, rhs);\\n    }\\n    \\n    /// @notice Performs the min operation\\n    /// @dev Pure in this function is marked as a hack/workaround - note that this function is NOT pure as fetches of ciphertexts require state access\\n    /// @param lhs input of type euint32\\n    /// @return the result of the min\\n    function min(euint32 lhs, euint32 rhs) internal pure returns (euint32) {\\n        return FHE.min(lhs, rhs);\\n    }\\n    \\n    /// @notice Performs the shl operation\\n    /// @dev Pure in this function is marked as a hack/workaround - note that this function is NOT pure as fetches of ciphertexts require state access\\n    /// @param lhs input of type euint32\\n    /// @return the result of the shl\\n    function shl(euint32 lhs, euint32 rhs) internal pure returns (euint32) {\\n        return FHE.shl(lhs, rhs);\\n    }\\n    \\n    /// @notice Performs the shr operation\\n    /// @dev Pure in this function is marked as a hack/workaround - note that this function is NOT pure as fetches of ciphertexts require state access\\n    /// @param lhs input of type euint32\\n    /// @return the result of the shr\\n    function shr(euint32 lhs, euint32 rhs) internal pure returns (euint32) {\\n        return FHE.shr(lhs, rhs);\\n    }\\n    function toBool(euint32 value) internal pure returns (ebool) {\\n        return FHE.asEbool(value);\\n    }\\n    function toU8(euint32 value) internal pure returns (euint8) {\\n        return FHE.asEuint8(value);\\n    }\\n    function toU16(euint32 value) internal pure returns (euint16) {\\n        return FHE.asEuint16(value);\\n    }\\n    function toU64(euint32 value) internal pure returns (euint64) {\\n        return FHE.asEuint64(value);\\n    }\\n    function toU128(euint32 value) internal pure returns (euint128) {\\n        return FHE.asEuint128(value);\\n    }\\n    function toU256(euint32 value) internal pure returns (euint256) {\\n        return FHE.asEuint256(value);\\n    }\\n    function toEaddress(euint32 value) internal pure returns (eaddress) {\\n        return FHE.asEaddress(value);\\n    }\\n    function seal(euint32 value, bytes32 publicKey) internal pure returns (string memory) {\\n        return FHE.sealoutput(value, publicKey);\\n    }\\n    function decrypt(euint32 value) internal pure returns (uint32) {\\n        return FHE.decrypt(value);\\n    }\\n}\\n\\nusing BindingsEuint64 for euint64 global;\\nlibrary BindingsEuint64 {\\n    \\n    /// @notice Performs the add operation\\n    /// @dev Pure in this function is marked as a hack/workaround - note that this function is NOT pure as fetches of ciphertexts require state access\\n    /// @param lhs input of type euint64\\n    /// @return the result of the add\\n    function add(euint64 lhs, euint64 rhs) internal pure returns (euint64) {\\n        return FHE.add(lhs, rhs);\\n    }\\n    \\n    /// @notice Performs the mul operation\\n    /// @dev Pure in this function is marked as a hack/workaround - note that this function is NOT pure as fetches of ciphertexts require state access\\n    /// @param lhs input of type euint64\\n    /// @return the result of the mul\\n    function mul(euint64 lhs, euint64 rhs) internal pure returns (euint64) {\\n        return FHE.mul(lhs, rhs);\\n    }\\n    \\n    /// @notice Performs the sub operation\\n    /// @dev Pure in this function is marked as a hack/workaround - note that this function is NOT pure as fetches of ciphertexts require state access\\n    /// @param lhs input of type euint64\\n    /// @return the result of the sub\\n    function sub(euint64 lhs, euint64 rhs) internal pure returns (euint64) {\\n        return FHE.sub(lhs, rhs);\\n    }\\n    \\n    /// @notice Performs the eq operation\\n    /// @dev Pure in this function is marked as a hack/workaround - note that this function is NOT pure as fetches of ciphertexts require state access\\n    /// @param lhs input of type euint64\\n    /// @return the result of the eq\\n    function eq(euint64 lhs, euint64 rhs) internal pure returns (ebool) {\\n        return FHE.eq(lhs, rhs);\\n    }\\n    \\n    /// @notice Performs the ne operation\\n    /// @dev Pure in this function is marked as a hack/workaround - note that this function is NOT pure as fetches of ciphertexts require state access\\n    /// @param lhs input of type euint64\\n    /// @return the result of the ne\\n    function ne(euint64 lhs, euint64 rhs) internal pure returns (ebool) {\\n        return FHE.ne(lhs, rhs);\\n    }\\n    \\n    /// @notice Performs the and operation\\n    /// @dev Pure in this function is marked as a hack/workaround - note that this function is NOT pure as fetches of ciphertexts require state access\\n    /// @param lhs input of type euint64\\n    /// @return the result of the and\\n    function and(euint64 lhs, euint64 rhs) internal pure returns (euint64) {\\n        return FHE.and(lhs, rhs);\\n    }\\n    \\n    /// @notice Performs the or operation\\n    /// @dev Pure in this function is marked as a hack/workaround - note that this function is NOT pure as fetches of ciphertexts require state access\\n    /// @param lhs input of type euint64\\n    /// @return the result of the or\\n    function or(euint64 lhs, euint64 rhs) internal pure returns (euint64) {\\n        return FHE.or(lhs, rhs);\\n    }\\n    \\n    /// @notice Performs the xor operation\\n    /// @dev Pure in this function is marked as a hack/workaround - note that this function is NOT pure as fetches of ciphertexts require state access\\n    /// @param lhs input of type euint64\\n    /// @return the result of the xor\\n    function xor(euint64 lhs, euint64 rhs) internal pure returns (euint64) {\\n        return FHE.xor(lhs, rhs);\\n    }\\n    \\n    /// @notice Performs the gt operation\\n    /// @dev Pure in this function is marked as a hack/workaround - note that this function is NOT pure as fetches of ciphertexts require state access\\n    /// @param lhs input of type euint64\\n    /// @return the result of the gt\\n    function gt(euint64 lhs, euint64 rhs) internal pure returns (ebool) {\\n        return FHE.gt(lhs, rhs);\\n    }\\n    \\n    /// @notice Performs the gte operation\\n    /// @dev Pure in this function is marked as a hack/workaround - note that this function is NOT pure as fetches of ciphertexts require state access\\n    /// @param lhs input of type euint64\\n    /// @return the result of the gte\\n    function gte(euint64 lhs, euint64 rhs) internal pure returns (ebool) {\\n        return FHE.gte(lhs, rhs);\\n    }\\n    \\n    /// @notice Performs the lt operation\\n    /// @dev Pure in this function is marked as a hack/workaround - note that this function is NOT pure as fetches of ciphertexts require state access\\n    /// @param lhs input of type euint64\\n    /// @return the result of the lt\\n    function lt(euint64 lhs, euint64 rhs) internal pure returns (ebool) {\\n        return FHE.lt(lhs, rhs);\\n    }\\n    \\n    /// @notice Performs the lte operation\\n    /// @dev Pure in this function is marked as a hack/workaround - note that this function is NOT pure as fetches of ciphertexts require state access\\n    /// @param lhs input of type euint64\\n    /// @return the result of the lte\\n    function lte(euint64 lhs, euint64 rhs) internal pure returns (ebool) {\\n        return FHE.lte(lhs, rhs);\\n    }\\n    \\n    /// @notice Performs the max operation\\n    /// @dev Pure in this function is marked as a hack/workaround - note that this function is NOT pure as fetches of ciphertexts require state access\\n    /// @param lhs input of type euint64\\n    /// @return the result of the max\\n    function max(euint64 lhs, euint64 rhs) internal pure returns (euint64) {\\n        return FHE.max(lhs, rhs);\\n    }\\n    \\n    /// @notice Performs the min operation\\n    /// @dev Pure in this function is marked as a hack/workaround - note that this function is NOT pure as fetches of ciphertexts require state access\\n    /// @param lhs input of type euint64\\n    /// @return the result of the min\\n    function min(euint64 lhs, euint64 rhs) internal pure returns (euint64) {\\n        return FHE.min(lhs, rhs);\\n    }\\n    \\n    /// @notice Performs the shl operation\\n    /// @dev Pure in this function is marked as a hack/workaround - note that this function is NOT pure as fetches of ciphertexts require state access\\n    /// @param lhs input of type euint64\\n    /// @return the result of the shl\\n    function shl(euint64 lhs, euint64 rhs) internal pure returns (euint64) {\\n        return FHE.shl(lhs, rhs);\\n    }\\n    \\n    /// @notice Performs the shr operation\\n    /// @dev Pure in this function is marked as a hack/workaround - note that this function is NOT pure as fetches of ciphertexts require state access\\n    /// @param lhs input of type euint64\\n    /// @return the result of the shr\\n    function shr(euint64 lhs, euint64 rhs) internal pure returns (euint64) {\\n        return FHE.shr(lhs, rhs);\\n    }\\n    function toBool(euint64 value) internal pure returns (ebool) {\\n        return FHE.asEbool(value);\\n    }\\n    function toU8(euint64 value) internal pure returns (euint8) {\\n        return FHE.asEuint8(value);\\n    }\\n    function toU16(euint64 value) internal pure returns (euint16) {\\n        return FHE.asEuint16(value);\\n    }\\n    function toU32(euint64 value) internal pure returns (euint32) {\\n        return FHE.asEuint32(value);\\n    }\\n    function toU128(euint64 value) internal pure returns (euint128) {\\n        return FHE.asEuint128(value);\\n    }\\n    function toU256(euint64 value) internal pure returns (euint256) {\\n        return FHE.asEuint256(value);\\n    }\\n    function toEaddress(euint64 value) internal pure returns (eaddress) {\\n        return FHE.asEaddress(value);\\n    }\\n    function seal(euint64 value, bytes32 publicKey) internal pure returns (string memory) {\\n        return FHE.sealoutput(value, publicKey);\\n    }\\n    function decrypt(euint64 value) internal pure returns (uint64) {\\n        return FHE.decrypt(value);\\n    }\\n}\\n\\nusing BindingsEuint128 for euint128 global;\\nlibrary BindingsEuint128 {\\n    \\n    /// @notice Performs the add operation\\n    /// @dev Pure in this function is marked as a hack/workaround - note that this function is NOT pure as fetches of ciphertexts require state access\\n    /// @param lhs input of type euint128\\n    /// @return the result of the add\\n    function add(euint128 lhs, euint128 rhs) internal pure returns (euint128) {\\n        return FHE.add(lhs, rhs);\\n    }\\n    \\n    /// @notice Performs the sub operation\\n    /// @dev Pure in this function is marked as a hack/workaround - note that this function is NOT pure as fetches of ciphertexts require state access\\n    /// @param lhs input of type euint128\\n    /// @return the result of the sub\\n    function sub(euint128 lhs, euint128 rhs) internal pure returns (euint128) {\\n        return FHE.sub(lhs, rhs);\\n    }\\n    \\n    /// @notice Performs the eq operation\\n    /// @dev Pure in this function is marked as a hack/workaround - note that this function is NOT pure as fetches of ciphertexts require state access\\n    /// @param lhs input of type euint128\\n    /// @return the result of the eq\\n    function eq(euint128 lhs, euint128 rhs) internal pure returns (ebool) {\\n        return FHE.eq(lhs, rhs);\\n    }\\n    \\n    /// @notice Performs the ne operation\\n    /// @dev Pure in this function is marked as a hack/workaround - note that this function is NOT pure as fetches of ciphertexts require state access\\n    /// @param lhs input of type euint128\\n    /// @return the result of the ne\\n    function ne(euint128 lhs, euint128 rhs) internal pure returns (ebool) {\\n        return FHE.ne(lhs, rhs);\\n    }\\n    \\n    /// @notice Performs the and operation\\n    /// @dev Pure in this function is marked as a hack/workaround - note that this function is NOT pure as fetches of ciphertexts require state access\\n    /// @param lhs input of type euint128\\n    /// @return the result of the and\\n    function and(euint128 lhs, euint128 rhs) internal pure returns (euint128) {\\n        return FHE.and(lhs, rhs);\\n    }\\n    \\n    /// @notice Performs the or operation\\n    /// @dev Pure in this function is marked as a hack/workaround - note that this function is NOT pure as fetches of ciphertexts require state access\\n    /// @param lhs input of type euint128\\n    /// @return the result of the or\\n    function or(euint128 lhs, euint128 rhs) internal pure returns (euint128) {\\n        return FHE.or(lhs, rhs);\\n    }\\n    \\n    /// @notice Performs the xor operation\\n    /// @dev Pure in this function is marked as a hack/workaround - note that this function is NOT pure as fetches of ciphertexts require state access\\n    /// @param lhs input of type euint128\\n    /// @return the result of the xor\\n    function xor(euint128 lhs, euint128 rhs) internal pure returns (euint128) {\\n        return FHE.xor(lhs, rhs);\\n    }\\n    \\n    /// @notice Performs the gt operation\\n    /// @dev Pure in this function is marked as a hack/workaround - note that this function is NOT pure as fetches of ciphertexts require state access\\n    /// @param lhs input of type euint128\\n    /// @return the result of the gt\\n    function gt(euint128 lhs, euint128 rhs) internal pure returns (ebool) {\\n        return FHE.gt(lhs, rhs);\\n    }\\n    \\n    /// @notice Performs the gte operation\\n    /// @dev Pure in this function is marked as a hack/workaround - note that this function is NOT pure as fetches of ciphertexts require state access\\n    /// @param lhs input of type euint128\\n    /// @return the result of the gte\\n    function gte(euint128 lhs, euint128 rhs) internal pure returns (ebool) {\\n        return FHE.gte(lhs, rhs);\\n    }\\n    \\n    /// @notice Performs the lt operation\\n    /// @dev Pure in this function is marked as a hack/workaround - note that this function is NOT pure as fetches of ciphertexts require state access\\n    /// @param lhs input of type euint128\\n    /// @return the result of the lt\\n    function lt(euint128 lhs, euint128 rhs) internal pure returns (ebool) {\\n        return FHE.lt(lhs, rhs);\\n    }\\n    \\n    /// @notice Performs the lte operation\\n    /// @dev Pure in this function is marked as a hack/workaround - note that this function is NOT pure as fetches of ciphertexts require state access\\n    /// @param lhs input of type euint128\\n    /// @return the result of the lte\\n    function lte(euint128 lhs, euint128 rhs) internal pure returns (ebool) {\\n        return FHE.lte(lhs, rhs);\\n    }\\n    \\n    /// @notice Performs the max operation\\n    /// @dev Pure in this function is marked as a hack/workaround - note that this function is NOT pure as fetches of ciphertexts require state access\\n    /// @param lhs input of type euint128\\n    /// @return the result of the max\\n    function max(euint128 lhs, euint128 rhs) internal pure returns (euint128) {\\n        return FHE.max(lhs, rhs);\\n    }\\n    \\n    /// @notice Performs the min operation\\n    /// @dev Pure in this function is marked as a hack/workaround - note that this function is NOT pure as fetches of ciphertexts require state access\\n    /// @param lhs input of type euint128\\n    /// @return the result of the min\\n    function min(euint128 lhs, euint128 rhs) internal pure returns (euint128) {\\n        return FHE.min(lhs, rhs);\\n    }\\n    \\n    /// @notice Performs the shl operation\\n    /// @dev Pure in this function is marked as a hack/workaround - note that this function is NOT pure as fetches of ciphertexts require state access\\n    /// @param lhs input of type euint128\\n    /// @return the result of the shl\\n    function shl(euint128 lhs, euint128 rhs) internal pure returns (euint128) {\\n        return FHE.shl(lhs, rhs);\\n    }\\n    \\n    /// @notice Performs the shr operation\\n    /// @dev Pure in this function is marked as a hack/workaround - note that this function is NOT pure as fetches of ciphertexts require state access\\n    /// @param lhs input of type euint128\\n    /// @return the result of the shr\\n    function shr(euint128 lhs, euint128 rhs) internal pure returns (euint128) {\\n        return FHE.shr(lhs, rhs);\\n    }\\n    function toBool(euint128 value) internal pure returns (ebool) {\\n        return FHE.asEbool(value);\\n    }\\n    function toU8(euint128 value) internal pure returns (euint8) {\\n        return FHE.asEuint8(value);\\n    }\\n    function toU16(euint128 value) internal pure returns (euint16) {\\n        return FHE.asEuint16(value);\\n    }\\n    function toU32(euint128 value) internal pure returns (euint32) {\\n        return FHE.asEuint32(value);\\n    }\\n    function toU64(euint128 value) internal pure returns (euint64) {\\n        return FHE.asEuint64(value);\\n    }\\n    function toU256(euint128 value) internal pure returns (euint256) {\\n        return FHE.asEuint256(value);\\n    }\\n    function toEaddress(euint128 value) internal pure returns (eaddress) {\\n        return FHE.asEaddress(value);\\n    }\\n    function seal(euint128 value, bytes32 publicKey) internal pure returns (string memory) {\\n        return FHE.sealoutput(value, publicKey);\\n    }\\n    function decrypt(euint128 value) internal pure returns (uint128) {\\n        return FHE.decrypt(value);\\n    }\\n}\\n\\nusing BindingsEuint256 for euint256 global;\\nlibrary BindingsEuint256 {\\n    \\n    /// @notice Performs the eq operation\\n    /// @dev Pure in this function is marked as a hack/workaround - note that this function is NOT pure as fetches of ciphertexts require state access\\n    /// @param lhs input of type euint256\\n    /// @return the result of the eq\\n    function eq(euint256 lhs, euint256 rhs) internal pure returns (ebool) {\\n        return FHE.eq(lhs, rhs);\\n    }\\n    \\n    /// @notice Performs the ne operation\\n    /// @dev Pure in this function is marked as a hack/workaround - note that this function is NOT pure as fetches of ciphertexts require state access\\n    /// @param lhs input of type euint256\\n    /// @return the result of the ne\\n    function ne(euint256 lhs, euint256 rhs) internal pure returns (ebool) {\\n        return FHE.ne(lhs, rhs);\\n    }\\n    function toBool(euint256 value) internal pure returns (ebool) {\\n        return FHE.asEbool(value);\\n    }\\n    function toU8(euint256 value) internal pure returns (euint8) {\\n        return FHE.asEuint8(value);\\n    }\\n    function toU16(euint256 value) internal pure returns (euint16) {\\n        return FHE.asEuint16(value);\\n    }\\n    function toU32(euint256 value) internal pure returns (euint32) {\\n        return FHE.asEuint32(value);\\n    }\\n    function toU64(euint256 value) internal pure returns (euint64) {\\n        return FHE.asEuint64(value);\\n    }\\n    function toU128(euint256 value) internal pure returns (euint128) {\\n        return FHE.asEuint128(value);\\n    }\\n    function toEaddress(euint256 value) internal pure returns (eaddress) {\\n        return FHE.asEaddress(value);\\n    }\\n    function seal(euint256 value, bytes32 publicKey) internal pure returns (string memory) {\\n        return FHE.sealoutput(value, publicKey);\\n    }\\n    function decrypt(euint256 value) internal pure returns (uint256) {\\n        return FHE.decrypt(value);\\n    }\\n}\\n\\nusing BindingsEaddress for eaddress global;\\nlibrary BindingsEaddress {\\n    \\n    /// @notice Performs the eq operation\\n    /// @dev Pure in this function is marked as a hack/workaround - note that this function is NOT pure as fetches of ciphertexts require state access\\n    /// @param lhs input of type eaddress\\n    /// @return the result of the eq\\n    function eq(eaddress lhs, eaddress rhs) internal pure returns (ebool) {\\n        return FHE.eq(lhs, rhs);\\n    }\\n    \\n    /// @notice Performs the ne operation\\n    /// @dev Pure in this function is marked as a hack/workaround - note that this function is NOT pure as fetches of ciphertexts require state access\\n    /// @param lhs input of type eaddress\\n    /// @return the result of the ne\\n    function ne(eaddress lhs, eaddress rhs) internal pure returns (ebool) {\\n        return FHE.ne(lhs, rhs);\\n    }\\n    function toBool(eaddress value) internal pure returns (ebool) {\\n        return FHE.asEbool(value);\\n    }\\n    function toU8(eaddress value) internal pure returns (euint8) {\\n        return FHE.asEuint8(value);\\n    }\\n    function toU16(eaddress value) internal pure returns (euint16) {\\n        return FHE.asEuint16(value);\\n    }\\n    function toU32(eaddress value) internal pure returns (euint32) {\\n        return FHE.asEuint32(value);\\n    }\\n    function toU64(eaddress value) internal pure returns (euint64) {\\n        return FHE.asEuint64(value);\\n    }\\n    function toU128(eaddress value) internal pure returns (euint128) {\\n        return FHE.asEuint128(value);\\n    }\\n    function toU256(eaddress value) internal pure returns (euint256) {\\n        return FHE.asEuint256(value);\\n    }\\n    function seal(eaddress value, bytes32 publicKey) internal pure returns (string memory) {\\n        return FHE.sealoutput(value, publicKey);\\n    }\\n    function decrypt(eaddress value) internal pure returns (address) {\\n        return FHE.decrypt(value);\\n    }\\n}\",\"keccak256\":\"0x1ffd2f9f5c64d58f600d54eba6c74d5c158455dd3e1eb827f1e745b1c81218a3\",\"license\":\"BSD-3-Clause-Clear\"},\"@fhenixprotocol/contracts/FheOS.sol\":{\"content\":\"// SPDX-License-Identifier: BSD-3-Clause-Clear\\n// solhint-disable one-contract-per-file\\npragma solidity >=0.8.13 <0.9.0;\\n\\nlibrary Precompiles {\\n    //solhint-disable const-name-snakecase\\n    address public constant Fheos = address(128);\\n}\\n\\ninterface FheOps {\\n    function log(string memory s) external pure;\\n    function add(uint8 utype, bytes memory lhsHash, bytes memory rhsHash) external pure returns (bytes memory);\\n    function verify(uint8 utype, bytes memory input) external pure returns (bytes memory);\\n    function sealOutput(uint8 utype, bytes memory ctHash, bytes memory pk) external pure returns (string memory);\\n    function decrypt(uint8 utype, bytes memory input) external pure returns (uint256);\\n    function lte(uint8 utype, bytes memory lhsHash, bytes memory rhsHash) external pure returns (bytes memory);\\n    function sub(uint8 utype, bytes memory lhsHash, bytes memory rhsHash) external pure returns (bytes memory);\\n    function mul(uint8 utype, bytes memory lhsHash, bytes memory rhsHash) external pure returns (bytes memory);\\n    function lt(uint8 utype, bytes memory lhsHash, bytes memory rhsHash) external pure returns (bytes memory);\\n    function select(uint8 utype, bytes memory controlHash, bytes memory ifTrueHash, bytes memory ifFalseHash) external pure returns (bytes memory);\\n    function req(uint8 utype, bytes memory input) external pure returns (bytes memory);\\n    function cast(uint8 utype, bytes memory input, uint8 toType) external pure returns (bytes memory);\\n    function trivialEncrypt(bytes memory input, uint8 toType) external pure returns (bytes memory);\\n    function div(uint8 utype, bytes memory lhsHash, bytes memory rhsHash) external pure returns (bytes memory);\\n    function gt(uint8 utype, bytes memory lhsHash, bytes memory rhsHash) external pure returns (bytes memory);\\n    function gte(uint8 utype, bytes memory lhsHash, bytes memory rhsHash) external pure returns (bytes memory);\\n    function rem(uint8 utype, bytes memory lhsHash, bytes memory rhsHash) external pure returns (bytes memory);\\n    function and(uint8 utype, bytes memory lhsHash, bytes memory rhsHash) external pure returns (bytes memory);\\n    function or(uint8 utype, bytes memory lhsHash, bytes memory rhsHash) external pure returns (bytes memory);\\n    function xor(uint8 utype, bytes memory lhsHash, bytes memory rhsHash) external pure returns (bytes memory);\\n    function eq(uint8 utype, bytes memory lhsHash, bytes memory rhsHash) external pure returns (bytes memory);\\n    function ne(uint8 utype, bytes memory lhsHash, bytes memory rhsHash) external pure returns (bytes memory);\\n    function min(uint8 utype, bytes memory lhsHash, bytes memory rhsHash) external pure returns (bytes memory);\\n    function max(uint8 utype, bytes memory lhsHash, bytes memory rhsHash) external pure returns (bytes memory);\\n    function shl(uint8 utype, bytes memory lhsHash, bytes memory rhsHash) external pure returns (bytes memory);\\n    function shr(uint8 utype, bytes memory lhsHash, bytes memory rhsHash) external pure returns (bytes memory);\\n    function not(uint8 utype, bytes memory value) external pure returns (bytes memory);\\n    function getNetworkPublicKey() external pure returns (bytes memory);\\n}\",\"keccak256\":\"0xc704013bec920b763d309d02f6c459acb16326b056bea878ee2130792be2fdac\",\"license\":\"BSD-3-Clause-Clear\"},\"@fhenixprotocol/contracts/access/Permissioned.sol\":{\"content\":\"// SPDX-License-Identifier: BSD-3-Clause-Clear\\npragma solidity >=0.8.19 <0.9.0;\\n\\nimport { ECDSA } from \\\"@openzeppelin/contracts/utils/cryptography/ECDSA.sol\\\";\\nimport { EIP712 } from \\\"@openzeppelin/contracts/utils/cryptography/EIP712.sol\\\";\\n\\n/// @title Permissioned Access Control Contract\\n/// @notice Abstract contract that provides EIP-712 based signature verification for access control\\n/// @dev This contract should be inherited by other contracts to provide EIP-712 signature validated access control\\nabstract contract Permissioned is EIP712 {\\n    /// @notice Emitted when the signer is not the message sender\\n    error SignerNotMessageSender();\\n\\n    /// @notice Emitted when the signer is not the specified owner\\n    error SignerNotOwner();\\n\\n    /// @dev Constructor that initializes EIP712 domain separator with a name and version\\n    /// solhint-disable-next-line func-visibility, no-empty-blocks\\n    constructor() EIP712(\\\"Fhenix Permission\\\", \\\"1.0\\\") {} \\n\\n    /// @notice Modifier that requires the provided signature to be signed by the message sender\\n    /// @param permission Data structure containing the public key and the signature to be verified\\n    modifier onlySender(Permission memory permission) {\\n        bytes32 digest = _hashTypedDataV4(keccak256(abi.encode(\\n            keccak256(\\\"Permissioned(bytes32 publicKey)\\\"),\\n            permission.publicKey\\n        )));\\n        address signer = ECDSA.recover(digest, permission.signature);\\n        if (signer != msg.sender)\\n            revert SignerNotMessageSender();\\n        _;\\n    }\\n\\n    /// @notice Modifier that requires the provided signature to be signed by a specific owner address\\n    /// @param permission Data structure containing the public key and the signature to be verified\\n    /// @param owner The expected owner of the public key to match against the recovered signer\\n    modifier onlyPermitted(Permission memory permission, address owner) {\\n        bytes32 digest = _hashTypedDataV4(keccak256(abi.encode(\\n            keccak256(\\\"Permissioned(bytes32 publicKey)\\\"),\\n            permission.publicKey\\n        )));\\n        address signer = ECDSA.recover(digest, permission.signature);\\n        if (signer != owner)\\n            revert SignerNotOwner();\\n        _;\\n    }\\n}\\n\\n/// @title Struct for holding signature information\\n/// @notice Used to pass both the public key and signature data within transactions\\n/// @dev Should be used with Signature-based modifiers for access control\\nstruct Permission {\\n    bytes32 publicKey;\\n    bytes signature;\\n}\\n\",\"keccak256\":\"0xfff6f7f1a33a83c578c93464dd936e6bda2ca619cfe298a0c5d76d6bb79a25f7\",\"license\":\"BSD-3-Clause-Clear\"},\"@fhenixprotocol/contracts/utils/debug/Console.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity >=0.8.19 <0.9.0;\\n\\nimport {FheOps, Precompiles} from \\\"../../FheOS.sol\\\";\\nimport \\\"@openzeppelin/contracts/utils/Strings.sol\\\";\\n\\nlibrary Console {\\n    function _logImpl(string memory payload) internal pure {\\n        FheOps(Precompiles.Fheos).log(payload);\\n    }\\n\\n    function _logImpl2Params(string memory p0, string memory p1) internal pure {\\n        string memory payload = string(abi.encodePacked(string(\\\"p0: \\\"), p0, string(\\\" p1: \\\"), p1));\\n        _logImpl(payload);\\n    }\\n\\n    function _logImpl3Params(string memory p0, string memory p1, string memory p2) internal pure {\\n        string memory payload = string(abi.encodePacked(string(\\\"p0: \\\"), p0, string(\\\" p1: \\\"), \\n        p1, string(\\\" p2: \\\"), p2));\\n        _logImpl(payload);\\n    }\\n\\n    function _intToString(int _value) internal pure returns (string memory) {\\n        return Strings.toStringSigned(_value);\\n    }\\n\\n    function _uintToString(uint _value) internal pure returns (string memory) {\\n        return Strings.toString(_value);\\n    }\\n\\n    function _addressToString(address _addr) internal pure returns (string memory) {\\n        bytes memory alphabet = \\\"0123456789abcdef\\\";\\n        bytes20 value = bytes20(_addr);\\n        bytes memory buffer = new bytes(42); // 2 characters for '0x' and 40 characters for the address\\n        buffer[0] = \\\"0\\\";\\n        buffer[1] = \\\"x\\\";\\n        for (uint256 i = 0; i < 20; i++) {\\n            buffer[2+i*2] = alphabet[uint8(value[i] >> 4)];\\n            buffer[3+i*2] = alphabet[uint8(value[i] & 0x0f)];\\n        }\\n        return string(buffer);\\n    }\\n\\n    function _boolToString(bool val) internal pure returns (string memory) {\\n        return val ? \\\"true\\\" : \\\"false\\\";\\n    }\\n\\n    function _logInt(int256 p0) internal pure {\\n        _logImpl(_intToString(p0));\\n    }\\n\\n    function _logUint(uint256 p0) internal pure {\\n        _logImpl(_uintToString(p0));\\n    }\\n\\n    function _logBool(bool p0) internal pure {\\n        _logImpl(_boolToString(p0));\\n    }\\n\\n    function _logAddress(address p0) internal pure {\\n        _logImpl(_addressToString(p0));\\n    }\\n\\n    function logBytes(bytes memory p0) internal pure {\\n        _logImpl(string(p0));\\n    }\\n\\n    function log(int256 p0) internal pure {\\n        _logInt(p0);\\n    }\\n\\n    function log(uint256 p0) internal pure {\\n        _logUint(p0);\\n    }\\n\\n    function log(string memory p0) internal pure {\\n       _logImpl(p0);\\n    }\\n\\n    function log(bool p0) internal pure {\\n        _logBool(p0);\\n    }\\n\\n    function log(address p0) internal pure {\\n        _logAddress(p0);\\n    }\\n\\tfunction log(int256 p0, int256 p1) internal pure {\\n    \\t_logImpl2Params(_intToString(p0), _intToString(p1));\\n\\t}\\n\\n\\tfunction log(int256 p0, uint256 p1) internal pure {\\n    \\t_logImpl2Params(_intToString(p0), _uintToString(p1));\\n\\t}\\n\\n\\tfunction log(int256 p0, string memory p1) internal pure {\\n    \\t_logImpl2Params(_intToString(p0), p1);\\n\\t}\\n\\n\\tfunction log(int256 p0, bool p1) internal pure {\\n    \\t_logImpl2Params(_intToString(p0), _boolToString(p1));\\n\\t}\\n\\n\\tfunction log(int256 p0, address p1) internal pure {\\n    \\t_logImpl2Params(_intToString(p0), _addressToString(p1));\\n\\t}\\n\\n\\tfunction log(uint256 p0, int256 p1) internal pure {\\n    \\t_logImpl2Params(_uintToString(p0), _intToString(p1));\\n\\t}\\n\\n\\tfunction log(uint256 p0, uint256 p1) internal pure {\\n    \\t_logImpl2Params(_uintToString(p0), _uintToString(p1));\\n\\t}\\n\\n\\tfunction log(uint256 p0, string memory p1) internal pure {\\n    \\t_logImpl2Params(_uintToString(p0), p1);\\n\\t}\\n\\n\\tfunction log(uint256 p0, bool p1) internal pure {\\n    \\t_logImpl2Params(_uintToString(p0), _boolToString(p1));\\n\\t}\\n\\n\\tfunction log(uint256 p0, address p1) internal pure {\\n    \\t_logImpl2Params(_uintToString(p0), _addressToString(p1));\\n\\t}\\n\\n\\tfunction log(string memory p0, int256 p1) internal pure {\\n    \\t_logImpl2Params(p0, _intToString(p1));\\n\\t}\\n\\n\\tfunction log(string memory p0, uint256 p1) internal pure {\\n    \\t_logImpl2Params(p0, _uintToString(p1));\\n\\t}\\n\\n\\tfunction log(string memory p0, string memory p1) internal pure {\\n    \\t_logImpl2Params(p0, p1);\\n\\t}\\n\\n\\tfunction log(string memory p0, bool p1) internal pure {\\n    \\t_logImpl2Params(p0, _boolToString(p1));\\n\\t}\\n\\n\\tfunction log(string memory p0, address p1) internal pure {\\n    \\t_logImpl2Params(p0, _addressToString(p1));\\n\\t}\\n\\n\\tfunction log(bool p0, int256 p1) internal pure {\\n    \\t_logImpl2Params(_boolToString(p0), _intToString(p1));\\n\\t}\\n\\n\\tfunction log(bool p0, uint256 p1) internal pure {\\n    \\t_logImpl2Params(_boolToString(p0), _uintToString(p1));\\n\\t}\\n\\n\\tfunction log(bool p0, string memory p1) internal pure {\\n    \\t_logImpl2Params(_boolToString(p0), p1);\\n\\t}\\n\\n\\tfunction log(bool p0, bool p1) internal pure {\\n    \\t_logImpl2Params(_boolToString(p0), _boolToString(p1));\\n\\t}\\n\\n\\tfunction log(bool p0, address p1) internal pure {\\n    \\t_logImpl2Params(_boolToString(p0), _addressToString(p1));\\n\\t}\\n\\n\\tfunction log(address p0, int256 p1) internal pure {\\n    \\t_logImpl2Params(_addressToString(p0), _intToString(p1));\\n\\t}\\n\\n\\tfunction log(address p0, uint256 p1) internal pure {\\n    \\t_logImpl2Params(_addressToString(p0), _uintToString(p1));\\n\\t}\\n\\n\\tfunction log(address p0, string memory p1) internal pure {\\n    \\t_logImpl2Params(_addressToString(p0), p1);\\n\\t}\\n\\n\\tfunction log(address p0, bool p1) internal pure {\\n    \\t_logImpl2Params(_addressToString(p0), _boolToString(p1));\\n\\t}\\n\\n\\tfunction log(address p0, address p1) internal pure {\\n    \\t_logImpl2Params(_addressToString(p0), _addressToString(p1));\\n\\t}\\n\\n\\tfunction log(int256 p0, int256 p1, int256 p2) internal pure {\\n    \\t_logImpl3Params(_intToString(p0), _intToString(p1), _intToString(p2));\\n\\t}\\n\\n\\tfunction log(int256 p0, int256 p1, uint256 p2) internal pure {\\n    \\t_logImpl3Params(_intToString(p0), _intToString(p1), _uintToString(p2));\\n\\t}\\n\\n\\tfunction log(int256 p0, int256 p1, string memory p2) internal pure {\\n    \\t_logImpl3Params(_intToString(p0), _intToString(p1), p2);\\n\\t}\\n\\n\\tfunction log(int256 p0, int256 p1, bool p2) internal pure {\\n    \\t_logImpl3Params(_intToString(p0), _intToString(p1), _boolToString(p2));\\n\\t}\\n\\n\\tfunction log(int256 p0, int256 p1, address p2) internal pure {\\n    \\t_logImpl3Params(_intToString(p0), _intToString(p1), _addressToString(p2));\\n\\t}\\n\\n\\tfunction log(int256 p0, uint256 p1, int256 p2) internal pure {\\n    \\t_logImpl3Params(_intToString(p0), _uintToString(p1), _intToString(p2));\\n\\t}\\n\\n\\tfunction log(int256 p0, uint256 p1, uint256 p2) internal pure {\\n    \\t_logImpl3Params(_intToString(p0), _uintToString(p1), _uintToString(p2));\\n\\t}\\n\\n\\tfunction log(int256 p0, uint256 p1, string memory p2) internal pure {\\n    \\t_logImpl3Params(_intToString(p0), _uintToString(p1), p2);\\n\\t}\\n\\n\\tfunction log(int256 p0, uint256 p1, bool p2) internal pure {\\n    \\t_logImpl3Params(_intToString(p0), _uintToString(p1), _boolToString(p2));\\n\\t}\\n\\n\\tfunction log(int256 p0, uint256 p1, address p2) internal pure {\\n    \\t_logImpl3Params(_intToString(p0), _uintToString(p1), _addressToString(p2));\\n\\t}\\n\\n\\tfunction log(int256 p0, string memory p1, int256 p2) internal pure {\\n    \\t_logImpl3Params(_intToString(p0), p1, _intToString(p2));\\n\\t}\\n\\n\\tfunction log(int256 p0, string memory p1, uint256 p2) internal pure {\\n    \\t_logImpl3Params(_intToString(p0), p1, _uintToString(p2));\\n\\t}\\n\\n\\tfunction log(int256 p0, string memory p1, string memory p2) internal pure {\\n    \\t_logImpl3Params(_intToString(p0), p1, p2);\\n\\t}\\n\\n\\tfunction log(int256 p0, string memory p1, bool p2) internal pure {\\n    \\t_logImpl3Params(_intToString(p0), p1, _boolToString(p2));\\n\\t}\\n\\n\\tfunction log(int256 p0, string memory p1, address p2) internal pure {\\n    \\t_logImpl3Params(_intToString(p0), p1, _addressToString(p2));\\n\\t}\\n\\n\\tfunction log(int256 p0, bool p1, int256 p2) internal pure {\\n    \\t_logImpl3Params(_intToString(p0), _boolToString(p1), _intToString(p2));\\n\\t}\\n\\n\\tfunction log(int256 p0, bool p1, uint256 p2) internal pure {\\n    \\t_logImpl3Params(_intToString(p0), _boolToString(p1), _uintToString(p2));\\n\\t}\\n\\n\\tfunction log(int256 p0, bool p1, string memory p2) internal pure {\\n    \\t_logImpl3Params(_intToString(p0), _boolToString(p1), p2);\\n\\t}\\n\\n\\tfunction log(int256 p0, bool p1, bool p2) internal pure {\\n    \\t_logImpl3Params(_intToString(p0), _boolToString(p1), _boolToString(p2));\\n\\t}\\n\\n\\tfunction log(int256 p0, bool p1, address p2) internal pure {\\n    \\t_logImpl3Params(_intToString(p0), _boolToString(p1), _addressToString(p2));\\n\\t}\\n\\n\\tfunction log(int256 p0, address p1, int256 p2) internal pure {\\n    \\t_logImpl3Params(_intToString(p0), _addressToString(p1), _intToString(p2));\\n\\t}\\n\\n\\tfunction log(int256 p0, address p1, uint256 p2) internal pure {\\n    \\t_logImpl3Params(_intToString(p0), _addressToString(p1), _uintToString(p2));\\n\\t}\\n\\n\\tfunction log(int256 p0, address p1, string memory p2) internal pure {\\n    \\t_logImpl3Params(_intToString(p0), _addressToString(p1), p2);\\n\\t}\\n\\n\\tfunction log(int256 p0, address p1, bool p2) internal pure {\\n    \\t_logImpl3Params(_intToString(p0), _addressToString(p1), _boolToString(p2));\\n\\t}\\n\\n\\tfunction log(int256 p0, address p1, address p2) internal pure {\\n    \\t_logImpl3Params(_intToString(p0), _addressToString(p1), _addressToString(p2));\\n\\t}\\n\\n\\tfunction log(uint256 p0, int256 p1, int256 p2) internal pure {\\n    \\t_logImpl3Params(_uintToString(p0), _intToString(p1), _intToString(p2));\\n\\t}\\n\\n\\tfunction log(uint256 p0, int256 p1, uint256 p2) internal pure {\\n    \\t_logImpl3Params(_uintToString(p0), _intToString(p1), _uintToString(p2));\\n\\t}\\n\\n\\tfunction log(uint256 p0, int256 p1, string memory p2) internal pure {\\n    \\t_logImpl3Params(_uintToString(p0), _intToString(p1), p2);\\n\\t}\\n\\n\\tfunction log(uint256 p0, int256 p1, bool p2) internal pure {\\n    \\t_logImpl3Params(_uintToString(p0), _intToString(p1), _boolToString(p2));\\n\\t}\\n\\n\\tfunction log(uint256 p0, int256 p1, address p2) internal pure {\\n    \\t_logImpl3Params(_uintToString(p0), _intToString(p1), _addressToString(p2));\\n\\t}\\n\\n\\tfunction log(uint256 p0, uint256 p1, int256 p2) internal pure {\\n    \\t_logImpl3Params(_uintToString(p0), _uintToString(p1), _intToString(p2));\\n\\t}\\n\\n\\tfunction log(uint256 p0, uint256 p1, uint256 p2) internal pure {\\n    \\t_logImpl3Params(_uintToString(p0), _uintToString(p1), _uintToString(p2));\\n\\t}\\n\\n\\tfunction log(uint256 p0, uint256 p1, string memory p2) internal pure {\\n    \\t_logImpl3Params(_uintToString(p0), _uintToString(p1), p2);\\n\\t}\\n\\n\\tfunction log(uint256 p0, uint256 p1, bool p2) internal pure {\\n    \\t_logImpl3Params(_uintToString(p0), _uintToString(p1), _boolToString(p2));\\n\\t}\\n\\n\\tfunction log(uint256 p0, uint256 p1, address p2) internal pure {\\n    \\t_logImpl3Params(_uintToString(p0), _uintToString(p1), _addressToString(p2));\\n\\t}\\n\\n\\tfunction log(uint256 p0, string memory p1, int256 p2) internal pure {\\n    \\t_logImpl3Params(_uintToString(p0), p1, _intToString(p2));\\n\\t}\\n\\n\\tfunction log(uint256 p0, string memory p1, uint256 p2) internal pure {\\n    \\t_logImpl3Params(_uintToString(p0), p1, _uintToString(p2));\\n\\t}\\n\\n\\tfunction log(uint256 p0, string memory p1, string memory p2) internal pure {\\n    \\t_logImpl3Params(_uintToString(p0), p1, p2);\\n\\t}\\n\\n\\tfunction log(uint256 p0, string memory p1, bool p2) internal pure {\\n    \\t_logImpl3Params(_uintToString(p0), p1, _boolToString(p2));\\n\\t}\\n\\n\\tfunction log(uint256 p0, string memory p1, address p2) internal pure {\\n    \\t_logImpl3Params(_uintToString(p0), p1, _addressToString(p2));\\n\\t}\\n\\n\\tfunction log(uint256 p0, bool p1, int256 p2) internal pure {\\n    \\t_logImpl3Params(_uintToString(p0), _boolToString(p1), _intToString(p2));\\n\\t}\\n\\n\\tfunction log(uint256 p0, bool p1, uint256 p2) internal pure {\\n    \\t_logImpl3Params(_uintToString(p0), _boolToString(p1), _uintToString(p2));\\n\\t}\\n\\n\\tfunction log(uint256 p0, bool p1, string memory p2) internal pure {\\n    \\t_logImpl3Params(_uintToString(p0), _boolToString(p1), p2);\\n\\t}\\n\\n\\tfunction log(uint256 p0, bool p1, bool p2) internal pure {\\n    \\t_logImpl3Params(_uintToString(p0), _boolToString(p1), _boolToString(p2));\\n\\t}\\n\\n\\tfunction log(uint256 p0, bool p1, address p2) internal pure {\\n    \\t_logImpl3Params(_uintToString(p0), _boolToString(p1), _addressToString(p2));\\n\\t}\\n\\n\\tfunction log(uint256 p0, address p1, int256 p2) internal pure {\\n    \\t_logImpl3Params(_uintToString(p0), _addressToString(p1), _intToString(p2));\\n\\t}\\n\\n\\tfunction log(uint256 p0, address p1, uint256 p2) internal pure {\\n    \\t_logImpl3Params(_uintToString(p0), _addressToString(p1), _uintToString(p2));\\n\\t}\\n\\n\\tfunction log(uint256 p0, address p1, string memory p2) internal pure {\\n    \\t_logImpl3Params(_uintToString(p0), _addressToString(p1), p2);\\n\\t}\\n\\n\\tfunction log(uint256 p0, address p1, bool p2) internal pure {\\n    \\t_logImpl3Params(_uintToString(p0), _addressToString(p1), _boolToString(p2));\\n\\t}\\n\\n\\tfunction log(uint256 p0, address p1, address p2) internal pure {\\n    \\t_logImpl3Params(_uintToString(p0), _addressToString(p1), _addressToString(p2));\\n\\t}\\n\\n\\tfunction log(string memory p0, int256 p1, int256 p2) internal pure {\\n    \\t_logImpl3Params(p0, _intToString(p1), _intToString(p2));\\n\\t}\\n\\n\\tfunction log(string memory p0, int256 p1, uint256 p2) internal pure {\\n    \\t_logImpl3Params(p0, _intToString(p1), _uintToString(p2));\\n\\t}\\n\\n\\tfunction log(string memory p0, int256 p1, string memory p2) internal pure {\\n    \\t_logImpl3Params(p0, _intToString(p1), p2);\\n\\t}\\n\\n\\tfunction log(string memory p0, int256 p1, bool p2) internal pure {\\n    \\t_logImpl3Params(p0, _intToString(p1), _boolToString(p2));\\n\\t}\\n\\n\\tfunction log(string memory p0, int256 p1, address p2) internal pure {\\n    \\t_logImpl3Params(p0, _intToString(p1), _addressToString(p2));\\n\\t}\\n\\n\\tfunction log(string memory p0, uint256 p1, int256 p2) internal pure {\\n    \\t_logImpl3Params(p0, _uintToString(p1), _intToString(p2));\\n\\t}\\n\\n\\tfunction log(string memory p0, uint256 p1, uint256 p2) internal pure {\\n    \\t_logImpl3Params(p0, _uintToString(p1), _uintToString(p2));\\n\\t}\\n\\n\\tfunction log(string memory p0, uint256 p1, string memory p2) internal pure {\\n    \\t_logImpl3Params(p0, _uintToString(p1), p2);\\n\\t}\\n\\n\\tfunction log(string memory p0, uint256 p1, bool p2) internal pure {\\n    \\t_logImpl3Params(p0, _uintToString(p1), _boolToString(p2));\\n\\t}\\n\\n\\tfunction log(string memory p0, uint256 p1, address p2) internal pure {\\n    \\t_logImpl3Params(p0, _uintToString(p1), _addressToString(p2));\\n\\t}\\n\\n\\tfunction log(string memory p0, string memory p1, int256 p2) internal pure {\\n    \\t_logImpl3Params(p0, p1, _intToString(p2));\\n\\t}\\n\\n\\tfunction log(string memory p0, string memory p1, uint256 p2) internal pure {\\n    \\t_logImpl3Params(p0, p1, _uintToString(p2));\\n\\t}\\n\\n\\tfunction log(string memory p0, string memory p1, string memory p2) internal pure {\\n    \\t_logImpl3Params(p0, p1, p2);\\n\\t}\\n\\n\\tfunction log(string memory p0, string memory p1, bool p2) internal pure {\\n    \\t_logImpl3Params(p0, p1, _boolToString(p2));\\n\\t}\\n\\n\\tfunction log(string memory p0, string memory p1, address p2) internal pure {\\n    \\t_logImpl3Params(p0, p1, _addressToString(p2));\\n\\t}\\n\\n\\tfunction log(string memory p0, bool p1, int256 p2) internal pure {\\n    \\t_logImpl3Params(p0, _boolToString(p1), _intToString(p2));\\n\\t}\\n\\n\\tfunction log(string memory p0, bool p1, uint256 p2) internal pure {\\n    \\t_logImpl3Params(p0, _boolToString(p1), _uintToString(p2));\\n\\t}\\n\\n\\tfunction log(string memory p0, bool p1, string memory p2) internal pure {\\n    \\t_logImpl3Params(p0, _boolToString(p1), p2);\\n\\t}\\n\\n\\tfunction log(string memory p0, bool p1, bool p2) internal pure {\\n    \\t_logImpl3Params(p0, _boolToString(p1), _boolToString(p2));\\n\\t}\\n\\n\\tfunction log(string memory p0, bool p1, address p2) internal pure {\\n    \\t_logImpl3Params(p0, _boolToString(p1), _addressToString(p2));\\n\\t}\\n\\n\\tfunction log(string memory p0, address p1, int256 p2) internal pure {\\n    \\t_logImpl3Params(p0, _addressToString(p1), _intToString(p2));\\n\\t}\\n\\n\\tfunction log(string memory p0, address p1, uint256 p2) internal pure {\\n    \\t_logImpl3Params(p0, _addressToString(p1), _uintToString(p2));\\n\\t}\\n\\n\\tfunction log(string memory p0, address p1, string memory p2) internal pure {\\n    \\t_logImpl3Params(p0, _addressToString(p1), p2);\\n\\t}\\n\\n\\tfunction log(string memory p0, address p1, bool p2) internal pure {\\n    \\t_logImpl3Params(p0, _addressToString(p1), _boolToString(p2));\\n\\t}\\n\\n\\tfunction log(string memory p0, address p1, address p2) internal pure {\\n    \\t_logImpl3Params(p0, _addressToString(p1), _addressToString(p2));\\n\\t}\\n\\n\\tfunction log(bool p0, int256 p1, int256 p2) internal pure {\\n    \\t_logImpl3Params(_boolToString(p0), _intToString(p1), _intToString(p2));\\n\\t}\\n\\n\\tfunction log(bool p0, int256 p1, uint256 p2) internal pure {\\n    \\t_logImpl3Params(_boolToString(p0), _intToString(p1), _uintToString(p2));\\n\\t}\\n\\n\\tfunction log(bool p0, int256 p1, string memory p2) internal pure {\\n    \\t_logImpl3Params(_boolToString(p0), _intToString(p1), p2);\\n\\t}\\n\\n\\tfunction log(bool p0, int256 p1, bool p2) internal pure {\\n    \\t_logImpl3Params(_boolToString(p0), _intToString(p1), _boolToString(p2));\\n\\t}\\n\\n\\tfunction log(bool p0, int256 p1, address p2) internal pure {\\n    \\t_logImpl3Params(_boolToString(p0), _intToString(p1), _addressToString(p2));\\n\\t}\\n\\n\\tfunction log(bool p0, uint256 p1, int256 p2) internal pure {\\n    \\t_logImpl3Params(_boolToString(p0), _uintToString(p1), _intToString(p2));\\n\\t}\\n\\n\\tfunction log(bool p0, uint256 p1, uint256 p2) internal pure {\\n    \\t_logImpl3Params(_boolToString(p0), _uintToString(p1), _uintToString(p2));\\n\\t}\\n\\n\\tfunction log(bool p0, uint256 p1, string memory p2) internal pure {\\n    \\t_logImpl3Params(_boolToString(p0), _uintToString(p1), p2);\\n\\t}\\n\\n\\tfunction log(bool p0, uint256 p1, bool p2) internal pure {\\n    \\t_logImpl3Params(_boolToString(p0), _uintToString(p1), _boolToString(p2));\\n\\t}\\n\\n\\tfunction log(bool p0, uint256 p1, address p2) internal pure {\\n    \\t_logImpl3Params(_boolToString(p0), _uintToString(p1), _addressToString(p2));\\n\\t}\\n\\n\\tfunction log(bool p0, string memory p1, int256 p2) internal pure {\\n    \\t_logImpl3Params(_boolToString(p0), p1, _intToString(p2));\\n\\t}\\n\\n\\tfunction log(bool p0, string memory p1, uint256 p2) internal pure {\\n    \\t_logImpl3Params(_boolToString(p0), p1, _uintToString(p2));\\n\\t}\\n\\n\\tfunction log(bool p0, string memory p1, string memory p2) internal pure {\\n    \\t_logImpl3Params(_boolToString(p0), p1, p2);\\n\\t}\\n\\n\\tfunction log(bool p0, string memory p1, bool p2) internal pure {\\n    \\t_logImpl3Params(_boolToString(p0), p1, _boolToString(p2));\\n\\t}\\n\\n\\tfunction log(bool p0, string memory p1, address p2) internal pure {\\n    \\t_logImpl3Params(_boolToString(p0), p1, _addressToString(p2));\\n\\t}\\n\\n\\tfunction log(bool p0, bool p1, int256 p2) internal pure {\\n    \\t_logImpl3Params(_boolToString(p0), _boolToString(p1), _intToString(p2));\\n\\t}\\n\\n\\tfunction log(bool p0, bool p1, uint256 p2) internal pure {\\n    \\t_logImpl3Params(_boolToString(p0), _boolToString(p1), _uintToString(p2));\\n\\t}\\n\\n\\tfunction log(bool p0, bool p1, string memory p2) internal pure {\\n    \\t_logImpl3Params(_boolToString(p0), _boolToString(p1), p2);\\n\\t}\\n\\n\\tfunction log(bool p0, bool p1, bool p2) internal pure {\\n    \\t_logImpl3Params(_boolToString(p0), _boolToString(p1), _boolToString(p2));\\n\\t}\\n\\n\\tfunction log(bool p0, bool p1, address p2) internal pure {\\n    \\t_logImpl3Params(_boolToString(p0), _boolToString(p1), _addressToString(p2));\\n\\t}\\n\\n\\tfunction log(bool p0, address p1, int256 p2) internal pure {\\n    \\t_logImpl3Params(_boolToString(p0), _addressToString(p1), _intToString(p2));\\n\\t}\\n\\n\\tfunction log(bool p0, address p1, uint256 p2) internal pure {\\n    \\t_logImpl3Params(_boolToString(p0), _addressToString(p1), _uintToString(p2));\\n\\t}\\n\\n\\tfunction log(bool p0, address p1, string memory p2) internal pure {\\n    \\t_logImpl3Params(_boolToString(p0), _addressToString(p1), p2);\\n\\t}\\n\\n\\tfunction log(bool p0, address p1, bool p2) internal pure {\\n    \\t_logImpl3Params(_boolToString(p0), _addressToString(p1), _boolToString(p2));\\n\\t}\\n\\n\\tfunction log(bool p0, address p1, address p2) internal pure {\\n    \\t_logImpl3Params(_boolToString(p0), _addressToString(p1), _addressToString(p2));\\n\\t}\\n\\n\\tfunction log(address p0, int256 p1, int256 p2) internal pure {\\n    \\t_logImpl3Params(_addressToString(p0), _intToString(p1), _intToString(p2));\\n\\t}\\n\\n\\tfunction log(address p0, int256 p1, uint256 p2) internal pure {\\n    \\t_logImpl3Params(_addressToString(p0), _intToString(p1), _uintToString(p2));\\n\\t}\\n\\n\\tfunction log(address p0, int256 p1, string memory p2) internal pure {\\n    \\t_logImpl3Params(_addressToString(p0), _intToString(p1), p2);\\n\\t}\\n\\n\\tfunction log(address p0, int256 p1, bool p2) internal pure {\\n    \\t_logImpl3Params(_addressToString(p0), _intToString(p1), _boolToString(p2));\\n\\t}\\n\\n\\tfunction log(address p0, int256 p1, address p2) internal pure {\\n    \\t_logImpl3Params(_addressToString(p0), _intToString(p1), _addressToString(p2));\\n\\t}\\n\\n\\tfunction log(address p0, uint256 p1, int256 p2) internal pure {\\n    \\t_logImpl3Params(_addressToString(p0), _uintToString(p1), _intToString(p2));\\n\\t}\\n\\n\\tfunction log(address p0, uint256 p1, uint256 p2) internal pure {\\n    \\t_logImpl3Params(_addressToString(p0), _uintToString(p1), _uintToString(p2));\\n\\t}\\n\\n\\tfunction log(address p0, uint256 p1, string memory p2) internal pure {\\n    \\t_logImpl3Params(_addressToString(p0), _uintToString(p1), p2);\\n\\t}\\n\\n\\tfunction log(address p0, uint256 p1, bool p2) internal pure {\\n    \\t_logImpl3Params(_addressToString(p0), _uintToString(p1), _boolToString(p2));\\n\\t}\\n\\n\\tfunction log(address p0, uint256 p1, address p2) internal pure {\\n    \\t_logImpl3Params(_addressToString(p0), _uintToString(p1), _addressToString(p2));\\n\\t}\\n\\n\\tfunction log(address p0, string memory p1, int256 p2) internal pure {\\n    \\t_logImpl3Params(_addressToString(p0), p1, _intToString(p2));\\n\\t}\\n\\n\\tfunction log(address p0, string memory p1, uint256 p2) internal pure {\\n    \\t_logImpl3Params(_addressToString(p0), p1, _uintToString(p2));\\n\\t}\\n\\n\\tfunction log(address p0, string memory p1, string memory p2) internal pure {\\n    \\t_logImpl3Params(_addressToString(p0), p1, p2);\\n\\t}\\n\\n\\tfunction log(address p0, string memory p1, bool p2) internal pure {\\n    \\t_logImpl3Params(_addressToString(p0), p1, _boolToString(p2));\\n\\t}\\n\\n\\tfunction log(address p0, string memory p1, address p2) internal pure {\\n    \\t_logImpl3Params(_addressToString(p0), p1, _addressToString(p2));\\n\\t}\\n\\n\\tfunction log(address p0, bool p1, int256 p2) internal pure {\\n    \\t_logImpl3Params(_addressToString(p0), _boolToString(p1), _intToString(p2));\\n\\t}\\n\\n\\tfunction log(address p0, bool p1, uint256 p2) internal pure {\\n    \\t_logImpl3Params(_addressToString(p0), _boolToString(p1), _uintToString(p2));\\n\\t}\\n\\n\\tfunction log(address p0, bool p1, string memory p2) internal pure {\\n    \\t_logImpl3Params(_addressToString(p0), _boolToString(p1), p2);\\n\\t}\\n\\n\\tfunction log(address p0, bool p1, bool p2) internal pure {\\n    \\t_logImpl3Params(_addressToString(p0), _boolToString(p1), _boolToString(p2));\\n\\t}\\n\\n\\tfunction log(address p0, bool p1, address p2) internal pure {\\n    \\t_logImpl3Params(_addressToString(p0), _boolToString(p1), _addressToString(p2));\\n\\t}\\n\\n\\tfunction log(address p0, address p1, int256 p2) internal pure {\\n    \\t_logImpl3Params(_addressToString(p0), _addressToString(p1), _intToString(p2));\\n\\t}\\n\\n\\tfunction log(address p0, address p1, uint256 p2) internal pure {\\n    \\t_logImpl3Params(_addressToString(p0), _addressToString(p1), _uintToString(p2));\\n\\t}\\n\\n\\tfunction log(address p0, address p1, string memory p2) internal pure {\\n    \\t_logImpl3Params(_addressToString(p0), _addressToString(p1), p2);\\n\\t}\\n\\n\\tfunction log(address p0, address p1, bool p2) internal pure {\\n    \\t_logImpl3Params(_addressToString(p0), _addressToString(p1), _boolToString(p2));\\n\\t}\\n\\n\\tfunction log(address p0, address p1, address p2) internal pure {\\n    \\t_logImpl3Params(_addressToString(p0), _addressToString(p1), _addressToString(p2));\\n\\t}\\n\\n}\\n\",\"keccak256\":\"0x5b5b84f8ac9b62db5085117835d99aad6b28b17961be16d89714379da631a3c9\",\"license\":\"MIT\"},\"@openzeppelin/contracts/interfaces/IERC5267.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v5.0.0) (interfaces/IERC5267.sol)\\n\\npragma solidity ^0.8.20;\\n\\ninterface IERC5267 {\\n    /**\\n     * @dev MAY be emitted to signal that the domain could have changed.\\n     */\\n    event EIP712DomainChanged();\\n\\n    /**\\n     * @dev returns the fields and values that describe the domain separator used by this contract for EIP-712\\n     * signature.\\n     */\\n    function eip712Domain()\\n        external\\n        view\\n        returns (\\n            bytes1 fields,\\n            string memory name,\\n            string memory version,\\n            uint256 chainId,\\n            address verifyingContract,\\n            bytes32 salt,\\n            uint256[] memory extensions\\n        );\\n}\\n\",\"keccak256\":\"0x92aa1df62dc3d33f1656d63bede0923e0df0b706ad4137c8b10b0a8fe549fd92\",\"license\":\"MIT\"},\"@openzeppelin/contracts/utils/ShortStrings.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v5.0.0) (utils/ShortStrings.sol)\\n\\npragma solidity ^0.8.20;\\n\\nimport {StorageSlot} from \\\"./StorageSlot.sol\\\";\\n\\n// | string  | 0xAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA   |\\n// | length  | 0x                                                              BB |\\ntype ShortString is bytes32;\\n\\n/**\\n * @dev This library provides functions to convert short memory strings\\n * into a `ShortString` type that can be used as an immutable variable.\\n *\\n * Strings of arbitrary length can be optimized using this library if\\n * they are short enough (up to 31 bytes) by packing them with their\\n * length (1 byte) in a single EVM word (32 bytes). Additionally, a\\n * fallback mechanism can be used for every other case.\\n *\\n * Usage example:\\n *\\n * ```solidity\\n * contract Named {\\n *     using ShortStrings for *;\\n *\\n *     ShortString private immutable _name;\\n *     string private _nameFallback;\\n *\\n *     constructor(string memory contractName) {\\n *         _name = contractName.toShortStringWithFallback(_nameFallback);\\n *     }\\n *\\n *     function name() external view returns (string memory) {\\n *         return _name.toStringWithFallback(_nameFallback);\\n *     }\\n * }\\n * ```\\n */\\nlibrary ShortStrings {\\n    // Used as an identifier for strings longer than 31 bytes.\\n    bytes32 private constant FALLBACK_SENTINEL = 0x00000000000000000000000000000000000000000000000000000000000000FF;\\n\\n    error StringTooLong(string str);\\n    error InvalidShortString();\\n\\n    /**\\n     * @dev Encode a string of at most 31 chars into a `ShortString`.\\n     *\\n     * This will trigger a `StringTooLong` error is the input string is too long.\\n     */\\n    function toShortString(string memory str) internal pure returns (ShortString) {\\n        bytes memory bstr = bytes(str);\\n        if (bstr.length > 31) {\\n            revert StringTooLong(str);\\n        }\\n        return ShortString.wrap(bytes32(uint256(bytes32(bstr)) | bstr.length));\\n    }\\n\\n    /**\\n     * @dev Decode a `ShortString` back to a \\\"normal\\\" string.\\n     */\\n    function toString(ShortString sstr) internal pure returns (string memory) {\\n        uint256 len = byteLength(sstr);\\n        // using `new string(len)` would work locally but is not memory safe.\\n        string memory str = new string(32);\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            mstore(str, len)\\n            mstore(add(str, 0x20), sstr)\\n        }\\n        return str;\\n    }\\n\\n    /**\\n     * @dev Return the length of a `ShortString`.\\n     */\\n    function byteLength(ShortString sstr) internal pure returns (uint256) {\\n        uint256 result = uint256(ShortString.unwrap(sstr)) & 0xFF;\\n        if (result > 31) {\\n            revert InvalidShortString();\\n        }\\n        return result;\\n    }\\n\\n    /**\\n     * @dev Encode a string into a `ShortString`, or write it to storage if it is too long.\\n     */\\n    function toShortStringWithFallback(string memory value, string storage store) internal returns (ShortString) {\\n        if (bytes(value).length < 32) {\\n            return toShortString(value);\\n        } else {\\n            StorageSlot.getStringSlot(store).value = value;\\n            return ShortString.wrap(FALLBACK_SENTINEL);\\n        }\\n    }\\n\\n    /**\\n     * @dev Decode a string that was encoded to `ShortString` or written to storage using {setWithFallback}.\\n     */\\n    function toStringWithFallback(ShortString value, string storage store) internal pure returns (string memory) {\\n        if (ShortString.unwrap(value) != FALLBACK_SENTINEL) {\\n            return toString(value);\\n        } else {\\n            return store;\\n        }\\n    }\\n\\n    /**\\n     * @dev Return the length of a string that was encoded to `ShortString` or written to storage using\\n     * {setWithFallback}.\\n     *\\n     * WARNING: This will return the \\\"byte length\\\" of the string. This may not reflect the actual length in terms of\\n     * actual characters as the UTF-8 encoding of a single character can span over multiple bytes.\\n     */\\n    function byteLengthWithFallback(ShortString value, string storage store) internal view returns (uint256) {\\n        if (ShortString.unwrap(value) != FALLBACK_SENTINEL) {\\n            return byteLength(value);\\n        } else {\\n            return bytes(store).length;\\n        }\\n    }\\n}\\n\",\"keccak256\":\"0x18a7171df639a934592915a520ecb97c5bbc9675a1105607aac8a94e72bf62c6\",\"license\":\"MIT\"},\"@openzeppelin/contracts/utils/StorageSlot.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v5.0.0) (utils/StorageSlot.sol)\\n// This file was procedurally generated from scripts/generate/templates/StorageSlot.js.\\n\\npragma solidity ^0.8.20;\\n\\n/**\\n * @dev Library for reading and writing primitive types to specific storage slots.\\n *\\n * Storage slots are often used to avoid storage conflict when dealing with upgradeable contracts.\\n * This library helps with reading and writing to such slots without the need for inline assembly.\\n *\\n * The functions in this library return Slot structs that contain a `value` member that can be used to read or write.\\n *\\n * Example usage to set ERC1967 implementation slot:\\n * ```solidity\\n * contract ERC1967 {\\n *     bytes32 internal constant _IMPLEMENTATION_SLOT = 0x360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc;\\n *\\n *     function _getImplementation() internal view returns (address) {\\n *         return StorageSlot.getAddressSlot(_IMPLEMENTATION_SLOT).value;\\n *     }\\n *\\n *     function _setImplementation(address newImplementation) internal {\\n *         require(newImplementation.code.length > 0);\\n *         StorageSlot.getAddressSlot(_IMPLEMENTATION_SLOT).value = newImplementation;\\n *     }\\n * }\\n * ```\\n */\\nlibrary StorageSlot {\\n    struct AddressSlot {\\n        address value;\\n    }\\n\\n    struct BooleanSlot {\\n        bool value;\\n    }\\n\\n    struct Bytes32Slot {\\n        bytes32 value;\\n    }\\n\\n    struct Uint256Slot {\\n        uint256 value;\\n    }\\n\\n    struct StringSlot {\\n        string value;\\n    }\\n\\n    struct BytesSlot {\\n        bytes value;\\n    }\\n\\n    /**\\n     * @dev Returns an `AddressSlot` with member `value` located at `slot`.\\n     */\\n    function getAddressSlot(bytes32 slot) internal pure returns (AddressSlot storage r) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            r.slot := slot\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns an `BooleanSlot` with member `value` located at `slot`.\\n     */\\n    function getBooleanSlot(bytes32 slot) internal pure returns (BooleanSlot storage r) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            r.slot := slot\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns an `Bytes32Slot` with member `value` located at `slot`.\\n     */\\n    function getBytes32Slot(bytes32 slot) internal pure returns (Bytes32Slot storage r) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            r.slot := slot\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns an `Uint256Slot` with member `value` located at `slot`.\\n     */\\n    function getUint256Slot(bytes32 slot) internal pure returns (Uint256Slot storage r) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            r.slot := slot\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns an `StringSlot` with member `value` located at `slot`.\\n     */\\n    function getStringSlot(bytes32 slot) internal pure returns (StringSlot storage r) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            r.slot := slot\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns an `StringSlot` representation of the string storage pointer `store`.\\n     */\\n    function getStringSlot(string storage store) internal pure returns (StringSlot storage r) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            r.slot := store.slot\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns an `BytesSlot` with member `value` located at `slot`.\\n     */\\n    function getBytesSlot(bytes32 slot) internal pure returns (BytesSlot storage r) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            r.slot := slot\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns an `BytesSlot` representation of the bytes storage pointer `store`.\\n     */\\n    function getBytesSlot(bytes storage store) internal pure returns (BytesSlot storage r) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            r.slot := store.slot\\n        }\\n    }\\n}\\n\",\"keccak256\":\"0x32ba59b4b7299237c8ba56319110989d7978a039faf754793064e967e5894418\",\"license\":\"MIT\"},\"@openzeppelin/contracts/utils/Strings.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v5.0.0) (utils/Strings.sol)\\n\\npragma solidity ^0.8.20;\\n\\nimport {Math} from \\\"./math/Math.sol\\\";\\nimport {SignedMath} from \\\"./math/SignedMath.sol\\\";\\n\\n/**\\n * @dev String operations.\\n */\\nlibrary Strings {\\n    bytes16 private constant HEX_DIGITS = \\\"0123456789abcdef\\\";\\n    uint8 private constant ADDRESS_LENGTH = 20;\\n\\n    /**\\n     * @dev The `value` string doesn't fit in the specified `length`.\\n     */\\n    error StringsInsufficientHexLength(uint256 value, uint256 length);\\n\\n    /**\\n     * @dev Converts a `uint256` to its ASCII `string` decimal representation.\\n     */\\n    function toString(uint256 value) internal pure returns (string memory) {\\n        unchecked {\\n            uint256 length = Math.log10(value) + 1;\\n            string memory buffer = new string(length);\\n            uint256 ptr;\\n            /// @solidity memory-safe-assembly\\n            assembly {\\n                ptr := add(buffer, add(32, length))\\n            }\\n            while (true) {\\n                ptr--;\\n                /// @solidity memory-safe-assembly\\n                assembly {\\n                    mstore8(ptr, byte(mod(value, 10), HEX_DIGITS))\\n                }\\n                value /= 10;\\n                if (value == 0) break;\\n            }\\n            return buffer;\\n        }\\n    }\\n\\n    /**\\n     * @dev Converts a `int256` to its ASCII `string` decimal representation.\\n     */\\n    function toStringSigned(int256 value) internal pure returns (string memory) {\\n        return string.concat(value < 0 ? \\\"-\\\" : \\\"\\\", toString(SignedMath.abs(value)));\\n    }\\n\\n    /**\\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation.\\n     */\\n    function toHexString(uint256 value) internal pure returns (string memory) {\\n        unchecked {\\n            return toHexString(value, Math.log256(value) + 1);\\n        }\\n    }\\n\\n    /**\\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation with fixed length.\\n     */\\n    function toHexString(uint256 value, uint256 length) internal pure returns (string memory) {\\n        uint256 localValue = value;\\n        bytes memory buffer = new bytes(2 * length + 2);\\n        buffer[0] = \\\"0\\\";\\n        buffer[1] = \\\"x\\\";\\n        for (uint256 i = 2 * length + 1; i > 1; --i) {\\n            buffer[i] = HEX_DIGITS[localValue & 0xf];\\n            localValue >>= 4;\\n        }\\n        if (localValue != 0) {\\n            revert StringsInsufficientHexLength(value, length);\\n        }\\n        return string(buffer);\\n    }\\n\\n    /**\\n     * @dev Converts an `address` with fixed length of 20 bytes to its not checksummed ASCII `string` hexadecimal\\n     * representation.\\n     */\\n    function toHexString(address addr) internal pure returns (string memory) {\\n        return toHexString(uint256(uint160(addr)), ADDRESS_LENGTH);\\n    }\\n\\n    /**\\n     * @dev Returns true if the two strings are equal.\\n     */\\n    function equal(string memory a, string memory b) internal pure returns (bool) {\\n        return bytes(a).length == bytes(b).length && keccak256(bytes(a)) == keccak256(bytes(b));\\n    }\\n}\\n\",\"keccak256\":\"0x55f102ea785d8399c0e58d1108e2d289506dde18abc6db1b7f68c1f9f9bc5792\",\"license\":\"MIT\"},\"@openzeppelin/contracts/utils/cryptography/ECDSA.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v5.0.0) (utils/cryptography/ECDSA.sol)\\n\\npragma solidity ^0.8.20;\\n\\n/**\\n * @dev Elliptic Curve Digital Signature Algorithm (ECDSA) operations.\\n *\\n * These functions can be used to verify that a message was signed by the holder\\n * of the private keys of a given address.\\n */\\nlibrary ECDSA {\\n    enum RecoverError {\\n        NoError,\\n        InvalidSignature,\\n        InvalidSignatureLength,\\n        InvalidSignatureS\\n    }\\n\\n    /**\\n     * @dev The signature derives the `address(0)`.\\n     */\\n    error ECDSAInvalidSignature();\\n\\n    /**\\n     * @dev The signature has an invalid length.\\n     */\\n    error ECDSAInvalidSignatureLength(uint256 length);\\n\\n    /**\\n     * @dev The signature has an S value that is in the upper half order.\\n     */\\n    error ECDSAInvalidSignatureS(bytes32 s);\\n\\n    /**\\n     * @dev Returns the address that signed a hashed message (`hash`) with `signature` or an error. This will not\\n     * return address(0) without also returning an error description. Errors are documented using an enum (error type)\\n     * and a bytes32 providing additional information about the error.\\n     *\\n     * If no error is returned, then the address can be used for verification purposes.\\n     *\\n     * The `ecrecover` EVM precompile allows for malleable (non-unique) signatures:\\n     * this function rejects them by requiring the `s` value to be in the lower\\n     * half order, and the `v` value to be either 27 or 28.\\n     *\\n     * IMPORTANT: `hash` _must_ be the result of a hash operation for the\\n     * verification to be secure: it is possible to craft signatures that\\n     * recover to arbitrary addresses for non-hashed data. A safe way to ensure\\n     * this is by receiving a hash of the original message (which may otherwise\\n     * be too long), and then calling {MessageHashUtils-toEthSignedMessageHash} on it.\\n     *\\n     * Documentation for signature generation:\\n     * - with https://web3js.readthedocs.io/en/v1.3.4/web3-eth-accounts.html#sign[Web3.js]\\n     * - with https://docs.ethers.io/v5/api/signer/#Signer-signMessage[ethers]\\n     */\\n    function tryRecover(bytes32 hash, bytes memory signature) internal pure returns (address, RecoverError, bytes32) {\\n        if (signature.length == 65) {\\n            bytes32 r;\\n            bytes32 s;\\n            uint8 v;\\n            // ecrecover takes the signature parameters, and the only way to get them\\n            // currently is to use assembly.\\n            /// @solidity memory-safe-assembly\\n            assembly {\\n                r := mload(add(signature, 0x20))\\n                s := mload(add(signature, 0x40))\\n                v := byte(0, mload(add(signature, 0x60)))\\n            }\\n            return tryRecover(hash, v, r, s);\\n        } else {\\n            return (address(0), RecoverError.InvalidSignatureLength, bytes32(signature.length));\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the address that signed a hashed message (`hash`) with\\n     * `signature`. This address can then be used for verification purposes.\\n     *\\n     * The `ecrecover` EVM precompile allows for malleable (non-unique) signatures:\\n     * this function rejects them by requiring the `s` value to be in the lower\\n     * half order, and the `v` value to be either 27 or 28.\\n     *\\n     * IMPORTANT: `hash` _must_ be the result of a hash operation for the\\n     * verification to be secure: it is possible to craft signatures that\\n     * recover to arbitrary addresses for non-hashed data. A safe way to ensure\\n     * this is by receiving a hash of the original message (which may otherwise\\n     * be too long), and then calling {MessageHashUtils-toEthSignedMessageHash} on it.\\n     */\\n    function recover(bytes32 hash, bytes memory signature) internal pure returns (address) {\\n        (address recovered, RecoverError error, bytes32 errorArg) = tryRecover(hash, signature);\\n        _throwError(error, errorArg);\\n        return recovered;\\n    }\\n\\n    /**\\n     * @dev Overload of {ECDSA-tryRecover} that receives the `r` and `vs` short-signature fields separately.\\n     *\\n     * See https://eips.ethereum.org/EIPS/eip-2098[EIP-2098 short signatures]\\n     */\\n    function tryRecover(bytes32 hash, bytes32 r, bytes32 vs) internal pure returns (address, RecoverError, bytes32) {\\n        unchecked {\\n            bytes32 s = vs & bytes32(0x7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff);\\n            // We do not check for an overflow here since the shift operation results in 0 or 1.\\n            uint8 v = uint8((uint256(vs) >> 255) + 27);\\n            return tryRecover(hash, v, r, s);\\n        }\\n    }\\n\\n    /**\\n     * @dev Overload of {ECDSA-recover} that receives the `r and `vs` short-signature fields separately.\\n     */\\n    function recover(bytes32 hash, bytes32 r, bytes32 vs) internal pure returns (address) {\\n        (address recovered, RecoverError error, bytes32 errorArg) = tryRecover(hash, r, vs);\\n        _throwError(error, errorArg);\\n        return recovered;\\n    }\\n\\n    /**\\n     * @dev Overload of {ECDSA-tryRecover} that receives the `v`,\\n     * `r` and `s` signature fields separately.\\n     */\\n    function tryRecover(\\n        bytes32 hash,\\n        uint8 v,\\n        bytes32 r,\\n        bytes32 s\\n    ) internal pure returns (address, RecoverError, bytes32) {\\n        // EIP-2 still allows signature malleability for ecrecover(). Remove this possibility and make the signature\\n        // unique. Appendix F in the Ethereum Yellow paper (https://ethereum.github.io/yellowpaper/paper.pdf), defines\\n        // the valid range for s in (301): 0 < s < secp256k1n \\u00f7 2 + 1, and for v in (302): v \\u2208 {27, 28}. Most\\n        // signatures from current libraries generate a unique signature with an s-value in the lower half order.\\n        //\\n        // If your library generates malleable signatures, such as s-values in the upper range, calculate a new s-value\\n        // with 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEBAAEDCE6AF48A03BBFD25E8CD0364141 - s1 and flip v from 27 to 28 or\\n        // vice versa. If your library also generates signatures with 0/1 for v instead 27/28, add 27 to v to accept\\n        // these malleable signatures as well.\\n        if (uint256(s) > 0x7FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF5D576E7357A4501DDFE92F46681B20A0) {\\n            return (address(0), RecoverError.InvalidSignatureS, s);\\n        }\\n\\n        // If the signature is valid (and not malleable), return the signer address\\n        address signer = ecrecover(hash, v, r, s);\\n        if (signer == address(0)) {\\n            return (address(0), RecoverError.InvalidSignature, bytes32(0));\\n        }\\n\\n        return (signer, RecoverError.NoError, bytes32(0));\\n    }\\n\\n    /**\\n     * @dev Overload of {ECDSA-recover} that receives the `v`,\\n     * `r` and `s` signature fields separately.\\n     */\\n    function recover(bytes32 hash, uint8 v, bytes32 r, bytes32 s) internal pure returns (address) {\\n        (address recovered, RecoverError error, bytes32 errorArg) = tryRecover(hash, v, r, s);\\n        _throwError(error, errorArg);\\n        return recovered;\\n    }\\n\\n    /**\\n     * @dev Optionally reverts with the corresponding custom error according to the `error` argument provided.\\n     */\\n    function _throwError(RecoverError error, bytes32 errorArg) private pure {\\n        if (error == RecoverError.NoError) {\\n            return; // no error: do nothing\\n        } else if (error == RecoverError.InvalidSignature) {\\n            revert ECDSAInvalidSignature();\\n        } else if (error == RecoverError.InvalidSignatureLength) {\\n            revert ECDSAInvalidSignatureLength(uint256(errorArg));\\n        } else if (error == RecoverError.InvalidSignatureS) {\\n            revert ECDSAInvalidSignatureS(errorArg);\\n        }\\n    }\\n}\\n\",\"keccak256\":\"0xeed0a08b0b091f528356cbc7245891a4c748682d4f6a18055e8e6ca77d12a6cf\",\"license\":\"MIT\"},\"@openzeppelin/contracts/utils/cryptography/EIP712.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v5.0.0) (utils/cryptography/EIP712.sol)\\n\\npragma solidity ^0.8.20;\\n\\nimport {MessageHashUtils} from \\\"./MessageHashUtils.sol\\\";\\nimport {ShortStrings, ShortString} from \\\"../ShortStrings.sol\\\";\\nimport {IERC5267} from \\\"../../interfaces/IERC5267.sol\\\";\\n\\n/**\\n * @dev https://eips.ethereum.org/EIPS/eip-712[EIP 712] is a standard for hashing and signing of typed structured data.\\n *\\n * The encoding scheme specified in the EIP requires a domain separator and a hash of the typed structured data, whose\\n * encoding is very generic and therefore its implementation in Solidity is not feasible, thus this contract\\n * does not implement the encoding itself. Protocols need to implement the type-specific encoding they need in order to\\n * produce the hash of their typed data using a combination of `abi.encode` and `keccak256`.\\n *\\n * This contract implements the EIP 712 domain separator ({_domainSeparatorV4}) that is used as part of the encoding\\n * scheme, and the final step of the encoding to obtain the message digest that is then signed via ECDSA\\n * ({_hashTypedDataV4}).\\n *\\n * The implementation of the domain separator was designed to be as efficient as possible while still properly updating\\n * the chain id to protect against replay attacks on an eventual fork of the chain.\\n *\\n * NOTE: This contract implements the version of the encoding known as \\\"v4\\\", as implemented by the JSON RPC method\\n * https://docs.metamask.io/guide/signing-data.html[`eth_signTypedDataV4` in MetaMask].\\n *\\n * NOTE: In the upgradeable version of this contract, the cached values will correspond to the address, and the domain\\n * separator of the implementation contract. This will cause the {_domainSeparatorV4} function to always rebuild the\\n * separator from the immutable values, which is cheaper than accessing a cached version in cold storage.\\n *\\n * @custom:oz-upgrades-unsafe-allow state-variable-immutable\\n */\\nabstract contract EIP712 is IERC5267 {\\n    using ShortStrings for *;\\n\\n    bytes32 private constant TYPE_HASH =\\n        keccak256(\\\"EIP712Domain(string name,string version,uint256 chainId,address verifyingContract)\\\");\\n\\n    // Cache the domain separator as an immutable value, but also store the chain id that it corresponds to, in order to\\n    // invalidate the cached domain separator if the chain id changes.\\n    bytes32 private immutable _cachedDomainSeparator;\\n    uint256 private immutable _cachedChainId;\\n    address private immutable _cachedThis;\\n\\n    bytes32 private immutable _hashedName;\\n    bytes32 private immutable _hashedVersion;\\n\\n    ShortString private immutable _name;\\n    ShortString private immutable _version;\\n    string private _nameFallback;\\n    string private _versionFallback;\\n\\n    /**\\n     * @dev Initializes the domain separator and parameter caches.\\n     *\\n     * The meaning of `name` and `version` is specified in\\n     * https://eips.ethereum.org/EIPS/eip-712#definition-of-domainseparator[EIP 712]:\\n     *\\n     * - `name`: the user readable name of the signing domain, i.e. the name of the DApp or the protocol.\\n     * - `version`: the current major version of the signing domain.\\n     *\\n     * NOTE: These parameters cannot be changed except through a xref:learn::upgrading-smart-contracts.adoc[smart\\n     * contract upgrade].\\n     */\\n    constructor(string memory name, string memory version) {\\n        _name = name.toShortStringWithFallback(_nameFallback);\\n        _version = version.toShortStringWithFallback(_versionFallback);\\n        _hashedName = keccak256(bytes(name));\\n        _hashedVersion = keccak256(bytes(version));\\n\\n        _cachedChainId = block.chainid;\\n        _cachedDomainSeparator = _buildDomainSeparator();\\n        _cachedThis = address(this);\\n    }\\n\\n    /**\\n     * @dev Returns the domain separator for the current chain.\\n     */\\n    function _domainSeparatorV4() internal view returns (bytes32) {\\n        if (address(this) == _cachedThis && block.chainid == _cachedChainId) {\\n            return _cachedDomainSeparator;\\n        } else {\\n            return _buildDomainSeparator();\\n        }\\n    }\\n\\n    function _buildDomainSeparator() private view returns (bytes32) {\\n        return keccak256(abi.encode(TYPE_HASH, _hashedName, _hashedVersion, block.chainid, address(this)));\\n    }\\n\\n    /**\\n     * @dev Given an already https://eips.ethereum.org/EIPS/eip-712#definition-of-hashstruct[hashed struct], this\\n     * function returns the hash of the fully encoded EIP712 message for this domain.\\n     *\\n     * This hash can be used together with {ECDSA-recover} to obtain the signer of a message. For example:\\n     *\\n     * ```solidity\\n     * bytes32 digest = _hashTypedDataV4(keccak256(abi.encode(\\n     *     keccak256(\\\"Mail(address to,string contents)\\\"),\\n     *     mailTo,\\n     *     keccak256(bytes(mailContents))\\n     * )));\\n     * address signer = ECDSA.recover(digest, signature);\\n     * ```\\n     */\\n    function _hashTypedDataV4(bytes32 structHash) internal view virtual returns (bytes32) {\\n        return MessageHashUtils.toTypedDataHash(_domainSeparatorV4(), structHash);\\n    }\\n\\n    /**\\n     * @dev See {IERC-5267}.\\n     */\\n    function eip712Domain()\\n        public\\n        view\\n        virtual\\n        returns (\\n            bytes1 fields,\\n            string memory name,\\n            string memory version,\\n            uint256 chainId,\\n            address verifyingContract,\\n            bytes32 salt,\\n            uint256[] memory extensions\\n        )\\n    {\\n        return (\\n            hex\\\"0f\\\", // 01111\\n            _EIP712Name(),\\n            _EIP712Version(),\\n            block.chainid,\\n            address(this),\\n            bytes32(0),\\n            new uint256[](0)\\n        );\\n    }\\n\\n    /**\\n     * @dev The name parameter for the EIP712 domain.\\n     *\\n     * NOTE: By default this function reads _name which is an immutable value.\\n     * It only reads from storage if necessary (in case the value is too large to fit in a ShortString).\\n     */\\n    // solhint-disable-next-line func-name-mixedcase\\n    function _EIP712Name() internal view returns (string memory) {\\n        return _name.toStringWithFallback(_nameFallback);\\n    }\\n\\n    /**\\n     * @dev The version parameter for the EIP712 domain.\\n     *\\n     * NOTE: By default this function reads _version which is an immutable value.\\n     * It only reads from storage if necessary (in case the value is too large to fit in a ShortString).\\n     */\\n    // solhint-disable-next-line func-name-mixedcase\\n    function _EIP712Version() internal view returns (string memory) {\\n        return _version.toStringWithFallback(_versionFallback);\\n    }\\n}\\n\",\"keccak256\":\"0x999f705a027ed6dc2d4e0df2cc4a509852c6bfd11de1c8161bf88832d0503fd0\",\"license\":\"MIT\"},\"@openzeppelin/contracts/utils/cryptography/MessageHashUtils.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v5.0.0) (utils/cryptography/MessageHashUtils.sol)\\n\\npragma solidity ^0.8.20;\\n\\nimport {Strings} from \\\"../Strings.sol\\\";\\n\\n/**\\n * @dev Signature message hash utilities for producing digests to be consumed by {ECDSA} recovery or signing.\\n *\\n * The library provides methods for generating a hash of a message that conforms to the\\n * https://eips.ethereum.org/EIPS/eip-191[EIP 191] and https://eips.ethereum.org/EIPS/eip-712[EIP 712]\\n * specifications.\\n */\\nlibrary MessageHashUtils {\\n    /**\\n     * @dev Returns the keccak256 digest of an EIP-191 signed data with version\\n     * `0x45` (`personal_sign` messages).\\n     *\\n     * The digest is calculated by prefixing a bytes32 `messageHash` with\\n     * `\\\"\\\\x19Ethereum Signed Message:\\\\n32\\\"` and hashing the result. It corresponds with the\\n     * hash signed when using the https://eth.wiki/json-rpc/API#eth_sign[`eth_sign`] JSON-RPC method.\\n     *\\n     * NOTE: The `messageHash` parameter is intended to be the result of hashing a raw message with\\n     * keccak256, although any bytes32 value can be safely used because the final digest will\\n     * be re-hashed.\\n     *\\n     * See {ECDSA-recover}.\\n     */\\n    function toEthSignedMessageHash(bytes32 messageHash) internal pure returns (bytes32 digest) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            mstore(0x00, \\\"\\\\x19Ethereum Signed Message:\\\\n32\\\") // 32 is the bytes-length of messageHash\\n            mstore(0x1c, messageHash) // 0x1c (28) is the length of the prefix\\n            digest := keccak256(0x00, 0x3c) // 0x3c is the length of the prefix (0x1c) + messageHash (0x20)\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the keccak256 digest of an EIP-191 signed data with version\\n     * `0x45` (`personal_sign` messages).\\n     *\\n     * The digest is calculated by prefixing an arbitrary `message` with\\n     * `\\\"\\\\x19Ethereum Signed Message:\\\\n\\\" + len(message)` and hashing the result. It corresponds with the\\n     * hash signed when using the https://eth.wiki/json-rpc/API#eth_sign[`eth_sign`] JSON-RPC method.\\n     *\\n     * See {ECDSA-recover}.\\n     */\\n    function toEthSignedMessageHash(bytes memory message) internal pure returns (bytes32) {\\n        return\\n            keccak256(bytes.concat(\\\"\\\\x19Ethereum Signed Message:\\\\n\\\", bytes(Strings.toString(message.length)), message));\\n    }\\n\\n    /**\\n     * @dev Returns the keccak256 digest of an EIP-191 signed data with version\\n     * `0x00` (data with intended validator).\\n     *\\n     * The digest is calculated by prefixing an arbitrary `data` with `\\\"\\\\x19\\\\x00\\\"` and the intended\\n     * `validator` address. Then hashing the result.\\n     *\\n     * See {ECDSA-recover}.\\n     */\\n    function toDataWithIntendedValidatorHash(address validator, bytes memory data) internal pure returns (bytes32) {\\n        return keccak256(abi.encodePacked(hex\\\"19_00\\\", validator, data));\\n    }\\n\\n    /**\\n     * @dev Returns the keccak256 digest of an EIP-712 typed data (EIP-191 version `0x01`).\\n     *\\n     * The digest is calculated from a `domainSeparator` and a `structHash`, by prefixing them with\\n     * `\\\\x19\\\\x01` and hashing the result. It corresponds to the hash signed by the\\n     * https://eips.ethereum.org/EIPS/eip-712[`eth_signTypedData`] JSON-RPC method as part of EIP-712.\\n     *\\n     * See {ECDSA-recover}.\\n     */\\n    function toTypedDataHash(bytes32 domainSeparator, bytes32 structHash) internal pure returns (bytes32 digest) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            let ptr := mload(0x40)\\n            mstore(ptr, hex\\\"19_01\\\")\\n            mstore(add(ptr, 0x02), domainSeparator)\\n            mstore(add(ptr, 0x22), structHash)\\n            digest := keccak256(ptr, 0x42)\\n        }\\n    }\\n}\\n\",\"keccak256\":\"0xba333517a3add42cd35fe877656fc3dfcc9de53baa4f3aabbd6d12a92e4ea435\",\"license\":\"MIT\"},\"@openzeppelin/contracts/utils/math/Math.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v5.0.0) (utils/math/Math.sol)\\n\\npragma solidity ^0.8.20;\\n\\n/**\\n * @dev Standard math utilities missing in the Solidity language.\\n */\\nlibrary Math {\\n    /**\\n     * @dev Muldiv operation overflow.\\n     */\\n    error MathOverflowedMulDiv();\\n\\n    enum Rounding {\\n        Floor, // Toward negative infinity\\n        Ceil, // Toward positive infinity\\n        Trunc, // Toward zero\\n        Expand // Away from zero\\n    }\\n\\n    /**\\n     * @dev Returns the addition of two unsigned integers, with an overflow flag.\\n     */\\n    function tryAdd(uint256 a, uint256 b) internal pure returns (bool, uint256) {\\n        unchecked {\\n            uint256 c = a + b;\\n            if (c < a) return (false, 0);\\n            return (true, c);\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the subtraction of two unsigned integers, with an overflow flag.\\n     */\\n    function trySub(uint256 a, uint256 b) internal pure returns (bool, uint256) {\\n        unchecked {\\n            if (b > a) return (false, 0);\\n            return (true, a - b);\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the multiplication of two unsigned integers, with an overflow flag.\\n     */\\n    function tryMul(uint256 a, uint256 b) internal pure returns (bool, uint256) {\\n        unchecked {\\n            // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\\n            // benefit is lost if 'b' is also tested.\\n            // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\\n            if (a == 0) return (true, 0);\\n            uint256 c = a * b;\\n            if (c / a != b) return (false, 0);\\n            return (true, c);\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the division of two unsigned integers, with a division by zero flag.\\n     */\\n    function tryDiv(uint256 a, uint256 b) internal pure returns (bool, uint256) {\\n        unchecked {\\n            if (b == 0) return (false, 0);\\n            return (true, a / b);\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the remainder of dividing two unsigned integers, with a division by zero flag.\\n     */\\n    function tryMod(uint256 a, uint256 b) internal pure returns (bool, uint256) {\\n        unchecked {\\n            if (b == 0) return (false, 0);\\n            return (true, a % b);\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the largest of two numbers.\\n     */\\n    function max(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return a > b ? a : b;\\n    }\\n\\n    /**\\n     * @dev Returns the smallest of two numbers.\\n     */\\n    function min(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return a < b ? a : b;\\n    }\\n\\n    /**\\n     * @dev Returns the average of two numbers. The result is rounded towards\\n     * zero.\\n     */\\n    function average(uint256 a, uint256 b) internal pure returns (uint256) {\\n        // (a + b) / 2 can overflow.\\n        return (a & b) + (a ^ b) / 2;\\n    }\\n\\n    /**\\n     * @dev Returns the ceiling of the division of two numbers.\\n     *\\n     * This differs from standard division with `/` in that it rounds towards infinity instead\\n     * of rounding towards zero.\\n     */\\n    function ceilDiv(uint256 a, uint256 b) internal pure returns (uint256) {\\n        if (b == 0) {\\n            // Guarantee the same behavior as in a regular Solidity division.\\n            return a / b;\\n        }\\n\\n        // (a + b - 1) / b can overflow on addition, so we distribute.\\n        return a == 0 ? 0 : (a - 1) / b + 1;\\n    }\\n\\n    /**\\n     * @notice Calculates floor(x * y / denominator) with full precision. Throws if result overflows a uint256 or\\n     * denominator == 0.\\n     * @dev Original credit to Remco Bloemen under MIT license (https://xn--2-umb.com/21/muldiv) with further edits by\\n     * Uniswap Labs also under MIT license.\\n     */\\n    function mulDiv(uint256 x, uint256 y, uint256 denominator) internal pure returns (uint256 result) {\\n        unchecked {\\n            // 512-bit multiply [prod1 prod0] = x * y. Compute the product mod 2^256 and mod 2^256 - 1, then use\\n            // use the Chinese Remainder Theorem to reconstruct the 512 bit result. The result is stored in two 256\\n            // variables such that product = prod1 * 2^256 + prod0.\\n            uint256 prod0 = x * y; // Least significant 256 bits of the product\\n            uint256 prod1; // Most significant 256 bits of the product\\n            assembly {\\n                let mm := mulmod(x, y, not(0))\\n                prod1 := sub(sub(mm, prod0), lt(mm, prod0))\\n            }\\n\\n            // Handle non-overflow cases, 256 by 256 division.\\n            if (prod1 == 0) {\\n                // Solidity will revert if denominator == 0, unlike the div opcode on its own.\\n                // The surrounding unchecked block does not change this fact.\\n                // See https://docs.soliditylang.org/en/latest/control-structures.html#checked-or-unchecked-arithmetic.\\n                return prod0 / denominator;\\n            }\\n\\n            // Make sure the result is less than 2^256. Also prevents denominator == 0.\\n            if (denominator <= prod1) {\\n                revert MathOverflowedMulDiv();\\n            }\\n\\n            ///////////////////////////////////////////////\\n            // 512 by 256 division.\\n            ///////////////////////////////////////////////\\n\\n            // Make division exact by subtracting the remainder from [prod1 prod0].\\n            uint256 remainder;\\n            assembly {\\n                // Compute remainder using mulmod.\\n                remainder := mulmod(x, y, denominator)\\n\\n                // Subtract 256 bit number from 512 bit number.\\n                prod1 := sub(prod1, gt(remainder, prod0))\\n                prod0 := sub(prod0, remainder)\\n            }\\n\\n            // Factor powers of two out of denominator and compute largest power of two divisor of denominator.\\n            // Always >= 1. See https://cs.stackexchange.com/q/138556/92363.\\n\\n            uint256 twos = denominator & (0 - denominator);\\n            assembly {\\n                // Divide denominator by twos.\\n                denominator := div(denominator, twos)\\n\\n                // Divide [prod1 prod0] by twos.\\n                prod0 := div(prod0, twos)\\n\\n                // Flip twos such that it is 2^256 / twos. If twos is zero, then it becomes one.\\n                twos := add(div(sub(0, twos), twos), 1)\\n            }\\n\\n            // Shift in bits from prod1 into prod0.\\n            prod0 |= prod1 * twos;\\n\\n            // Invert denominator mod 2^256. Now that denominator is an odd number, it has an inverse modulo 2^256 such\\n            // that denominator * inv = 1 mod 2^256. Compute the inverse by starting with a seed that is correct for\\n            // four bits. That is, denominator * inv = 1 mod 2^4.\\n            uint256 inverse = (3 * denominator) ^ 2;\\n\\n            // Use the Newton-Raphson iteration to improve the precision. Thanks to Hensel's lifting lemma, this also\\n            // works in modular arithmetic, doubling the correct bits in each step.\\n            inverse *= 2 - denominator * inverse; // inverse mod 2^8\\n            inverse *= 2 - denominator * inverse; // inverse mod 2^16\\n            inverse *= 2 - denominator * inverse; // inverse mod 2^32\\n            inverse *= 2 - denominator * inverse; // inverse mod 2^64\\n            inverse *= 2 - denominator * inverse; // inverse mod 2^128\\n            inverse *= 2 - denominator * inverse; // inverse mod 2^256\\n\\n            // Because the division is now exact we can divide by multiplying with the modular inverse of denominator.\\n            // This will give us the correct result modulo 2^256. Since the preconditions guarantee that the outcome is\\n            // less than 2^256, this is the final result. We don't need to compute the high bits of the result and prod1\\n            // is no longer required.\\n            result = prod0 * inverse;\\n            return result;\\n        }\\n    }\\n\\n    /**\\n     * @notice Calculates x * y / denominator with full precision, following the selected rounding direction.\\n     */\\n    function mulDiv(uint256 x, uint256 y, uint256 denominator, Rounding rounding) internal pure returns (uint256) {\\n        uint256 result = mulDiv(x, y, denominator);\\n        if (unsignedRoundsUp(rounding) && mulmod(x, y, denominator) > 0) {\\n            result += 1;\\n        }\\n        return result;\\n    }\\n\\n    /**\\n     * @dev Returns the square root of a number. If the number is not a perfect square, the value is rounded\\n     * towards zero.\\n     *\\n     * Inspired by Henry S. Warren, Jr.'s \\\"Hacker's Delight\\\" (Chapter 11).\\n     */\\n    function sqrt(uint256 a) internal pure returns (uint256) {\\n        if (a == 0) {\\n            return 0;\\n        }\\n\\n        // For our first guess, we get the biggest power of 2 which is smaller than the square root of the target.\\n        //\\n        // We know that the \\\"msb\\\" (most significant bit) of our target number `a` is a power of 2 such that we have\\n        // `msb(a) <= a < 2*msb(a)`. This value can be written `msb(a)=2**k` with `k=log2(a)`.\\n        //\\n        // This can be rewritten `2**log2(a) <= a < 2**(log2(a) + 1)`\\n        // \\u2192 `sqrt(2**k) <= sqrt(a) < sqrt(2**(k+1))`\\n        // \\u2192 `2**(k/2) <= sqrt(a) < 2**((k+1)/2) <= 2**(k/2 + 1)`\\n        //\\n        // Consequently, `2**(log2(a) / 2)` is a good first approximation of `sqrt(a)` with at least 1 correct bit.\\n        uint256 result = 1 << (log2(a) >> 1);\\n\\n        // At this point `result` is an estimation with one bit of precision. We know the true value is a uint128,\\n        // since it is the square root of a uint256. Newton's method converges quadratically (precision doubles at\\n        // every iteration). We thus need at most 7 iteration to turn our partial result with one bit of precision\\n        // into the expected uint128 result.\\n        unchecked {\\n            result = (result + a / result) >> 1;\\n            result = (result + a / result) >> 1;\\n            result = (result + a / result) >> 1;\\n            result = (result + a / result) >> 1;\\n            result = (result + a / result) >> 1;\\n            result = (result + a / result) >> 1;\\n            result = (result + a / result) >> 1;\\n            return min(result, a / result);\\n        }\\n    }\\n\\n    /**\\n     * @notice Calculates sqrt(a), following the selected rounding direction.\\n     */\\n    function sqrt(uint256 a, Rounding rounding) internal pure returns (uint256) {\\n        unchecked {\\n            uint256 result = sqrt(a);\\n            return result + (unsignedRoundsUp(rounding) && result * result < a ? 1 : 0);\\n        }\\n    }\\n\\n    /**\\n     * @dev Return the log in base 2 of a positive value rounded towards zero.\\n     * Returns 0 if given 0.\\n     */\\n    function log2(uint256 value) internal pure returns (uint256) {\\n        uint256 result = 0;\\n        unchecked {\\n            if (value >> 128 > 0) {\\n                value >>= 128;\\n                result += 128;\\n            }\\n            if (value >> 64 > 0) {\\n                value >>= 64;\\n                result += 64;\\n            }\\n            if (value >> 32 > 0) {\\n                value >>= 32;\\n                result += 32;\\n            }\\n            if (value >> 16 > 0) {\\n                value >>= 16;\\n                result += 16;\\n            }\\n            if (value >> 8 > 0) {\\n                value >>= 8;\\n                result += 8;\\n            }\\n            if (value >> 4 > 0) {\\n                value >>= 4;\\n                result += 4;\\n            }\\n            if (value >> 2 > 0) {\\n                value >>= 2;\\n                result += 2;\\n            }\\n            if (value >> 1 > 0) {\\n                result += 1;\\n            }\\n        }\\n        return result;\\n    }\\n\\n    /**\\n     * @dev Return the log in base 2, following the selected rounding direction, of a positive value.\\n     * Returns 0 if given 0.\\n     */\\n    function log2(uint256 value, Rounding rounding) internal pure returns (uint256) {\\n        unchecked {\\n            uint256 result = log2(value);\\n            return result + (unsignedRoundsUp(rounding) && 1 << result < value ? 1 : 0);\\n        }\\n    }\\n\\n    /**\\n     * @dev Return the log in base 10 of a positive value rounded towards zero.\\n     * Returns 0 if given 0.\\n     */\\n    function log10(uint256 value) internal pure returns (uint256) {\\n        uint256 result = 0;\\n        unchecked {\\n            if (value >= 10 ** 64) {\\n                value /= 10 ** 64;\\n                result += 64;\\n            }\\n            if (value >= 10 ** 32) {\\n                value /= 10 ** 32;\\n                result += 32;\\n            }\\n            if (value >= 10 ** 16) {\\n                value /= 10 ** 16;\\n                result += 16;\\n            }\\n            if (value >= 10 ** 8) {\\n                value /= 10 ** 8;\\n                result += 8;\\n            }\\n            if (value >= 10 ** 4) {\\n                value /= 10 ** 4;\\n                result += 4;\\n            }\\n            if (value >= 10 ** 2) {\\n                value /= 10 ** 2;\\n                result += 2;\\n            }\\n            if (value >= 10 ** 1) {\\n                result += 1;\\n            }\\n        }\\n        return result;\\n    }\\n\\n    /**\\n     * @dev Return the log in base 10, following the selected rounding direction, of a positive value.\\n     * Returns 0 if given 0.\\n     */\\n    function log10(uint256 value, Rounding rounding) internal pure returns (uint256) {\\n        unchecked {\\n            uint256 result = log10(value);\\n            return result + (unsignedRoundsUp(rounding) && 10 ** result < value ? 1 : 0);\\n        }\\n    }\\n\\n    /**\\n     * @dev Return the log in base 256 of a positive value rounded towards zero.\\n     * Returns 0 if given 0.\\n     *\\n     * Adding one to the result gives the number of pairs of hex symbols needed to represent `value` as a hex string.\\n     */\\n    function log256(uint256 value) internal pure returns (uint256) {\\n        uint256 result = 0;\\n        unchecked {\\n            if (value >> 128 > 0) {\\n                value >>= 128;\\n                result += 16;\\n            }\\n            if (value >> 64 > 0) {\\n                value >>= 64;\\n                result += 8;\\n            }\\n            if (value >> 32 > 0) {\\n                value >>= 32;\\n                result += 4;\\n            }\\n            if (value >> 16 > 0) {\\n                value >>= 16;\\n                result += 2;\\n            }\\n            if (value >> 8 > 0) {\\n                result += 1;\\n            }\\n        }\\n        return result;\\n    }\\n\\n    /**\\n     * @dev Return the log in base 256, following the selected rounding direction, of a positive value.\\n     * Returns 0 if given 0.\\n     */\\n    function log256(uint256 value, Rounding rounding) internal pure returns (uint256) {\\n        unchecked {\\n            uint256 result = log256(value);\\n            return result + (unsignedRoundsUp(rounding) && 1 << (result << 3) < value ? 1 : 0);\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns whether a provided rounding mode is considered rounding up for unsigned integers.\\n     */\\n    function unsignedRoundsUp(Rounding rounding) internal pure returns (bool) {\\n        return uint8(rounding) % 2 == 1;\\n    }\\n}\\n\",\"keccak256\":\"0x005ec64c6313f0555d59e278f9a7a5ab2db5bdc72a027f255a37c327af1ec02d\",\"license\":\"MIT\"},\"@openzeppelin/contracts/utils/math/SignedMath.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v5.0.0) (utils/math/SignedMath.sol)\\n\\npragma solidity ^0.8.20;\\n\\n/**\\n * @dev Standard signed math utilities missing in the Solidity language.\\n */\\nlibrary SignedMath {\\n    /**\\n     * @dev Returns the largest of two signed numbers.\\n     */\\n    function max(int256 a, int256 b) internal pure returns (int256) {\\n        return a > b ? a : b;\\n    }\\n\\n    /**\\n     * @dev Returns the smallest of two signed numbers.\\n     */\\n    function min(int256 a, int256 b) internal pure returns (int256) {\\n        return a < b ? a : b;\\n    }\\n\\n    /**\\n     * @dev Returns the average of two signed numbers without overflow.\\n     * The result is rounded towards zero.\\n     */\\n    function average(int256 a, int256 b) internal pure returns (int256) {\\n        // Formula from the book \\\"Hacker's Delight\\\"\\n        int256 x = (a & b) + ((a ^ b) >> 1);\\n        return x + (int256(uint256(x) >> 255) & (a ^ b));\\n    }\\n\\n    /**\\n     * @dev Returns the absolute unsigned value of a signed value.\\n     */\\n    function abs(int256 n) internal pure returns (uint256) {\\n        unchecked {\\n            // must be unchecked in order to support `n = type(int256).min`\\n            return uint256(n >= 0 ? n : -n);\\n        }\\n    }\\n}\\n\",\"keccak256\":\"0x5f7e4076e175393767754387c962926577f1660dd9b810187b9002407656be72\",\"license\":\"MIT\"},\"contracts/TwoFactorAuth.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.25;\\n\\nimport {Console} from \\\"@fhenixprotocol/contracts/utils/debug/Console.sol\\\";\\nimport \\\"@fhenixprotocol/contracts/FHE.sol\\\";\\nimport {Permissioned, Permission} from \\\"@fhenixprotocol/contracts/access/Permissioned.sol\\\";\\n\\n/**\\n * @title TwoFactorAuth\\n * @dev A smart contract for implementing a two-factor authentication (2FA) system.\\n * This contract allows users to register, request login, approve login, and verify temporary passwords.\\n */\\ncontract TwoFactorAuth is Permissioned {\\n  // Constants for time intervals\\n  uint256 public constant TIME_INTERVAL = 300; // 5 minutes\\n  uint256 public constant PASSWORD_VALIDITY_DURATION = 300; // 5 minutes\\n\\n  // Struct to hold authentication data for each user\\n  struct AuthData {\\n    uint256 lastRequestTime; // Timestamp of the last login request\\n    address secondarySigner; // Address of the secondary signer\\n    bool isApproved; // Indicates if the login request is approved\\n    uint256 lastApprovalTime; // Timestamp of the last approval\\n    euint256 encryptedPassword; // Encrypted temporary password\\n    bytes32 userPublicKey; // Public key of the user for encryption\\n    uint256 validUntil; // Timestamp until which the password is valid\\n    uint8 passwordAttempts; // Number of attempts to enter the password\\n    bool passwordUsed; // Indicates if the password has been used\\n  }\\n\\n  // State variables\\n  address owner;\\n  mapping(address => AuthData) public authData; // Mapping of user addresses to their authentication data\\n  mapping(address => bool) public whitelistedServices; // Mapping of whitelisted services\\n\\n  // Events\\n  event Registered(address indexed user, address indexed secondarySigner); // Emitted when a user registers\\n  event LoginRequested(address indexed user); // Emitted when a login request is made\\n  event LoginApproved(address indexed user, address indexed secondarySigner); // Emitted when a login is approved\\n\\n  // Constructor to set the owner\\n  constructor(address _owner) Permissioned() {\\n    owner = _owner;\\n  }\\n\\n  /**\\n   * @dev Registers a user with a secondary signer and user public key.\\n   * @param perm The permission object for access control.\\n   * @param _secondarySigner The address of the secondary signer.\\n   */\\n  function register(\\n    Permission calldata perm,\\n    address _secondarySigner\\n  ) external onlySender(perm) {\\n    require(_secondarySigner != address(0), \\\"Invalid secondary signer address\\\");\\n    require(\\n      _secondarySigner != msg.sender,\\n      \\\"Secondary signer cannot be the same as the primary user\\\"\\n    );\\n\\n    // Store authentication data for the user\\n    authData[msg.sender] = AuthData({\\n      lastRequestTime: 0,\\n      secondarySigner: _secondarySigner,\\n      isApproved: false,\\n      lastApprovalTime: 0,\\n      encryptedPassword: FHE.asEuint256(0),\\n      userPublicKey: perm.publicKey,\\n      validUntil: 0,\\n      passwordAttempts: 0,\\n      passwordUsed: false\\n    });\\n\\n    emit Registered(msg.sender, _secondarySigner);\\n  }\\n\\n  /**\\n   * @dev Requests a login, resetting the approval status.\\n   */\\n  function requestLogin() external {\\n    AuthData storage data = authData[msg.sender];\\n    require(data.secondarySigner != address(0), \\\"User not registered\\\");\\n    require(\\n      block.timestamp > data.lastRequestTime + TIME_INTERVAL || data.isApproved,\\n      \\\"Previous login request still pending\\\"\\n    );\\n\\n    // Update request time and reset approval status\\n    data.lastRequestTime = block.timestamp;\\n    data.isApproved = false;\\n    data.passwordAttempts = 0;\\n    data.passwordUsed = false;\\n\\n    emit LoginRequested(msg.sender);\\n  }\\n\\n  /**\\n   * @dev Approves a login request from the secondary signer.\\n   * @param _user The address of the user requesting login.\\n   */\\n  function approveLogin(\\n    address _user,\\n    inEuint256 calldata _tempPassword\\n  ) external {\\n    AuthData storage data = authData[_user];\\n    require(msg.sender == data.secondarySigner, \\\"Not authorized\\\");\\n    require(\\n      block.timestamp <= data.lastRequestTime + TIME_INTERVAL,\\n      \\\"Time interval expired\\\"\\n    );\\n\\n    // Update approval status and generate a temporary password\\n    data.isApproved = true;\\n    data.lastApprovalTime = block.timestamp;\\n\\n    data.encryptedPassword = FHE.asEuint256(_tempPassword);\\n    data.validUntil = block.timestamp + PASSWORD_VALIDITY_DURATION; // Set validity duration\\n\\n    emit LoginApproved(_user, msg.sender);\\n  }\\n\\n  /**\\n   * @dev Retrieves the encrypted password for a user.\\n   * @return encryptedPassword The sealed encrypted password.\\n   */\\n  function getEncryptedPassword()\\n    external\\n    view\\n    returns (string memory encryptedPassword)\\n  {\\n    AuthData storage data = authData[msg.sender];\\n\\n    // Check if the user is registered and approved\\n    require(data.secondarySigner != address(0), \\\"User not registered\\\");\\n    require(data.isApproved, \\\"Login not approved\\\");\\n\\n    return data.encryptedPassword.seal(data.userPublicKey);\\n  }\\n\\n  /**\\n   * @dev Verifies the temporary password for a user by a whitelisted service.\\n   * @param perm The permission object for access control.\\n   * @param _service The address of the service verifying the password.\\n   * @param _user The address of the user.\\n   * @param _encryptedTempPassword The encrypted temporary password provided by the service.\\n   * @return True if the password is valid, false otherwise.\\n   */\\n  function verifyTempPassword(\\n    Permission calldata perm,\\n    address _service,\\n    address _user,\\n    inEuint256 calldata _encryptedTempPassword\\n  ) external onlyPermitted(perm, _service) returns (bool) {\\n    require(whitelistedServices[_service], \\\"Service not whitelisted\\\"); // Check if the service is whitelisted\\n\\n    AuthData storage data = authData[_user];\\n    require(data.isApproved, \\\"Login not approved\\\");\\n    require(block.timestamp <= data.validUntil, \\\"Password has expired\\\"); // Check if the password is still valid\\n    require(!data.passwordUsed, \\\"Password has been used\\\"); // Check if the password has been used too many times\\n    require(data.passwordAttempts < 3, \\\"Too many attempts\\\"); // Check if the password has been used too many times\\n\\n    // Compare the decrypted passwords\\n    euint256 encryptedTempPassword = FHE.asEuint256(_encryptedTempPassword);\\n    ebool encryptedIsValid = FHE.eq(\\n      encryptedTempPassword,\\n      data.encryptedPassword\\n    );\\n    bool isValid = FHE.decrypt(encryptedIsValid);\\n\\n    if (!isValid) {\\n      data.passwordUsed = true;\\n      data.passwordAttempts = 0;\\n    } else {\\n      data.passwordAttempts++;\\n    }\\n\\n    return isValid;\\n  }\\n\\n  /**\\n   * @dev Adds a service to the whitelist.\\n   * @param perm The permission object for access control.\\n   * @param service The address of the service to be added.\\n   */\\n  function addServiceToWhitelist(\\n    Permission calldata perm,\\n    address service\\n  ) external onlyPermitted(perm, owner) {\\n    whitelistedServices[service] = true;\\n  }\\n\\n  /**\\n   * @dev Removes a service from the whitelist.\\n   * @param perm The permission object for access control.\\n   * @param service The address of the service to be removed.\\n   */\\n  function removeServiceFromWhitelist(\\n    Permission calldata perm,\\n    address service\\n  ) external onlyPermitted(perm, owner) {\\n    whitelistedServices[service] = false;\\n  }\\n}\\n\",\"keccak256\":\"0x0323237dc5548995b45044317557e268b3c9ab3625a07d7ab435da64442fbfc5\",\"license\":\"MIT\"}},\"version\":1}",
  "bytecode": "0x61016060405234801561001157600080fd5b5060405161394b38038061394b83398181016040528101906100339190610310565b6040518060400160405280601181526020017f4668656e6978205065726d697373696f6e0000000000000000000000000000008152506040518060400160405280600381526020017f312e3000000000000000000000000000000000000000000000000000000000008152506100b360008361019060201b90919060201c565b61012081815250506100cf60018261019060201b90919060201c565b6101408181525050818051906020012060e08181525050808051906020012061010081815250504660a0818152505061010c6101e060201b60201c565b608081815250503073ffffffffffffffffffffffffffffffffffffffff1660c08173ffffffffffffffffffffffffffffffffffffffff1681525050505080600260006101000a81548173ffffffffffffffffffffffffffffffffffffffff021916908373ffffffffffffffffffffffffffffffffffffffff16021790555050610827565b60006020835110156101b2576101ab8361023b60201b60201c565b90506101da565b826101c2836102a360201b60201c565b60000190816101d1919061058d565b5060ff60001b90505b92915050565b60007f8b73c3c69bb8fe3d512ecc4cf759cc79239f7b179b0ffacaa9a75d522b39400f60e051610100514630604051602001610220959493929190610696565b60405160208183030381529060405280519060200120905090565b600080829050601f8151111561028857826040517f305a27a900000000000000000000000000000000000000000000000000000000815260040161027f919061076e565b60405180910390fd5b805181610294906107c0565b60001c1760001b915050919050565b6000819050919050565b600080fd5b600073ffffffffffffffffffffffffffffffffffffffff82169050919050565b60006102dd826102b2565b9050919050565b6102ed816102d2565b81146102f857600080fd5b50565b60008151905061030a816102e4565b92915050565b600060208284031215610326576103256102ad565b5b6000610334848285016102fb565b91505092915050565b600081519050919050565b7f4e487b7100000000000000000000000000000000000000000000000000000000600052604160045260246000fd5b7f4e487b7100000000000000000000000000000000000000000000000000000000600052602260045260246000fd5b600060028204905060018216806103be57607f821691505b6020821081036103d1576103d0610377565b5b50919050565b60008190508160005260206000209050919050565b60006020601f8301049050919050565b600082821b905092915050565b6000600883026104397fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff826103fc565b61044386836103fc565b95508019841693508086168417925050509392505050565b6000819050919050565b6000819050919050565b600061048a6104856104808461045b565b610465565b61045b565b9050919050565b6000819050919050565b6104a48361046f565b6104b86104b082610491565b848454610409565b825550505050565b600090565b6104cd6104c0565b6104d881848461049b565b505050565b5b818110156104fc576104f16000826104c5565b6001810190506104de565b5050565b601f82111561054157610512816103d7565b61051b846103ec565b8101602085101561052a578190505b61053e610536856103ec565b8301826104dd565b50505b505050565b600082821c905092915050565b600061056460001984600802610546565b1980831691505092915050565b600061057d8383610553565b9150826002028217905092915050565b6105968261033d565b67ffffffffffffffff8111156105af576105ae610348565b5b6105b982546103a6565b6105c4828285610500565b600060209050601f8311600181146105f757600084156105e5578287015190505b6105ef8582610571565b865550610657565b601f198416610605866103d7565b60005b8281101561062d57848901518255600182019150602085019450602081019050610608565b8683101561064a5784890151610646601f891682610553565b8355505b6001600288020188555050505b505050505050565b6000819050919050565b6106728161065f565b82525050565b6106818161045b565b82525050565b610690816102d2565b82525050565b600060a0820190506106ab6000830188610669565b6106b86020830187610669565b6106c56040830186610669565b6106d26060830185610678565b6106df6080830184610687565b9695505050505050565b600082825260208201905092915050565b60005b838110156107185780820151818401526020810190506106fd565b60008484015250505050565b6000601f19601f8301169050919050565b60006107408261033d565b61074a81856106e9565b935061075a8185602086016106fa565b61076381610724565b840191505092915050565b600060208201905081810360008301526107888184610735565b905092915050565b600081519050919050565b6000819050602082019050919050565b60006107b7825161065f565b80915050919050565b60006107cb82610790565b826107d58461079b565b90506107e0816107ab565b925060208210156108205761081b7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff836020036008026103fc565b831692505b5050919050565b60805160a05160c05160e0516101005161012051610140516130ca61088160003960006113790152600061133e01526000611ad401526000611ab301526000611513015260006115690152600061159201526130ca6000f3fe608060405234801561001057600080fd5b50600436106100b45760003560e01c806384b0196e1161007157806384b0196e1461016d578063b75d192414610191578063cb41cf64146101c1578063d420e518146101f1578063e9bb37a01461020d578063fdfd7c981461022b576100b4565b80631e76c6b4146100b95780632412d95d146100f1578063283783521461010f57806335629fb1146101195780634dae80241461013557806355874a9914610151575b600080fd5b6100d360048036038101906100ce9190611eba565b610249565b6040516100e899989796959493929190611f9a565b60405180910390f35b6100f96102de565b6040516101069190612027565b60405180910390f35b6101176102e4565b005b610133600480360381019061012e9190612066565b6104cd565b005b61014f600480360381019061014a9190612066565b61062a565b005b61016b600480360381019061016691906120e1565b610787565b005b610175610965565b60405161018897969594939291906122c6565b60405180910390f35b6101ab60048036038101906101a6919061234a565b610a0f565b6040516101b891906123e9565b60405180910390f35b6101db60048036038101906101d69190611eba565b610dc4565b6040516101e891906123e9565b60405180910390f35b61020b60048036038101906102069190612066565b610de4565b005b610215611189565b6040516102229190612027565b60405180910390f35b61023361118f565b6040516102409190612404565b60405180910390f35b60036020528060005260406000206000915090508060000154908060010160009054906101000a900473ffffffffffffffffffffffffffffffffffffffff16908060010160149054906101000a900460ff16908060020154908060030154908060040154908060050154908060060160009054906101000a900460ff16908060060160019054906101000a900460ff16905089565b61012c81565b6000600360003373ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff1681526020019081526020016000209050600073ffffffffffffffffffffffffffffffffffffffff168160010160009054906101000a900473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16036103ba576040517f08c379a00000000000000000000000000000000000000000000000000000000081526004016103b190612472565b60405180910390fd5b61012c81600001546103cc91906124c1565b4211806103e757508060010160149054906101000a900460ff165b610426576040517f08c379a000000000000000000000000000000000000000000000000000000000815260040161041d90612567565b60405180910390fd5b42816000018190555060008160010160146101000a81548160ff02191690831515021790555060008160060160006101000a81548160ff021916908360ff16021790555060008160060160016101000a81548160ff0219169083151502179055503373ffffffffffffffffffffffffffffffffffffffff167f5551f52823ba301440592c9fc2e93c6a6fb8d0cd41bd1cfa6f020b59400695fa60405160405180910390a250565b816104d79061275e565b600260009054906101000a900473ffffffffffffffffffffffffffffffffffffffff1660006105517f6bdaeb2d29561f159c7ef98b16b27015fb2aeb87209c7ee656226d912f59927d8460000151604051602001610536929190612771565b604051602081830303815290604052805190602001206112d9565b905060006105638285602001516112f3565b90508273ffffffffffffffffffffffffffffffffffffffff168173ffffffffffffffffffffffffffffffffffffffff16146105ca576040517f51c65eae00000000000000000000000000000000000000000000000000000000815260040160405180910390fd5b6001600460008773ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16815260200190815260200160002060006101000a81548160ff021916908315150217905550505050505050565b816106349061275e565b600260009054906101000a900473ffffffffffffffffffffffffffffffffffffffff1660006106ae7f6bdaeb2d29561f159c7ef98b16b27015fb2aeb87209c7ee656226d912f59927d8460000151604051602001610693929190612771565b604051602081830303815290604052805190602001206112d9565b905060006106c08285602001516112f3565b90508273ffffffffffffffffffffffffffffffffffffffff168173ffffffffffffffffffffffffffffffffffffffff1614610727576040517f51c65eae00000000000000000000000000000000000000000000000000000000815260040160405180910390fd5b6000600460008773ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16815260200190815260200160002060006101000a81548160ff021916908315150217905550505050505050565b6000600360008473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16815260200190815260200160002090508060010160009054906101000a900473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff163373ffffffffffffffffffffffffffffffffffffffff161461085c576040517f08c379a0000000000000000000000000000000000000000000000000000000008152600401610853906127e6565b60405180910390fd5b61012c816000015461086e91906124c1565b4211156108b0576040517f08c379a00000000000000000000000000000000000000000000000000000000081526004016108a790612852565b60405180910390fd5b60018160010160146101000a81548160ff0219169083151502179055504281600201819055506108e8826108e3906128ca565b61131f565b816003018190555061012c426108fe91906124c1565b81600501819055503373ffffffffffffffffffffffffffffffffffffffff168373ffffffffffffffffffffffffffffffffffffffff167f9331a3c7a93bcdc2ae741e8ba8b724b1952cc8d3590b749a60490cfb10f2822260405160405180910390a3505050565b600060608060008060006060610979611335565b610981611370565b46306000801b600067ffffffffffffffff8111156109a2576109a161258c565b5b6040519080825280602002602001820160405280156109d05781602001602082028036833780820191505090505b507f0f00000000000000000000000000000000000000000000000000000000000000959493929190965096509650965096509650965090919293949596565b600084610a1b9061275e565b846000610a737f6bdaeb2d29561f159c7ef98b16b27015fb2aeb87209c7ee656226d912f59927d8460000151604051602001610a58929190612771565b604051602081830303815290604052805190602001206112d9565b90506000610a858285602001516112f3565b90508273ffffffffffffffffffffffffffffffffffffffff168173ffffffffffffffffffffffffffffffffffffffff1614610aec576040517f51c65eae00000000000000000000000000000000000000000000000000000000815260040160405180910390fd5b600460008973ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16815260200190815260200160002060009054906101000a900460ff16610b78576040517f08c379a0000000000000000000000000000000000000000000000000000000008152600401610b6f90612929565b60405180910390fd5b6000600360008973ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16815260200190815260200160002090508060010160149054906101000a900460ff16610c0c576040517f08c379a0000000000000000000000000000000000000000000000000000000008152600401610c0390612995565b60405180910390fd5b8060050154421115610c53576040517f08c379a0000000000000000000000000000000000000000000000000000000008152600401610c4a90612a01565b60405180910390fd5b8060060160019054906101000a900460ff1615610ca5576040517f08c379a0000000000000000000000000000000000000000000000000000000008152600401610c9c90612a6d565b60405180910390fd5b60038160060160009054906101000a900460ff1660ff1610610cfc576040517f08c379a0000000000000000000000000000000000000000000000000000000008152600401610cf390612ad9565b60405180910390fd5b6000610d1088610d0b906128ca565b61131f565b90506000610d228284600301546113ab565b90506000610d2f82611424565b905080610d765760018460060160016101000a81548160ff02191690831515021790555060008460060160006101000a81548160ff021916908360ff160217905550610db1565b83600601600081819054906101000a900460ff1680929190610d9790612af9565b91906101000a81548160ff021916908360ff160217905550505b8098505050505050505050949350505050565b60046020528060005260406000206000915054906101000a900460ff1681565b81610dee9061275e565b6000610e457f6bdaeb2d29561f159c7ef98b16b27015fb2aeb87209c7ee656226d912f59927d8360000151604051602001610e2a929190612771565b604051602081830303815290604052805190602001206112d9565b90506000610e578284602001516112f3565b90503373ffffffffffffffffffffffffffffffffffffffff168173ffffffffffffffffffffffffffffffffffffffff1614610ebe576040517f3093a27700000000000000000000000000000000000000000000000000000000815260040160405180910390fd5b600073ffffffffffffffffffffffffffffffffffffffff168473ffffffffffffffffffffffffffffffffffffffff1603610f2d576040517f08c379a0000000000000000000000000000000000000000000000000000000008152600401610f2490612b6e565b60405180910390fd5b3373ffffffffffffffffffffffffffffffffffffffff168473ffffffffffffffffffffffffffffffffffffffff1603610f9b576040517f08c379a0000000000000000000000000000000000000000000000000000000008152600401610f9290612c00565b60405180910390fd5b604051806101200160405280600081526020018573ffffffffffffffffffffffffffffffffffffffff16815260200160001515815260200160008152602001610fe460006114e7565b81526020018660000135815260200160008152602001600060ff16815260200160001515815250600360003373ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff1681526020019081526020016000206000820151816000015560208201518160010160006101000a81548173ffffffffffffffffffffffffffffffffffffffff021916908373ffffffffffffffffffffffffffffffffffffffff16021790555060408201518160010160146101000a81548160ff021916908315150217905550606082015181600201556080820151816003015560a0820151816004015560c0820151816005015560e08201518160060160006101000a81548160ff021916908360ff1602179055506101008201518160060160016101000a81548160ff0219169083151502179055509050508373ffffffffffffffffffffffffffffffffffffffff163373ffffffffffffffffffffffffffffffffffffffff167f0a31ee9d46a828884b81003c8498156ea6aa15b9b54bdd0ef0b533d9eba57e5560405160405180910390a35050505050565b61012c81565b60606000600360003373ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff1681526020019081526020016000209050600073ffffffffffffffffffffffffffffffffffffffff168160010160009054906101000a900473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff1603611267576040517f08c379a000000000000000000000000000000000000000000000000000000000815260040161125e90612472565b60405180910390fd5b8060010160149054906101000a900460ff166112b8576040517f08c379a00000000000000000000000000000000000000000000000000000000081526004016112af90612995565b60405180910390fd5b6112d3816004015482600301546114fb90919063ffffffff16565b91505090565b60006112ec6112e661150f565b836115c6565b9050919050565b6000806000806113038686611607565b9250925092506113138282611663565b82935050505092915050565b600061132e82600001516117c7565b9050919050565b606061136b60007f00000000000000000000000000000000000000000000000000000000000000006117db90919063ffffffff16565b905090565b60606113a660017f00000000000000000000000000000000000000000000000000000000000000006117db90919063ffffffff16565b905090565b60006113b68361188b565b6113c7576113c460006114e7565b92505b6113d08261188b565b6113e1576113de60006114e7565b91505b60008390506000839050600061141660058484608073ffffffffffffffffffffffffffffffffffffffff166392348b34611898565b905080935050505092915050565b600061142f8261192c565b6114405761143d6000611939565b91505b600082905060006114508261194d565b90506000608073ffffffffffffffffffffffffffffffffffffffff166373cc0154600d846040518363ffffffff1660e01b8152600401611491929190612c75565b602060405180830381865afa1580156114ae573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906114d29190612cd1565b90506114dd816119aa565b9350505050919050565b60006114f48260056119b6565b9050919050565b60606115078383611a58565b905092915050565b60007f000000000000000000000000000000000000000000000000000000000000000073ffffffffffffffffffffffffffffffffffffffff163073ffffffffffffffffffffffffffffffffffffffff1614801561158b57507f000000000000000000000000000000000000000000000000000000000000000046145b156115b8577f000000000000000000000000000000000000000000000000000000000000000090506115c3565b6115c0611a8e565b90505b90565b60006040517f190100000000000000000000000000000000000000000000000000000000000081528360028201528260228201526042812091505092915050565b6000806000604184510361164c5760008060006020870151925060408701519150606087015160001a905061163e88828585611b24565b95509550955050505061165c565b60006002855160001b9250925092505b9250925092565b6000600381111561167757611676612cfe565b5b82600381111561168a57611689612cfe565b5b03156117c357600160038111156116a4576116a3612cfe565b5b8260038111156116b7576116b6612cfe565b5b036116ee576040517ff645eedf00000000000000000000000000000000000000000000000000000000815260040160405180910390fd5b6002600381111561170257611701612cfe565b5b82600381111561171557611714612cfe565b5b0361175a578060001c6040517ffce698f70000000000000000000000000000000000000000000000000000000081526004016117519190612027565b60405180910390fd5b60038081111561176d5761176c612cfe565b5b8260038111156117805761177f612cfe565b5b036117c257806040517fd78bce0c0000000000000000000000000000000000000000000000000000000081526004016117b99190612d2d565b60405180910390fd5b5b5050565b60006117d4826005611c18565b9050919050565b606060ff60001b83146117f8576117f183611cb2565b9050611885565b81805461180490612d77565b80601f016020809104026020016040519081016040528092919081815260200182805461183090612d77565b801561187d5780601f106118525761010080835404028352916020019161187d565b820191906000526020600020905b81548152906001019060200180831161186057829003601f168201915b505050505090505b92915050565b6000808214159050919050565b600060608383886118a88961194d565b6118b18961194d565b6040518463ffffffff1660e01b81526004016118cf93929190612da8565b600060405180830381865afa1580156118ec573d6000803e3d6000fd5b505050506040513d6000823e3d601f19601f820116820180604052508101906119159190612e5d565b905061192081611d26565b91505095945050505050565b6000808214159050919050565b600061194682600d6119b6565b9050919050565b6060602067ffffffffffffffff81111561196a5761196961258c565b5b6040519080825280601f01601f19166020018201604052801561199c5781602001600182028036833780820191505090505b509050816020820152919050565b60008082119050919050565b60006060608073ffffffffffffffffffffffffffffffffffffffff166319e1c5c46119e08661194d565b856040518363ffffffff1660e01b81526004016119fe929190612ea6565b600060405180830381865afa158015611a1b573d6000803e3d6000fd5b505050506040513d6000823e3d601f19601f82011682018060405250810190611a449190612e5d565b9050611a4f81611d34565b91505092915050565b6060611a638361188b565b611a7457611a7160006114e7565b92505b6000839050611a8560058285611d42565b91505092915050565b60007f8b73c3c69bb8fe3d512ecc4cf759cc79239f7b179b0ffacaa9a75d522b39400f7f00000000000000000000000000000000000000000000000000000000000000007f00000000000000000000000000000000000000000000000000000000000000004630604051602001611b09959493929190612ed6565b60405160208183030381529060405280519060200120905090565b60008060007f7fffffffffffffffffffffffffffffff5d576e7357a4501ddfe92f46681b20a08460001c1115611b64576000600385925092509250611c0e565b600060018888888860405160008152602001604052604051611b899493929190612f29565b6020604051602081039080840390855afa158015611bab573d6000803e3d6000fd5b505050602060405103519050600073ffffffffffffffffffffffffffffffffffffffff168173ffffffffffffffffffffffffffffffffffffffff1603611bff57600060016000801b93509350935050611c0e565b8060008060001b935093509350505b9450945094915050565b60006060608073ffffffffffffffffffffffffffffffffffffffff16635fa55ca784866040518363ffffffff1660e01b8152600401611c58929190612c75565b600060405180830381865afa158015611c75573d6000803e3d6000fd5b505050506040513d6000823e3d601f19601f82011682018060405250810190611c9e9190612e5d565b9050611ca981611d34565b91505092915050565b60606000611cbf83611df8565b90506000602067ffffffffffffffff811115611cde57611cdd61258c565b5b6040519080825280601f01601f191660200182016040528015611d105781602001600182028036833780820191505090505b5090508181528360208201528092505050919050565b600060208201519050919050565b600060208201519050919050565b6060608073ffffffffffffffffffffffffffffffffffffffff1663a1848ff385611d6b8661194d565b85604051602001611d7c9190612f8f565b6040516020818303038152906040526040518463ffffffff1660e01b8152600401611da993929190612da8565b600060405180830381865afa158015611dc6573d6000803e3d6000fd5b505050506040513d6000823e3d601f19601f82011682018060405250810190611def919061304b565b90509392505050565b60008060ff8360001c169050601f811115611e3f576040517fb3512b0c00000000000000000000000000000000000000000000000000000000815260040160405180910390fd5b80915050919050565b6000604051905090565b600080fd5b600080fd5b600073ffffffffffffffffffffffffffffffffffffffff82169050919050565b6000611e8782611e5c565b9050919050565b611e9781611e7c565b8114611ea257600080fd5b50565b600081359050611eb481611e8e565b92915050565b600060208284031215611ed057611ecf611e52565b5b6000611ede84828501611ea5565b91505092915050565b6000819050919050565b611efa81611ee7565b82525050565b611f0981611e7c565b82525050565b60008115159050919050565b611f2481611f0f565b82525050565b6000819050919050565b6000611f4f611f4a611f4584611ee7565b611f2a565b611ee7565b9050919050565b611f5f81611f34565b82525050565b6000819050919050565b611f7881611f65565b82525050565b600060ff82169050919050565b611f9481611f7e565b82525050565b600061012082019050611fb0600083018c611ef1565b611fbd602083018b611f00565b611fca604083018a611f1b565b611fd76060830189611ef1565b611fe46080830188611f56565b611ff160a0830187611f6f565b611ffe60c0830186611ef1565b61200b60e0830185611f8b565b612019610100830184611f1b565b9a9950505050505050505050565b600060208201905061203c6000830184611ef1565b92915050565b600080fd5b60006040828403121561205d5761205c612042565b5b81905092915050565b6000806040838503121561207d5761207c611e52565b5b600083013567ffffffffffffffff81111561209b5761209a611e57565b5b6120a785828601612047565b92505060206120b885828601611ea5565b9150509250929050565b6000602082840312156120d8576120d7612042565b5b81905092915050565b600080604083850312156120f8576120f7611e52565b5b600061210685828601611ea5565b925050602083013567ffffffffffffffff81111561212757612126611e57565b5b612133858286016120c2565b9150509250929050565b60007fff0000000000000000000000000000000000000000000000000000000000000082169050919050565b6121728161213d565b82525050565b600081519050919050565b600082825260208201905092915050565b60005b838110156121b2578082015181840152602081019050612197565b60008484015250505050565b6000601f19601f8301169050919050565b60006121da82612178565b6121e48185612183565b93506121f4818560208601612194565b6121fd816121be565b840191505092915050565b600081519050919050565b600082825260208201905092915050565b6000819050602082019050919050565b61223d81611ee7565b82525050565b600061224f8383612234565b60208301905092915050565b6000602082019050919050565b600061227382612208565b61227d8185612213565b935061228883612224565b8060005b838110156122b95781516122a08882612243565b97506122ab8361225b565b92505060018101905061228c565b5085935050505092915050565b600060e0820190506122db600083018a612169565b81810360208301526122ed81896121cf565b9050818103604083015261230181886121cf565b90506123106060830187611ef1565b61231d6080830186611f00565b61232a60a0830185611f6f565b81810360c083015261233c8184612268565b905098975050505050505050565b6000806000806080858703121561236457612363611e52565b5b600085013567ffffffffffffffff81111561238257612381611e57565b5b61238e87828801612047565b945050602061239f87828801611ea5565b93505060406123b087828801611ea5565b925050606085013567ffffffffffffffff8111156123d1576123d0611e57565b5b6123dd878288016120c2565b91505092959194509250565b60006020820190506123fe6000830184611f1b565b92915050565b6000602082019050818103600083015261241e81846121cf565b905092915050565b7f55736572206e6f74207265676973746572656400000000000000000000000000600082015250565b600061245c601383612183565b915061246782612426565b602082019050919050565b6000602082019050818103600083015261248b8161244f565b9050919050565b7f4e487b7100000000000000000000000000000000000000000000000000000000600052601160045260246000fd5b60006124cc82611ee7565b91506124d783611ee7565b92508282019050808211156124ef576124ee612492565b5b92915050565b7f50726576696f7573206c6f67696e2072657175657374207374696c6c2070656e60008201527f64696e6700000000000000000000000000000000000000000000000000000000602082015250565b6000612551602483612183565b915061255c826124f5565b604082019050919050565b6000602082019050818103600083015261258081612544565b9050919050565b600080fd5b7f4e487b7100000000000000000000000000000000000000000000000000000000600052604160045260246000fd5b6125c4826121be565b810181811067ffffffffffffffff821117156125e3576125e261258c565b5b80604052505050565b60006125f6611e48565b905061260282826125bb565b919050565b600080fd5b61261581611f65565b811461262057600080fd5b50565b6000813590506126328161260c565b92915050565b600080fd5b600080fd5b600067ffffffffffffffff82111561265d5761265c61258c565b5b612666826121be565b9050602081019050919050565b82818337600083830152505050565b600061269561269084612642565b6125ec565b9050828152602081018484840111156126b1576126b061263d565b5b6126bc848285612673565b509392505050565b600082601f8301126126d9576126d8612638565b5b81356126e9848260208601612682565b91505092915050565b60006040828403121561270857612707612587565b5b61271260406125ec565b9050600061272284828501612623565b600083015250602082013567ffffffffffffffff81111561274657612745612607565b5b612752848285016126c4565b60208301525092915050565b600061276a36836126f2565b9050919050565b60006040820190506127866000830185611f6f565b6127936020830184611f6f565b9392505050565b7f4e6f7420617574686f72697a6564000000000000000000000000000000000000600082015250565b60006127d0600e83612183565b91506127db8261279a565b602082019050919050565b600060208201905081810360008301526127ff816127c3565b9050919050565b7f54696d6520696e74657276616c20657870697265640000000000000000000000600082015250565b600061283c601583612183565b915061284782612806565b602082019050919050565b6000602082019050818103600083015261286b8161282f565b9050919050565b60006020828403121561288857612887612587565b5b61289260206125ec565b9050600082013567ffffffffffffffff8111156128b2576128b1612607565b5b6128be848285016126c4565b60008301525092915050565b60006128d63683612872565b9050919050565b7f53657276696365206e6f742077686974656c6973746564000000000000000000600082015250565b6000612913601783612183565b915061291e826128dd565b602082019050919050565b6000602082019050818103600083015261294281612906565b9050919050565b7f4c6f67696e206e6f7420617070726f7665640000000000000000000000000000600082015250565b600061297f601283612183565b915061298a82612949565b602082019050919050565b600060208201905081810360008301526129ae81612972565b9050919050565b7f50617373776f7264206861732065787069726564000000000000000000000000600082015250565b60006129eb601483612183565b91506129f6826129b5565b602082019050919050565b60006020820190508181036000830152612a1a816129de565b9050919050565b7f50617373776f726420686173206265656e207573656400000000000000000000600082015250565b6000612a57601683612183565b9150612a6282612a21565b602082019050919050565b60006020820190508181036000830152612a8681612a4a565b9050919050565b7f546f6f206d616e7920617474656d707473000000000000000000000000000000600082015250565b6000612ac3601183612183565b9150612ace82612a8d565b602082019050919050565b60006020820190508181036000830152612af281612ab6565b9050919050565b6000612b0482611f7e565b915060ff8203612b1757612b16612492565b5b600182019050919050565b7f496e76616c6964207365636f6e64617279207369676e65722061646472657373600082015250565b6000612b58602083612183565b9150612b6382612b22565b602082019050919050565b60006020820190508181036000830152612b8781612b4b565b9050919050565b7f5365636f6e64617279207369676e65722063616e6e6f7420626520746865207360008201527f616d6520617320746865207072696d6172792075736572000000000000000000602082015250565b6000612bea603783612183565b9150612bf582612b8e565b604082019050919050565b60006020820190508181036000830152612c1981612bdd565b9050919050565b600081519050919050565b600082825260208201905092915050565b6000612c4782612c20565b612c518185612c2b565b9350612c61818560208601612194565b612c6a816121be565b840191505092915050565b6000604082019050612c8a6000830185611f8b565b8181036020830152612c9c8184612c3c565b90509392505050565b612cae81611ee7565b8114612cb957600080fd5b50565b600081519050612ccb81612ca5565b92915050565b600060208284031215612ce757612ce6611e52565b5b6000612cf584828501612cbc565b91505092915050565b7f4e487b7100000000000000000000000000000000000000000000000000000000600052602160045260246000fd5b6000602082019050612d426000830184611f6f565b92915050565b7f4e487b7100000000000000000000000000000000000000000000000000000000600052602260045260246000fd5b60006002820490506001821680612d8f57607f821691505b602082108103612da257612da1612d48565b5b50919050565b6000606082019050612dbd6000830186611f8b565b8181036020830152612dcf8185612c3c565b90508181036040830152612de38184612c3c565b9050949350505050565b6000612e00612dfb84612642565b6125ec565b905082815260208101848484011115612e1c57612e1b61263d565b5b612e27848285612194565b509392505050565b600082601f830112612e4457612e43612638565b5b8151612e54848260208601612ded565b91505092915050565b600060208284031215612e7357612e72611e52565b5b600082015167ffffffffffffffff811115612e9157612e90611e57565b5b612e9d84828501612e2f565b91505092915050565b60006040820190508181036000830152612ec08185612c3c565b9050612ecf6020830184611f8b565b9392505050565b600060a082019050612eeb6000830188611f6f565b612ef86020830187611f6f565b612f056040830186611f6f565b612f126060830185611ef1565b612f1f6080830184611f00565b9695505050505050565b6000608082019050612f3e6000830187611f6f565b612f4b6020830186611f8b565b612f586040830185611f6f565b612f656060830184611f6f565b95945050505050565b6000819050919050565b612f89612f8482611f65565b612f6e565b82525050565b6000612f9b8284612f78565b60208201915081905092915050565b600067ffffffffffffffff821115612fc557612fc461258c565b5b612fce826121be565b9050602081019050919050565b6000612fee612fe984612faa565b6125ec565b90508281526020810184848401111561300a5761300961263d565b5b613015848285612194565b509392505050565b600082601f83011261303257613031612638565b5b8151613042848260208601612fdb565b91505092915050565b60006020828403121561306157613060611e52565b5b600082015167ffffffffffffffff81111561307f5761307e611e57565b5b61308b8482850161301d565b9150509291505056fea2646970667358221220fe5434d99175ec7d43e58f4e0c6986f33fcbdc2810cecd874ac910df87b8253964736f6c63430008190033",
  "deployedBytecode": "0x608060405234801561001057600080fd5b50600436106100b45760003560e01c806384b0196e1161007157806384b0196e1461016d578063b75d192414610191578063cb41cf64146101c1578063d420e518146101f1578063e9bb37a01461020d578063fdfd7c981461022b576100b4565b80631e76c6b4146100b95780632412d95d146100f1578063283783521461010f57806335629fb1146101195780634dae80241461013557806355874a9914610151575b600080fd5b6100d360048036038101906100ce9190611eba565b610249565b6040516100e899989796959493929190611f9a565b60405180910390f35b6100f96102de565b6040516101069190612027565b60405180910390f35b6101176102e4565b005b610133600480360381019061012e9190612066565b6104cd565b005b61014f600480360381019061014a9190612066565b61062a565b005b61016b600480360381019061016691906120e1565b610787565b005b610175610965565b60405161018897969594939291906122c6565b60405180910390f35b6101ab60048036038101906101a6919061234a565b610a0f565b6040516101b891906123e9565b60405180910390f35b6101db60048036038101906101d69190611eba565b610dc4565b6040516101e891906123e9565b60405180910390f35b61020b60048036038101906102069190612066565b610de4565b005b610215611189565b6040516102229190612027565b60405180910390f35b61023361118f565b6040516102409190612404565b60405180910390f35b60036020528060005260406000206000915090508060000154908060010160009054906101000a900473ffffffffffffffffffffffffffffffffffffffff16908060010160149054906101000a900460ff16908060020154908060030154908060040154908060050154908060060160009054906101000a900460ff16908060060160019054906101000a900460ff16905089565b61012c81565b6000600360003373ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff1681526020019081526020016000209050600073ffffffffffffffffffffffffffffffffffffffff168160010160009054906101000a900473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16036103ba576040517f08c379a00000000000000000000000000000000000000000000000000000000081526004016103b190612472565b60405180910390fd5b61012c81600001546103cc91906124c1565b4211806103e757508060010160149054906101000a900460ff165b610426576040517f08c379a000000000000000000000000000000000000000000000000000000000815260040161041d90612567565b60405180910390fd5b42816000018190555060008160010160146101000a81548160ff02191690831515021790555060008160060160006101000a81548160ff021916908360ff16021790555060008160060160016101000a81548160ff0219169083151502179055503373ffffffffffffffffffffffffffffffffffffffff167f5551f52823ba301440592c9fc2e93c6a6fb8d0cd41bd1cfa6f020b59400695fa60405160405180910390a250565b816104d79061275e565b600260009054906101000a900473ffffffffffffffffffffffffffffffffffffffff1660006105517f6bdaeb2d29561f159c7ef98b16b27015fb2aeb87209c7ee656226d912f59927d8460000151604051602001610536929190612771565b604051602081830303815290604052805190602001206112d9565b905060006105638285602001516112f3565b90508273ffffffffffffffffffffffffffffffffffffffff168173ffffffffffffffffffffffffffffffffffffffff16146105ca576040517f51c65eae00000000000000000000000000000000000000000000000000000000815260040160405180910390fd5b6001600460008773ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16815260200190815260200160002060006101000a81548160ff021916908315150217905550505050505050565b816106349061275e565b600260009054906101000a900473ffffffffffffffffffffffffffffffffffffffff1660006106ae7f6bdaeb2d29561f159c7ef98b16b27015fb2aeb87209c7ee656226d912f59927d8460000151604051602001610693929190612771565b604051602081830303815290604052805190602001206112d9565b905060006106c08285602001516112f3565b90508273ffffffffffffffffffffffffffffffffffffffff168173ffffffffffffffffffffffffffffffffffffffff1614610727576040517f51c65eae00000000000000000000000000000000000000000000000000000000815260040160405180910390fd5b6000600460008773ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16815260200190815260200160002060006101000a81548160ff021916908315150217905550505050505050565b6000600360008473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16815260200190815260200160002090508060010160009054906101000a900473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff163373ffffffffffffffffffffffffffffffffffffffff161461085c576040517f08c379a0000000000000000000000000000000000000000000000000000000008152600401610853906127e6565b60405180910390fd5b61012c816000015461086e91906124c1565b4211156108b0576040517f08c379a00000000000000000000000000000000000000000000000000000000081526004016108a790612852565b60405180910390fd5b60018160010160146101000a81548160ff0219169083151502179055504281600201819055506108e8826108e3906128ca565b61131f565b816003018190555061012c426108fe91906124c1565b81600501819055503373ffffffffffffffffffffffffffffffffffffffff168373ffffffffffffffffffffffffffffffffffffffff167f9331a3c7a93bcdc2ae741e8ba8b724b1952cc8d3590b749a60490cfb10f2822260405160405180910390a3505050565b600060608060008060006060610979611335565b610981611370565b46306000801b600067ffffffffffffffff8111156109a2576109a161258c565b5b6040519080825280602002602001820160405280156109d05781602001602082028036833780820191505090505b507f0f00000000000000000000000000000000000000000000000000000000000000959493929190965096509650965096509650965090919293949596565b600084610a1b9061275e565b846000610a737f6bdaeb2d29561f159c7ef98b16b27015fb2aeb87209c7ee656226d912f59927d8460000151604051602001610a58929190612771565b604051602081830303815290604052805190602001206112d9565b90506000610a858285602001516112f3565b90508273ffffffffffffffffffffffffffffffffffffffff168173ffffffffffffffffffffffffffffffffffffffff1614610aec576040517f51c65eae00000000000000000000000000000000000000000000000000000000815260040160405180910390fd5b600460008973ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16815260200190815260200160002060009054906101000a900460ff16610b78576040517f08c379a0000000000000000000000000000000000000000000000000000000008152600401610b6f90612929565b60405180910390fd5b6000600360008973ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16815260200190815260200160002090508060010160149054906101000a900460ff16610c0c576040517f08c379a0000000000000000000000000000000000000000000000000000000008152600401610c0390612995565b60405180910390fd5b8060050154421115610c53576040517f08c379a0000000000000000000000000000000000000000000000000000000008152600401610c4a90612a01565b60405180910390fd5b8060060160019054906101000a900460ff1615610ca5576040517f08c379a0000000000000000000000000000000000000000000000000000000008152600401610c9c90612a6d565b60405180910390fd5b60038160060160009054906101000a900460ff1660ff1610610cfc576040517f08c379a0000000000000000000000000000000000000000000000000000000008152600401610cf390612ad9565b60405180910390fd5b6000610d1088610d0b906128ca565b61131f565b90506000610d228284600301546113ab565b90506000610d2f82611424565b905080610d765760018460060160016101000a81548160ff02191690831515021790555060008460060160006101000a81548160ff021916908360ff160217905550610db1565b83600601600081819054906101000a900460ff1680929190610d9790612af9565b91906101000a81548160ff021916908360ff160217905550505b8098505050505050505050949350505050565b60046020528060005260406000206000915054906101000a900460ff1681565b81610dee9061275e565b6000610e457f6bdaeb2d29561f159c7ef98b16b27015fb2aeb87209c7ee656226d912f59927d8360000151604051602001610e2a929190612771565b604051602081830303815290604052805190602001206112d9565b90506000610e578284602001516112f3565b90503373ffffffffffffffffffffffffffffffffffffffff168173ffffffffffffffffffffffffffffffffffffffff1614610ebe576040517f3093a27700000000000000000000000000000000000000000000000000000000815260040160405180910390fd5b600073ffffffffffffffffffffffffffffffffffffffff168473ffffffffffffffffffffffffffffffffffffffff1603610f2d576040517f08c379a0000000000000000000000000000000000000000000000000000000008152600401610f2490612b6e565b60405180910390fd5b3373ffffffffffffffffffffffffffffffffffffffff168473ffffffffffffffffffffffffffffffffffffffff1603610f9b576040517f08c379a0000000000000000000000000000000000000000000000000000000008152600401610f9290612c00565b60405180910390fd5b604051806101200160405280600081526020018573ffffffffffffffffffffffffffffffffffffffff16815260200160001515815260200160008152602001610fe460006114e7565b81526020018660000135815260200160008152602001600060ff16815260200160001515815250600360003373ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff1681526020019081526020016000206000820151816000015560208201518160010160006101000a81548173ffffffffffffffffffffffffffffffffffffffff021916908373ffffffffffffffffffffffffffffffffffffffff16021790555060408201518160010160146101000a81548160ff021916908315150217905550606082015181600201556080820151816003015560a0820151816004015560c0820151816005015560e08201518160060160006101000a81548160ff021916908360ff1602179055506101008201518160060160016101000a81548160ff0219169083151502179055509050508373ffffffffffffffffffffffffffffffffffffffff163373ffffffffffffffffffffffffffffffffffffffff167f0a31ee9d46a828884b81003c8498156ea6aa15b9b54bdd0ef0b533d9eba57e5560405160405180910390a35050505050565b61012c81565b60606000600360003373ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff1681526020019081526020016000209050600073ffffffffffffffffffffffffffffffffffffffff168160010160009054906101000a900473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff1603611267576040517f08c379a000000000000000000000000000000000000000000000000000000000815260040161125e90612472565b60405180910390fd5b8060010160149054906101000a900460ff166112b8576040517f08c379a00000000000000000000000000000000000000000000000000000000081526004016112af90612995565b60405180910390fd5b6112d3816004015482600301546114fb90919063ffffffff16565b91505090565b60006112ec6112e661150f565b836115c6565b9050919050565b6000806000806113038686611607565b9250925092506113138282611663565b82935050505092915050565b600061132e82600001516117c7565b9050919050565b606061136b60007f00000000000000000000000000000000000000000000000000000000000000006117db90919063ffffffff16565b905090565b60606113a660017f00000000000000000000000000000000000000000000000000000000000000006117db90919063ffffffff16565b905090565b60006113b68361188b565b6113c7576113c460006114e7565b92505b6113d08261188b565b6113e1576113de60006114e7565b91505b60008390506000839050600061141660058484608073ffffffffffffffffffffffffffffffffffffffff166392348b34611898565b905080935050505092915050565b600061142f8261192c565b6114405761143d6000611939565b91505b600082905060006114508261194d565b90506000608073ffffffffffffffffffffffffffffffffffffffff166373cc0154600d846040518363ffffffff1660e01b8152600401611491929190612c75565b602060405180830381865afa1580156114ae573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906114d29190612cd1565b90506114dd816119aa565b9350505050919050565b60006114f48260056119b6565b9050919050565b60606115078383611a58565b905092915050565b60007f000000000000000000000000000000000000000000000000000000000000000073ffffffffffffffffffffffffffffffffffffffff163073ffffffffffffffffffffffffffffffffffffffff1614801561158b57507f000000000000000000000000000000000000000000000000000000000000000046145b156115b8577f000000000000000000000000000000000000000000000000000000000000000090506115c3565b6115c0611a8e565b90505b90565b60006040517f190100000000000000000000000000000000000000000000000000000000000081528360028201528260228201526042812091505092915050565b6000806000604184510361164c5760008060006020870151925060408701519150606087015160001a905061163e88828585611b24565b95509550955050505061165c565b60006002855160001b9250925092505b9250925092565b6000600381111561167757611676612cfe565b5b82600381111561168a57611689612cfe565b5b03156117c357600160038111156116a4576116a3612cfe565b5b8260038111156116b7576116b6612cfe565b5b036116ee576040517ff645eedf00000000000000000000000000000000000000000000000000000000815260040160405180910390fd5b6002600381111561170257611701612cfe565b5b82600381111561171557611714612cfe565b5b0361175a578060001c6040517ffce698f70000000000000000000000000000000000000000000000000000000081526004016117519190612027565b60405180910390fd5b60038081111561176d5761176c612cfe565b5b8260038111156117805761177f612cfe565b5b036117c257806040517fd78bce0c0000000000000000000000000000000000000000000000000000000081526004016117b99190612d2d565b60405180910390fd5b5b5050565b60006117d4826005611c18565b9050919050565b606060ff60001b83146117f8576117f183611cb2565b9050611885565b81805461180490612d77565b80601f016020809104026020016040519081016040528092919081815260200182805461183090612d77565b801561187d5780601f106118525761010080835404028352916020019161187d565b820191906000526020600020905b81548152906001019060200180831161186057829003601f168201915b505050505090505b92915050565b6000808214159050919050565b600060608383886118a88961194d565b6118b18961194d565b6040518463ffffffff1660e01b81526004016118cf93929190612da8565b600060405180830381865afa1580156118ec573d6000803e3d6000fd5b505050506040513d6000823e3d601f19601f820116820180604052508101906119159190612e5d565b905061192081611d26565b91505095945050505050565b6000808214159050919050565b600061194682600d6119b6565b9050919050565b6060602067ffffffffffffffff81111561196a5761196961258c565b5b6040519080825280601f01601f19166020018201604052801561199c5781602001600182028036833780820191505090505b509050816020820152919050565b60008082119050919050565b60006060608073ffffffffffffffffffffffffffffffffffffffff166319e1c5c46119e08661194d565b856040518363ffffffff1660e01b81526004016119fe929190612ea6565b600060405180830381865afa158015611a1b573d6000803e3d6000fd5b505050506040513d6000823e3d601f19601f82011682018060405250810190611a449190612e5d565b9050611a4f81611d34565b91505092915050565b6060611a638361188b565b611a7457611a7160006114e7565b92505b6000839050611a8560058285611d42565b91505092915050565b60007f8b73c3c69bb8fe3d512ecc4cf759cc79239f7b179b0ffacaa9a75d522b39400f7f00000000000000000000000000000000000000000000000000000000000000007f00000000000000000000000000000000000000000000000000000000000000004630604051602001611b09959493929190612ed6565b60405160208183030381529060405280519060200120905090565b60008060007f7fffffffffffffffffffffffffffffff5d576e7357a4501ddfe92f46681b20a08460001c1115611b64576000600385925092509250611c0e565b600060018888888860405160008152602001604052604051611b899493929190612f29565b6020604051602081039080840390855afa158015611bab573d6000803e3d6000fd5b505050602060405103519050600073ffffffffffffffffffffffffffffffffffffffff168173ffffffffffffffffffffffffffffffffffffffff1603611bff57600060016000801b93509350935050611c0e565b8060008060001b935093509350505b9450945094915050565b60006060608073ffffffffffffffffffffffffffffffffffffffff16635fa55ca784866040518363ffffffff1660e01b8152600401611c58929190612c75565b600060405180830381865afa158015611c75573d6000803e3d6000fd5b505050506040513d6000823e3d601f19601f82011682018060405250810190611c9e9190612e5d565b9050611ca981611d34565b91505092915050565b60606000611cbf83611df8565b90506000602067ffffffffffffffff811115611cde57611cdd61258c565b5b6040519080825280601f01601f191660200182016040528015611d105781602001600182028036833780820191505090505b5090508181528360208201528092505050919050565b600060208201519050919050565b600060208201519050919050565b6060608073ffffffffffffffffffffffffffffffffffffffff1663a1848ff385611d6b8661194d565b85604051602001611d7c9190612f8f565b6040516020818303038152906040526040518463ffffffff1660e01b8152600401611da993929190612da8565b600060405180830381865afa158015611dc6573d6000803e3d6000fd5b505050506040513d6000823e3d601f19601f82011682018060405250810190611def919061304b565b90509392505050565b60008060ff8360001c169050601f811115611e3f576040517fb3512b0c00000000000000000000000000000000000000000000000000000000815260040160405180910390fd5b80915050919050565b6000604051905090565b600080fd5b600080fd5b600073ffffffffffffffffffffffffffffffffffffffff82169050919050565b6000611e8782611e5c565b9050919050565b611e9781611e7c565b8114611ea257600080fd5b50565b600081359050611eb481611e8e565b92915050565b600060208284031215611ed057611ecf611e52565b5b6000611ede84828501611ea5565b91505092915050565b6000819050919050565b611efa81611ee7565b82525050565b611f0981611e7c565b82525050565b60008115159050919050565b611f2481611f0f565b82525050565b6000819050919050565b6000611f4f611f4a611f4584611ee7565b611f2a565b611ee7565b9050919050565b611f5f81611f34565b82525050565b6000819050919050565b611f7881611f65565b82525050565b600060ff82169050919050565b611f9481611f7e565b82525050565b600061012082019050611fb0600083018c611ef1565b611fbd602083018b611f00565b611fca604083018a611f1b565b611fd76060830189611ef1565b611fe46080830188611f56565b611ff160a0830187611f6f565b611ffe60c0830186611ef1565b61200b60e0830185611f8b565b612019610100830184611f1b565b9a9950505050505050505050565b600060208201905061203c6000830184611ef1565b92915050565b600080fd5b60006040828403121561205d5761205c612042565b5b81905092915050565b6000806040838503121561207d5761207c611e52565b5b600083013567ffffffffffffffff81111561209b5761209a611e57565b5b6120a785828601612047565b92505060206120b885828601611ea5565b9150509250929050565b6000602082840312156120d8576120d7612042565b5b81905092915050565b600080604083850312156120f8576120f7611e52565b5b600061210685828601611ea5565b925050602083013567ffffffffffffffff81111561212757612126611e57565b5b612133858286016120c2565b9150509250929050565b60007fff0000000000000000000000000000000000000000000000000000000000000082169050919050565b6121728161213d565b82525050565b600081519050919050565b600082825260208201905092915050565b60005b838110156121b2578082015181840152602081019050612197565b60008484015250505050565b6000601f19601f8301169050919050565b60006121da82612178565b6121e48185612183565b93506121f4818560208601612194565b6121fd816121be565b840191505092915050565b600081519050919050565b600082825260208201905092915050565b6000819050602082019050919050565b61223d81611ee7565b82525050565b600061224f8383612234565b60208301905092915050565b6000602082019050919050565b600061227382612208565b61227d8185612213565b935061228883612224565b8060005b838110156122b95781516122a08882612243565b97506122ab8361225b565b92505060018101905061228c565b5085935050505092915050565b600060e0820190506122db600083018a612169565b81810360208301526122ed81896121cf565b9050818103604083015261230181886121cf565b90506123106060830187611ef1565b61231d6080830186611f00565b61232a60a0830185611f6f565b81810360c083015261233c8184612268565b905098975050505050505050565b6000806000806080858703121561236457612363611e52565b5b600085013567ffffffffffffffff81111561238257612381611e57565b5b61238e87828801612047565b945050602061239f87828801611ea5565b93505060406123b087828801611ea5565b925050606085013567ffffffffffffffff8111156123d1576123d0611e57565b5b6123dd878288016120c2565b91505092959194509250565b60006020820190506123fe6000830184611f1b565b92915050565b6000602082019050818103600083015261241e81846121cf565b905092915050565b7f55736572206e6f74207265676973746572656400000000000000000000000000600082015250565b600061245c601383612183565b915061246782612426565b602082019050919050565b6000602082019050818103600083015261248b8161244f565b9050919050565b7f4e487b7100000000000000000000000000000000000000000000000000000000600052601160045260246000fd5b60006124cc82611ee7565b91506124d783611ee7565b92508282019050808211156124ef576124ee612492565b5b92915050565b7f50726576696f7573206c6f67696e2072657175657374207374696c6c2070656e60008201527f64696e6700000000000000000000000000000000000000000000000000000000602082015250565b6000612551602483612183565b915061255c826124f5565b604082019050919050565b6000602082019050818103600083015261258081612544565b9050919050565b600080fd5b7f4e487b7100000000000000000000000000000000000000000000000000000000600052604160045260246000fd5b6125c4826121be565b810181811067ffffffffffffffff821117156125e3576125e261258c565b5b80604052505050565b60006125f6611e48565b905061260282826125bb565b919050565b600080fd5b61261581611f65565b811461262057600080fd5b50565b6000813590506126328161260c565b92915050565b600080fd5b600080fd5b600067ffffffffffffffff82111561265d5761265c61258c565b5b612666826121be565b9050602081019050919050565b82818337600083830152505050565b600061269561269084612642565b6125ec565b9050828152602081018484840111156126b1576126b061263d565b5b6126bc848285612673565b509392505050565b600082601f8301126126d9576126d8612638565b5b81356126e9848260208601612682565b91505092915050565b60006040828403121561270857612707612587565b5b61271260406125ec565b9050600061272284828501612623565b600083015250602082013567ffffffffffffffff81111561274657612745612607565b5b612752848285016126c4565b60208301525092915050565b600061276a36836126f2565b9050919050565b60006040820190506127866000830185611f6f565b6127936020830184611f6f565b9392505050565b7f4e6f7420617574686f72697a6564000000000000000000000000000000000000600082015250565b60006127d0600e83612183565b91506127db8261279a565b602082019050919050565b600060208201905081810360008301526127ff816127c3565b9050919050565b7f54696d6520696e74657276616c20657870697265640000000000000000000000600082015250565b600061283c601583612183565b915061284782612806565b602082019050919050565b6000602082019050818103600083015261286b8161282f565b9050919050565b60006020828403121561288857612887612587565b5b61289260206125ec565b9050600082013567ffffffffffffffff8111156128b2576128b1612607565b5b6128be848285016126c4565b60008301525092915050565b60006128d63683612872565b9050919050565b7f53657276696365206e6f742077686974656c6973746564000000000000000000600082015250565b6000612913601783612183565b915061291e826128dd565b602082019050919050565b6000602082019050818103600083015261294281612906565b9050919050565b7f4c6f67696e206e6f7420617070726f7665640000000000000000000000000000600082015250565b600061297f601283612183565b915061298a82612949565b602082019050919050565b600060208201905081810360008301526129ae81612972565b9050919050565b7f50617373776f7264206861732065787069726564000000000000000000000000600082015250565b60006129eb601483612183565b91506129f6826129b5565b602082019050919050565b60006020820190508181036000830152612a1a816129de565b9050919050565b7f50617373776f726420686173206265656e207573656400000000000000000000600082015250565b6000612a57601683612183565b9150612a6282612a21565b602082019050919050565b60006020820190508181036000830152612a8681612a4a565b9050919050565b7f546f6f206d616e7920617474656d707473000000000000000000000000000000600082015250565b6000612ac3601183612183565b9150612ace82612a8d565b602082019050919050565b60006020820190508181036000830152612af281612ab6565b9050919050565b6000612b0482611f7e565b915060ff8203612b1757612b16612492565b5b600182019050919050565b7f496e76616c6964207365636f6e64617279207369676e65722061646472657373600082015250565b6000612b58602083612183565b9150612b6382612b22565b602082019050919050565b60006020820190508181036000830152612b8781612b4b565b9050919050565b7f5365636f6e64617279207369676e65722063616e6e6f7420626520746865207360008201527f616d6520617320746865207072696d6172792075736572000000000000000000602082015250565b6000612bea603783612183565b9150612bf582612b8e565b604082019050919050565b60006020820190508181036000830152612c1981612bdd565b9050919050565b600081519050919050565b600082825260208201905092915050565b6000612c4782612c20565b612c518185612c2b565b9350612c61818560208601612194565b612c6a816121be565b840191505092915050565b6000604082019050612c8a6000830185611f8b565b8181036020830152612c9c8184612c3c565b90509392505050565b612cae81611ee7565b8114612cb957600080fd5b50565b600081519050612ccb81612ca5565b92915050565b600060208284031215612ce757612ce6611e52565b5b6000612cf584828501612cbc565b91505092915050565b7f4e487b7100000000000000000000000000000000000000000000000000000000600052602160045260246000fd5b6000602082019050612d426000830184611f6f565b92915050565b7f4e487b7100000000000000000000000000000000000000000000000000000000600052602260045260246000fd5b60006002820490506001821680612d8f57607f821691505b602082108103612da257612da1612d48565b5b50919050565b6000606082019050612dbd6000830186611f8b565b8181036020830152612dcf8185612c3c565b90508181036040830152612de38184612c3c565b9050949350505050565b6000612e00612dfb84612642565b6125ec565b905082815260208101848484011115612e1c57612e1b61263d565b5b612e27848285612194565b509392505050565b600082601f830112612e4457612e43612638565b5b8151612e54848260208601612ded565b91505092915050565b600060208284031215612e7357612e72611e52565b5b600082015167ffffffffffffffff811115612e9157612e90611e57565b5b612e9d84828501612e2f565b91505092915050565b60006040820190508181036000830152612ec08185612c3c565b9050612ecf6020830184611f8b565b9392505050565b600060a082019050612eeb6000830188611f6f565b612ef86020830187611f6f565b612f056040830186611f6f565b612f126060830185611ef1565b612f1f6080830184611f00565b9695505050505050565b6000608082019050612f3e6000830187611f6f565b612f4b6020830186611f8b565b612f586040830185611f6f565b612f656060830184611f6f565b95945050505050565b6000819050919050565b612f89612f8482611f65565b612f6e565b82525050565b6000612f9b8284612f78565b60208201915081905092915050565b600067ffffffffffffffff821115612fc557612fc461258c565b5b612fce826121be565b9050602081019050919050565b6000612fee612fe984612faa565b6125ec565b90508281526020810184848401111561300a5761300961263d565b5b613015848285612194565b509392505050565b600082601f83011261303257613031612638565b5b8151613042848260208601612fdb565b91505092915050565b60006020828403121561306157613060611e52565b5b600082015167ffffffffffffffff81111561307f5761307e611e57565b5b61308b8482850161301d565b9150509291505056fea2646970667358221220fe5434d99175ec7d43e58f4e0c6986f33fcbdc2810cecd874ac910df87b8253964736f6c63430008190033",
  "devdoc": {
    "details": "A smart contract for implementing a two-factor authentication (2FA) system. This contract allows users to register, request login, approve login, and verify temporary passwords.",
    "errors": {
      "ECDSAInvalidSignature()": [
        {
          "details": "The signature derives the `address(0)`."
        }
      ],
      "ECDSAInvalidSignatureLength(uint256)": [
        {
          "details": "The signature has an invalid length."
        }
      ],
      "ECDSAInvalidSignatureS(bytes32)": [
        {
          "details": "The signature has an S value that is in the upper half order."
        }
      ]
    },
    "events": {
      "EIP712DomainChanged()": {
        "details": "MAY be emitted to signal that the domain could have changed."
      }
    },
    "kind": "dev",
    "methods": {
      "addServiceToWhitelist((bytes32,bytes),address)": {
        "details": "Adds a service to the whitelist.",
        "params": {
          "perm": "The permission object for access control.",
          "service": "The address of the service to be added."
        }
      },
      "approveLogin(address,(bytes))": {
        "details": "Approves a login request from the secondary signer.",
        "params": {
          "_user": "The address of the user requesting login."
        }
      },
      "eip712Domain()": {
        "details": "See {IERC-5267}."
      },
      "getEncryptedPassword()": {
        "details": "Retrieves the encrypted password for a user.",
        "returns": {
          "encryptedPassword": "The sealed encrypted password."
        }
      },
      "register((bytes32,bytes),address)": {
        "details": "Registers a user with a secondary signer and user public key.",
        "params": {
          "_secondarySigner": "The address of the secondary signer.",
          "perm": "The permission object for access control."
        }
      },
      "removeServiceFromWhitelist((bytes32,bytes),address)": {
        "details": "Removes a service from the whitelist.",
        "params": {
          "perm": "The permission object for access control.",
          "service": "The address of the service to be removed."
        }
      },
      "requestLogin()": {
        "details": "Requests a login, resetting the approval status."
      },
      "verifyTempPassword((bytes32,bytes),address,address,(bytes))": {
        "details": "Verifies the temporary password for a user by a whitelisted service.",
        "params": {
          "_encryptedTempPassword": "The encrypted temporary password provided by the service.",
          "_service": "The address of the service verifying the password.",
          "_user": "The address of the user.",
          "perm": "The permission object for access control."
        },
        "returns": {
          "_0": "True if the password is valid, false otherwise."
        }
      }
    },
    "title": "TwoFactorAuth",
    "version": 1
  },
  "userdoc": {
    "errors": {
      "SignerNotMessageSender()": [
        {
          "notice": "Emitted when the signer is not the message sender"
        }
      ],
      "SignerNotOwner()": [
        {
          "notice": "Emitted when the signer is not the specified owner"
        }
      ]
    },
    "kind": "user",
    "methods": {},
    "version": 1
  },
  "storageLayout": {
    "storage": [
      {
        "astId": 19906,
        "contract": "contracts/TwoFactorAuth.sol:TwoFactorAuth",
        "label": "_nameFallback",
        "offset": 0,
        "slot": "0",
        "type": "t_string_storage"
      },
      {
        "astId": 19908,
        "contract": "contracts/TwoFactorAuth.sol:TwoFactorAuth",
        "label": "_versionFallback",
        "offset": 0,
        "slot": "1",
        "type": "t_string_storage"
      },
      {
        "astId": 21368,
        "contract": "contracts/TwoFactorAuth.sol:TwoFactorAuth",
        "label": "owner",
        "offset": 0,
        "slot": "2",
        "type": "t_address"
      },
      {
        "astId": 21373,
        "contract": "contracts/TwoFactorAuth.sol:TwoFactorAuth",
        "label": "authData",
        "offset": 0,
        "slot": "3",
        "type": "t_mapping(t_address,t_struct(AuthData)21366_storage)"
      },
      {
        "astId": 21377,
        "contract": "contracts/TwoFactorAuth.sol:TwoFactorAuth",
        "label": "whitelistedServices",
        "offset": 0,
        "slot": "4",
        "type": "t_mapping(t_address,t_bool)"
      }
    ],
    "types": {
      "t_address": {
        "encoding": "inplace",
        "label": "address",
        "numberOfBytes": "20"
      },
      "t_bool": {
        "encoding": "inplace",
        "label": "bool",
        "numberOfBytes": "1"
      },
      "t_bytes32": {
        "encoding": "inplace",
        "label": "bytes32",
        "numberOfBytes": "32"
      },
      "t_mapping(t_address,t_bool)": {
        "encoding": "mapping",
        "key": "t_address",
        "label": "mapping(address => bool)",
        "numberOfBytes": "32",
        "value": "t_bool"
      },
      "t_mapping(t_address,t_struct(AuthData)21366_storage)": {
        "encoding": "mapping",
        "key": "t_address",
        "label": "mapping(address => struct TwoFactorAuth.AuthData)",
        "numberOfBytes": "32",
        "value": "t_struct(AuthData)21366_storage"
      },
      "t_string_storage": {
        "encoding": "bytes",
        "label": "string",
        "numberOfBytes": "32"
      },
      "t_struct(AuthData)21366_storage": {
        "encoding": "inplace",
        "label": "struct TwoFactorAuth.AuthData",
        "members": [
          {
            "astId": 21348,
            "contract": "contracts/TwoFactorAuth.sol:TwoFactorAuth",
            "label": "lastRequestTime",
            "offset": 0,
            "slot": "0",
            "type": "t_uint256"
          },
          {
            "astId": 21350,
            "contract": "contracts/TwoFactorAuth.sol:TwoFactorAuth",
            "label": "secondarySigner",
            "offset": 0,
            "slot": "1",
            "type": "t_address"
          },
          {
            "astId": 21352,
            "contract": "contracts/TwoFactorAuth.sol:TwoFactorAuth",
            "label": "isApproved",
            "offset": 20,
            "slot": "1",
            "type": "t_bool"
          },
          {
            "astId": 21354,
            "contract": "contracts/TwoFactorAuth.sol:TwoFactorAuth",
            "label": "lastApprovalTime",
            "offset": 0,
            "slot": "2",
            "type": "t_uint256"
          },
          {
            "astId": 21357,
            "contract": "contracts/TwoFactorAuth.sol:TwoFactorAuth",
            "label": "encryptedPassword",
            "offset": 0,
            "slot": "3",
            "type": "t_userDefinedValueType(euint256)18"
          },
          {
            "astId": 21359,
            "contract": "contracts/TwoFactorAuth.sol:TwoFactorAuth",
            "label": "userPublicKey",
            "offset": 0,
            "slot": "4",
            "type": "t_bytes32"
          },
          {
            "astId": 21361,
            "contract": "contracts/TwoFactorAuth.sol:TwoFactorAuth",
            "label": "validUntil",
            "offset": 0,
            "slot": "5",
            "type": "t_uint256"
          },
          {
            "astId": 21363,
            "contract": "contracts/TwoFactorAuth.sol:TwoFactorAuth",
            "label": "passwordAttempts",
            "offset": 0,
            "slot": "6",
            "type": "t_uint8"
          },
          {
            "astId": 21365,
            "contract": "contracts/TwoFactorAuth.sol:TwoFactorAuth",
            "label": "passwordUsed",
            "offset": 1,
            "slot": "6",
            "type": "t_bool"
          }
        ],
        "numberOfBytes": "224"
      },
      "t_uint256": {
        "encoding": "inplace",
        "label": "uint256",
        "numberOfBytes": "32"
      },
      "t_uint8": {
        "encoding": "inplace",
        "label": "uint8",
        "numberOfBytes": "1"
      },
      "t_userDefinedValueType(euint256)18": {
        "encoding": "inplace",
        "label": "euint256",
        "numberOfBytes": "32"
      }
    }
  }
}
